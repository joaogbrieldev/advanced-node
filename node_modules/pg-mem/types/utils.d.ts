import moment from 'moment';
import { IValue, RegClass, _ISchema, _ISelection, _IType, _Transaction } from './interfaces-private';
import { DataTypeDef, Expr, ExprRef, Interval, nil, QName } from 'pgsql-ast-parser';
import { ISubscription, IType } from './interfaces';
export interface Ctor<T> extends Function {
    new (...params: any[]): T;
    prototype: T;
}
export declare type Optional<T> = {
    [key in keyof T]?: T[key];
};
export declare type SRecord<T> = Record<string, T>;
export declare function trimNullish<T>(value: T, depth?: number): T;
export declare function watchUse<T>(rootValue: T): {
    checked: T;
    check?: () => string | null;
};
export declare function deepEqual<T>(a: T, b: T, strict?: boolean, depth?: number, numberDelta?: number): boolean;
export declare function deepCompare<T>(a: T, b: T, strict?: boolean, depth?: number, numberDelta?: number): number;
declare type Json = {
    [key: string]: Json;
} | Json[] | string | number | null;
export declare function queryJson(a: Json, b: Json): boolean;
export declare function buildLikeMatcher(likeCondition: string, caseSensitive?: boolean): (stringToMatch: string | number) => boolean | null;
export declare function nullIsh(v: any): boolean;
export declare function hasNullish(...vals: any[]): boolean;
export declare function sum(v: number[]): number;
export declare function deepCloneSimple<T>(v: T): T;
export declare function isSelectAllArgList(select: Expr[]): boolean;
export declare function ignore(...val: any[]): void;
export declare function combineSubs(...vals: ISubscription[]): ISubscription;
interface Ctx {
    schema: _ISchema;
    transaction: _Transaction;
}
export declare function getContext(): Ctx;
export declare function pushContext<T>(ctx: Ctx, act: () => T): T;
export declare function indexHash(this: void, vals: (IValue | string)[]): string;
export declare function randomString(length?: number, chars?: string): string;
export declare function schemaOf(t: DataTypeDef): string | nil;
export declare function isType(t: any): t is (_IType | IType);
export declare namespace isType {
    var TAG: symbol;
}
export declare function suggestColumnName(expr: Expr | nil): string | null;
export declare function findTemplate<T>(this: void, selection: _ISelection, t: _Transaction, template?: T, columns?: (keyof T)[]): Iterable<T>;
export declare function compareVersions(_a: string, _b: string): number;
export declare function intervalToSec(v: Interval): number;
export declare function parseRegClass(_reg: RegClass): QName | number;
export declare function parseTime(str: string): moment.Moment;
export declare function colByName<T>(refs: Map<string, T>, ref: string | ExprRef, nullIfNotFound: boolean | nil): T | nil;
export declare function colToStr(col: string | ExprRef): string;
export declare function qnameToStr(col: string | QName): string;
export declare function asSingleName(col: string | ExprRef): string | nil;
export declare function asSingleQName(col: string | QName, allowedSchema?: string): string | nil;
export {};
//# sourceMappingURL=utils.d.ts.map