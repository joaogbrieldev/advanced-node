import { TransformBase } from './transform-base';
import { _ISelection, _Transaction, IValue, _IIndex, _Explainer, _SelectExplanation, Stats } from '../interfaces-private';
import { SelectedColumn, Expr, ExprRef, ExprCall } from 'pgsql-ast-parser';
import { nil } from '../interfaces';
export declare const aggregationFunctions: Set<string>;
export declare function buildGroupBy(on: _ISelection, groupBy: Expr[], select: SelectedColumn[]): Aggregation<unknown>;
export declare class Aggregation<T> extends TransformBase<T> implements _ISelection<T> {
    private readonly groupedBy;
    columns: readonly IValue<any>[];
    /**
     * Group-by values
     * - key: column in source hash
     * - value: column in this, evaluated against temporary entity.
     **/
    private groupByMapping;
    private building;
    private readonly symbol;
    private readonly groupIndex?;
    private columnsById;
    private aggregations;
    constructor(on: _ISelection, groupedBy: IValue[], select: SelectedColumn[]);
    entropy(t: _Transaction): number;
    stats(): Stats | null;
    enumerate(t: _Transaction): Iterable<T>;
    private _enumerate;
    private seqScan;
    computeDirect(t: _Transaction): any;
    checkIfIsKey(got: IValue<any>): IValue<any>;
    getColumn(column: string | ExprRef): IValue;
    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;
    getAggregation(name: string, call: ExprCall): IValue;
    private _getAggregation;
    hasItem(value: T, t: _Transaction): boolean;
    getIndex(forValue: IValue<any>): _IIndex<any> | nil;
    explain(e: _Explainer): _SelectExplanation;
}
//# sourceMappingURL=aggregation.d.ts.map