{"version":3,"sources":["webpack/bootstrap","./src/interfaces-private.ts","./src/utils.ts","./src/interfaces.ts","./src/datatypes/index.ts","./src/transforms/transform-base.ts","./src/expression-builder.ts","./src/datatypes/datatype-base.ts","./src/schema/readonly-table.ts","external \"pgsql-ast-parser\"","external \"object-hash\"","./src/evaluator.ts","./src/datatypes/datatypes.ts","./src/transforms/selection.ts","external \"immutable\"","external \"moment\"","./src/clean-results.ts","./src/buffer-node.ts","external \"lru-cache\"","./src/transforms/aggregation.ts","./src/transforms/alias.ts","./src/parse-cache.ts","./src/schema/table-index.ts","./src/pg-escape.ts","./src/transforms/seq-scan.ts","./src/index.ts","./src/db.ts","./src/schema.ts","./src/datatypes/datatypes-geometric.ts","./src/datatypes/t-interval.ts","./src/datatypes/t-time.ts","./src/datatypes/t-timestamp.ts","./src/datatypes/t-jsonb.ts","./src/datatypes/t-regtype.ts","./src/datatypes/t-regclass.ts","./src/datatypes/t-record.ts","./src/datatypes/t-inet.ts","./src/function-call.ts","./src/transforms/restrictive-index.ts","./src/transforms/aggregations/count.ts","./src/transforms/aggregations/max-min.ts","./src/transforms/aggregations/sum.ts","./src/transforms/aggregations/array_agg.ts","./src/transforms/aggregations/avg.ts","./src/transforms/join.ts","./src/table.ts","./src/btree-index.ts","external \"functional-red-black-tree\"","./src/column.ts","./src/constraints/generated.ts","./src/constraints/foreign-key.ts","./src/transforms/array-filter.ts","./src/sequence.ts","./src/migrate/migrate.ts","./src/datatypes/t-custom-enum.ts","./src/schema/values-table.ts","./src/datatypes/t-equivalent.ts","./src/view.ts","./src/transforms/build-filter.ts","./src/transforms/eq-filter.ts","./src/transforms/false-filter.ts","./src/transforms/and-filter.ts","./src/transforms/or-filter.ts","./src/transforms/in-filter.ts","./src/transforms/not-in-filter.ts","./src/transforms/startswith-filter.ts","./src/transforms/ineq-filter.ts","./src/transforms/between-filter.ts","./src/adapters.ts","./src/transaction.ts","./src/transforms/limit.ts","./src/transforms/union.ts","./src/transforms/distinct.ts","./src/transforms/order-by.ts","./src/schema/pg-catalog/index.ts","./src/schema/pg-catalog/pg-attribute-list.ts","./src/schema/pg-catalog/pg-class.ts","./src/schema/pg-catalog/pg-constraints-list.ts","./src/schema/pg-catalog/pg-index-list.ts","./src/schema/pg-catalog/pg-namespace-list.ts","./src/schema/pg-catalog/pg-type-list.ts","./src/functions/index.ts","./src/functions/string.ts","./src/functions/date.ts","./src/functions/system.ts","./src/functions/sequence-fns.ts","./src/schema/pg-catalog/pg-range.ts","./src/schema/pg-catalog/pg-database.ts","./src/schema/information-schema/index.ts","./src/schema/information-schema/columns-list.ts","./src/schema/information-schema/table-list.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 24);\n","import { IMemoryDb, IMemoryTable, DataType, IType, TableEvent, GlobalEvent, ISchema, SchemaField, MemoryDbOptions, nil, FunctionDefinition, Schema, QueryError, ISubscription, LanguageCompiler, ArgDefDetails } from './interfaces';\nimport { Expr, SelectedColumn, SelectStatement, CreateColumnDef, AlterColumn, LimitStatement, OrderByStatement, TableConstraint, AlterSequenceChange, CreateSequenceOptions, QName, DataTypeDef, ExprRef } from 'pgsql-ast-parser';\nimport { Map as ImMap, Record, List, Set as ImSet } from 'immutable';\n\nexport * from './interfaces';\n\n\nexport const GLOBAL_VARS = Symbol('_global_vars');\n\n// export type PrimaryKey = string | number;\nconst ID = Symbol('_id');\nexport function getId(item: any): string {\n    if (!item) {\n        return '';\n    }\n    const got = item[ID];\n    if (!got) {\n        throw new Error('Unexpected: cannot get an ID of something which is not a record');\n    }\n    return got;\n}\n\nexport function setId<T = any>(item: T, id: string): T {\n    const got = (item as any)[ID];\n    if (got === id) {\n        return item;\n    }\n    if (got) {\n        throw new Error('Unexpected: Cannot update an ID');\n    }\n    (item as any)[ID] = id;\n    return item;\n}\n\nexport type RegClass = string | number;\nexport type RegType = string | number;\nexport type TypeQuery = DataTypeDef | DataType | number | _IType;\nexport interface _ISchema extends ISchema {\n    readonly name: string;\n    readonly db: _IDb;\n    readonly dualTable: _ITable;\n    buildSelect(p: SelectStatement): _ISelection;\n    explainSelect(sql: string): _SelectExplanation;\n    explainLastSelect(): _SelectExplanation | undefined;\n    getTable(table: string): _ITable;\n    getTable(table: string, nullIfNotFound?: boolean): _ITable;\n    tablesCount(t: _Transaction): number;\n    listTables(t: _Transaction): Iterable<_ITable>;\n    declareTable(table: Schema, noSchemaChange?: boolean): _ITable;\n    createSequence(t: _Transaction, opts: CreateSequenceOptions | nil, name: QName | nil): _ISequence;\n    /** Get functions matching this arrity */\n    getFunctions(name: string | QName, arrity: number, forceOwn?: boolean): Iterable<_FunctionDefinition>;\n\n    getObject(p: QName): _IRelation;\n    getObject(p: QName, opts: BeingCreated): _IRelation;\n    getObject(p: QName, opts?: QueryObjOpts): _IRelation | null;\n\n    getOwnObject(name: string): _IRelation | null;\n\n    parseType(t: string): _IType;\n\n\n    getType(t: TypeQuery): _IType;\n    getType(_t: TypeQuery, opts?: QueryObjOpts): _IType | null;\n\n    getOwnType(name: DataTypeDef): _IType | null\n\n    getObjectByRegClassId(reg: number): _IRelation;\n    getObjectByRegClassId(reg: number, opts?: QueryObjOpts): _IRelation | null;\n\n    getOwnObjectByRegClassId(reg: number): _IRelation | null;\n\n    getObjectByRegOrName(reg: RegClass): _IRelation;\n    getObjectByRegOrName(reg: RegClass, opts?: QueryObjOpts): _IRelation | null;\n\n    setReadonly(): void;\n\n    _registerTypeSizeable(name: string, type: (sz?: number) => _IType): this;\n    _registerType(type: _IType): this;\n\n    _reg_register(rel: _IRelation): Reg;\n    _reg_unregister(rel: _IRelation): void;\n    _reg_rename(rel: _IRelation, oldName: string, newName: string): void;\n}\n\nexport interface QueryObjOpts extends Partial<BeingCreated> {\n    /** Returns null instead of throwing error if not found */\n    nullIfNotFound?: boolean;\n    /** Will only search in the current schema, or in the targeted schema (not in search path) */\n    skipSearch?: boolean;\n}\n\nexport interface BeingCreated {\n    beingCreated: _IRelation;\n}\n\nexport interface _FunctionDefinition {\n    args: _ArgDefDetails[];\n    argsVariadic?: _IType | nil;\n    returns?: _IType | nil;\n    impure?: boolean;\n    allowNullArguments?: boolean;\n    implementation: (...args: any[]) => any;\n}\n\n\nexport type _ArgDefDetails = ArgDefDetails & {\n    type: _IType;\n    default?: IValue;\n};\n\nexport interface _Transaction {\n    readonly isChild: boolean;\n    /** Create a new transaction within this transaction */\n    fork(): _Transaction;\n    /** Commit this transaction (returns the parent transaction) */\n    commit(): _Transaction;\n    /** Commits this transaction and all underlying transactions */\n    fullCommit(): _Transaction;\n    rollback(): _Transaction;\n    delete(identity: symbol): void;\n    set<T>(identity: symbol, data: T): T;\n    get<T>(identity: symbol): T;\n    getMap<T extends ImMap<any, any>>(identity: symbol): T;\n    getSet<T>(identity: symbol): ImSet<T>;\n}\n\nexport interface Stats {\n    /** Returns this selection size, or null if it cannot be computed without iteration */\n    count: number;\n}\n\nexport interface _ISelection<T = any> extends _IAlias {\n    readonly debugId?: string;\n\n    readonly ownerSchema: _ISchema;\n    readonly db: _IDb;\n    /** Column list (those visible when select *) */\n    readonly columns: ReadonlyArray<IValue>;\n    /** Statistical measure of how many items will be returned by this selection */\n    entropy(t: _Transaction): number;\n    enumerate(t: _Transaction): Iterable<T>;\n\n    /** Returns true if the given value is present in this */\n    hasItem(value: T, t: _Transaction): boolean;\n\n    stats(t: _Transaction): Stats | null;\n\n    /** Gets the index associated with this value (or returns null) */\n    getIndex(...forValue: IValue[]): _IIndex<T> | nil;\n    /** All columns. A bit like .columns`, but including records selections */\n    listSelectableIdentities(): Iterable<IValue>;\n    filter(where: Expr | nil): _ISelection;\n    limit(limit: LimitStatement): _ISelection;\n    orderBy(orderBy: OrderByStatement[] | nil): _ISelection;\n    groupBy(grouping: Expr[] | nil, select: SelectedColumn[]): _ISelection;\n    distinct(select?: Expr[]): _ISelection;\n    union(right: _ISelection): _ISelection;\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    setAlias(alias?: string): _ISelection;\n    subquery(data: _ISelection, op: SelectStatement): _ISelection;\n    isOriginOf(a: IValue): boolean;\n    explain(e: _Explainer): _SelectExplanation;\n\n    /** Select a specific subset */\n    select(select: (string | SelectedColumn)[]): _ISelection;\n\n    /** Limit selection to a specific alias (in joins) */\n    selectAlias(alias: string): _IAlias | nil;\n}\n\nexport interface _IAlias {\n    listColumns(): Iterable<IValue>;\n}\n\n\nexport interface _Explainer {\n    readonly transaction: _Transaction;\n    idFor(sel: _ISelection): string | number;\n}\n\nexport type _SelectExplanation = {\n    /** A jointure */\n    id: string | number;\n    _: 'join';\n    /**  The restrictive table (the one which MUST have a matched elemnt) */\n    restrictive: _SelectExplanation;\n    /** The joined table */\n    joined: _SelectExplanation;\n    inner: boolean;\n    on: {\n        /** 'with' will have to be scanned with this expression */\n        seqScan: _ExprExplanation;\n    } | {\n        /** Which seq id will be iterated (could be either 'join' or 'with' when there is an inner join) */\n        iterate: string | number;\n        /** Which iteration side has been chosen (always 'restrictive' for non inner joins) */\n        iterateSide: 'joined' | 'restrictive';\n        /** the index table on the other table that can be used to lookup corresponding item(s) */\n        joinIndex: _IndexExplanation;\n        /** It will be matched with this expression (computable from the other table) */\n        matches: _ExprExplanation;\n        /** True if there is a predicate filter that is also applied (happens when there are 'ANDs' in join condition) */\n        filtered?: boolean;\n    }\n} | {\n    /** A selection transformation */\n    id: string | number;\n    _: 'map';\n    select?: {\n        what: _ExprExplanation;\n        as: string;\n    }[];\n    of: _SelectExplanation;\n} | {\n    id: string | number;\n    _: 'orderBy';\n    of: _SelectExplanation;\n} | {\n    /** A selection transformation */\n    id: string | number;\n    _: 'limit';\n    take?: _ExprExplanation;\n    skip?: _ExprExplanation;\n    on: _SelectExplanation;\n} | {\n    /** A selection transformation */\n    id: string | number;\n    _: 'distinct';\n    of: _SelectExplanation;\n} | {\n    /** A table */\n    _: 'table';\n    table: string;\n} | {\n    /** An AND filter */\n    id: string | number;\n    _: 'and',\n    enumerate: _SelectExplanation;\n    andCheck: _SelectExplanation[];\n} | {\n    /** A raw array definition */\n    id: string | number;\n    _: 'constantSet';\n    rawArrayLen: number;\n} | {\n    /** One of the following operators on an index:\n     * - (NOT) IN\n     * - (NOT) LIKE\n     * - (NOT) BETWEEN\n     * - < > <= >= = !=\n     *\n     * (against constants) */\n    id: string | number;\n    _: 'eq' | 'ineq' | 'neq' | 'inside' | 'outside';\n    entropy: number;\n    /** The index that will be used to check equality */\n    on: _IndexExplanation;\n} | {\n    /** An empty set */\n    id: string | number;\n    _: 'empty';\n} | {\n    /** An union set */\n    id: string | number;\n    _: 'union',\n    union: _SelectExplanation[];\n} | {\n    /** A seq-scan filter of another set */\n    id: string | number;\n    _: 'seqFilter';\n    filtered: _SelectExplanation;\n} | {\n    id: string | number;\n    _: 'aggregate';\n    aggregator: {\n        /** aggregation will iterate the whole lot */\n        seqScan: _ExprExplanation;\n    } | {\n        /** aggregation uses an index items which already contains required aggregations */\n        index: _IndexExplanation\n    } | {\n        /** aggregation is trivial (select count(*) from table) */\n        trivial: _ISelection;\n    };\n}\n\nexport type _IndexExplanation = {\n    /** BTree index on expression */\n    _: 'btree';\n    onTable: string;\n    btree: string[];\n} | {\n    _: 'indexMap';\n    of: _IndexExplanation;\n} | {\n    _: 'indexRestriction';\n    /** This index will receive a lookup for each item of \"for\" collection */\n    lookup: _IndexExplanation;\n    /** Enumerated collection */\n    for: _SelectExplanation;\n} | {\n    /** Uses an index of a column propagated by a join */\n    _: 'indexOnJoin';\n    /** The in propagated column that is used */\n    index: _IndexExplanation;\n    /** How elements from the other table will be joined */\n    strategy: _IndexExplanation | 'catastrophic';\n};\n\nexport type _ExprExplanation = {\n    constant: true;\n} | {\n    /** ID of the origin of this selection */\n    on: string | number;\n    col: string;\n}\n\nexport interface _IDb extends IMemoryDb {\n    readonly options: MemoryDbOptions;\n    readonly public: _ISchema;\n    readonly data: _Transaction;\n    readonly searchPath: ReadonlyArray<string>;\n\n    createSchema(db: string): _ISchema;\n    getSchema(db?: string | null, nullIfNotFound?: false): _ISchema;\n    getSchema(db: string, nullIfNotFound: true): _ISchema | null;\n    raiseTable(table: string, event: TableEvent): void;\n    raiseGlobal(event: GlobalEvent, ...args: any[]): void;\n    listSchemas(): _ISchema[];\n    onSchemaChange(): void;\n    getTable(name: string, nullIfNotExists?: boolean): _ITable;\n    getExtension(name: string): (schema: ISchema) => void;\n    /** Get functions matching this arrity */\n    getFunctions(name: string | QName, arrity: number): Iterable<_FunctionDefinition>;\n    getLanguage(name: string): LanguageCompiler;\n}\nexport type OnConflictHandler = { ignore: 'all' | _IIndex } | {\n    onIndex: _IIndex;\n    update: (item: any, excluded: any) => void;\n}\n\nexport type DropHandler = (t: _Transaction) => void;\nexport type IndexHandler = (act: 'create' | 'drop', idx: _INamedIndex) => void;\n\nexport interface _RelationBase {\n    readonly name: string;\n    readonly reg: Reg;\n    readonly ownerSchema?: _ISchema;\n}\n\nexport interface Reg {\n    readonly typeId: number;\n    readonly classId: number;\n}\n\nexport interface ChangeOpts {\n    onConflict?: OnConflictHandler | nil;\n    overriding?: 'user' | 'system' | nil;\n}\n\nexport interface _ITable<T = any> extends IMemoryTable<T>, _RelationBase {\n    readonly type: 'table';\n    readonly hidden: boolean;\n    readonly db: _IDb;\n    readonly selection: _ISelection<T>;\n    readonly ownerSchema: _ISchema;\n    doInsert(t: _Transaction, toInsert: T, opts?: ChangeOpts): T;\n    setHidden(): this;\n    setReadonly(): this;\n    delete(t: _Transaction, toDelete: T): void;\n    update(t: _Transaction, toUpdate: T): T;\n    createIndex(t: _Transaction, expressions: CreateIndexDef): this;\n    createIndex(t: _Transaction, expressions: string[], type: 'primary' | 'unique', indexName?: string): this;\n    setReadonly(): this;\n    /** Create a column */\n    addColumn(column: SchemaField | CreateColumnDef, t: _Transaction): _Column;\n    /** Get a column to modify it */\n    getColumnRef(column: string): _Column;\n    getColumnRef(column: string, nullIfNotFound?: boolean): _Column | nil;\n    rename(to: string): this;\n    addConstraint(constraint: TableConstraint, t: _Transaction): void;\n    getIndex(...forValues: IValue[]): _IIndex | nil;\n    dropIndex(t: _Transaction, name: string): void;\n    drop(t: _Transaction): void;\n    /** Will be executed when one of the given columns is affected (update/delete) */\n    onBeforeChange(columns: (string | _Column)[], check: ChangeHandler<T>): ISubscription;\n    /** Will be executed once all 'onBeforeChange' handlers have ran (coherency checks) */\n    onCheckChange(columns: (string | _Column)[], check: ChangeHandler<T>): ISubscription;\n    onDrop(sub: DropHandler): ISubscription;\n    onIndex(sub: IndexHandler): ISubscription;\n    onTruncate(sub: DropHandler): ISubscription;\n    truncate(t: _Transaction): void;\n}\n\nexport interface _IView extends _RelationBase {\n    readonly type: 'view';\n    readonly db: _IDb;\n    readonly selection: _ISelection;\n    drop(t: _Transaction): void;\n}\n\n\nexport interface _IConstraint {\n    readonly name: string | nil;\n    uninstall(t: _Transaction): void;\n}\n\nexport type ChangeHandler<T = any> = (old: T | null, neu: T | null, t: _Transaction, opts: ChangeOpts) => void;\n\nexport interface _Column {\n    readonly notNull: boolean;\n    readonly default: IValue | nil;\n    readonly expression: IValue;\n    readonly usedInIndexes: ReadonlySet<_IIndex>;\n    readonly table: _ITable;\n    readonly name: string;\n    alter(alter: AlterColumn, t: _Transaction): this;\n    rename(to: string, t: _Transaction): this;\n    drop(t: _Transaction): void;\n    onDrop(sub: DropHandler): ISubscription;\n}\n\nexport interface CreateIndexDef {\n    ifNotExists?: boolean;\n    columns: CreateIndexColDef[];\n    indexName?: string;\n    unique?: boolean;\n    notNull?: boolean;\n    primary?: boolean;\n}\nexport interface CreateIndexColDef {\n    value: IValue;\n    nullsLast?: boolean;\n    desc?: boolean\n}\n\n\nexport interface _IType<TRaw = any> extends IType, _RelationBase {\n    readonly type: 'type';\n    /** Data type */\n    readonly primary: DataType;\n    /** Reg type name */\n    readonly name: string; // | null;\n    readonly reg: Reg;\n\n    toString(): string;\n    equals(a: TRaw, b: TRaw): boolean | null;\n    gt(a: TRaw, b: TRaw): boolean | null;\n    ge(a: TRaw, b: TRaw): boolean | null;\n    lt(a: TRaw, b: TRaw): boolean | null;\n    le(a: TRaw, b: TRaw): boolean | null;\n    canConvertImplicit(to: _IType<TRaw>): boolean | nil;\n    canConvert(to: _IType<TRaw>): boolean | nil;\n    convert<T = any>(value: IValue<TRaw>, to: _IType<T>): IValue<T>;\n    prefer(type: _IType<any>): _IType | nil;\n\n    /** Build an array type for this type */\n    asArray(): _IType<TRaw[]>;\n    asList(): _IType<TRaw[]>;\n\n    /** Get an unicity hash */\n    hash(value: TRaw): string | number | null;\n\n    drop(t: _Transaction): void;\n}\n\nexport interface IValue<TRaw = any> {\n    /** Columns used in this expression (if any) */\n    readonly usedColumns: ReadonlySet<IValue>;\n\n    readonly type: _IType<TRaw>;\n\n    /** is 'any()' call ? */\n    readonly isAny: boolean;\n\n    /** Is a constant... i.e. not dependent on columns. ex: (2+2) or NOW() */\n    readonly isConstant: boolean;\n\n    /** Is REAL constant (i.e. 2+2, not varying expressions like NOW()) */\n    readonly isConstantReal: boolean;\n\n    /** Is a literal constant ? (constant not defined as an operation) */\n    readonly isConstantLiteral: boolean;\n\n    /** Will be set if there is an index on this value */\n    readonly index: _IIndex | nil;\n\n    /** Originates from this selection */\n    readonly origin: _ISelection | nil;\n\n\n    /** Column ID, or null */\n    readonly id: string | nil;\n\n    /** Hash of this value (used to identify indexed expressions) */\n    readonly hash: string;\n\n    /** Get value if is a constant */\n    get(): any;\n    /** Get value if is NOT a constant */\n    get(raw: TRaw, t?: _Transaction | nil): any;\n\n    setId(newId: string): IValue;\n    canConvert(to: _IType): boolean;\n    convert<T = any>(to: _IType<T>): IValue<T>;\n\n    /**\n     * Creates a copy of this column that can\n     **/\n    setWrapper<TNewRaw>(newOrigin: _ISelection, unwrap: (val: TNewRaw) => TRaw): IValue<TRaw>;\n    setOrigin(origin: _ISelection): IValue<TRaw>;\n    clone(): IValue<any>;\n\n    explain(e: _Explainer): _ExprExplanation;\n}\n\nexport type IndexKey = any[];\nexport interface IndexExpression {\n    readonly hash: string;\n    readonly type: _IType;\n}\n\nexport interface _INamedIndex<T = any> extends _IIndex<T>, _RelationBase {\n    readonly type: 'index';\n    readonly onTable: _ITable<T>;\n    drop(t: _Transaction): void;\n}\n\n\n\nexport interface _IIndex<T = any> {\n    readonly unique?: boolean;\n    readonly expressions: IndexExpression[];\n\n    /** Returns a measure of how many items will be returned by this op */\n    entropy(t: IndexOp): number;\n\n    /** Returns this selection stats, or null if it cannot be computed without iteration */\n    stats(t: _Transaction, key?: IndexKey): Stats | null;\n\n    /** Get values equating the given key */\n    eqFirst(rawKey: IndexKey, t: _Transaction): T | null;\n\n    enumerate(op: IndexOp): Iterable<T>;\n\n    explain(e: _Explainer): _IndexExplanation;\n\n    iterateKeys(t: _Transaction): Iterable<IndexKey> | null;\n}\n\nexport type IndexOp = {\n    type: 'eq' | 'neq' | 'gt' | 'lt' | 'ge' | 'le';\n    key: IndexKey;\n    t: _Transaction;\n    matchNull?: boolean;\n} | {\n    type: 'inside' | 'outside'\n    lo: IndexKey;\n    hi: IndexKey;\n    t: _Transaction;\n} | {\n    type: 'nin';\n    keys: IndexKey[];\n    t: _Transaction;\n}\n\nexport interface TableRecordDef<T> {\n    hasPrimary?: boolean;\n    readonly?: boolean;\n    hidden?: boolean;\n    name?: string;\n    dataId?: symbol;\n\n    serials: ImMap<string, number>;\n    it: number;\n    indexByHash: ImMap<string, _IIndex<T>>;\n    indexByName: ImMap<string, _IIndex<T>>;\n    columnsByName: ImMap<string, CR<T>>;\n}\n\nexport interface TableColumnRecordDef<T> {\n    default: IValue;\n    notNull: boolean;\n    usedInIndexes: ImSet<_IIndex>;\n    type: _IType;\n    name: string;\n}\n\nexport type TR<T> = Record<TableRecordDef<T>>;\nexport type CR<T> = Record<TableColumnRecordDef<T>>;\nexport const EmtpyTable = Record<TableRecordDef<any>>({\n    serials: ImMap(),\n    it: 0,\n    indexByHash: ImMap(),\n    indexByName: ImMap(),\n    columnsByName: ImMap(),\n});\n\nexport const NewColumn = Record<TableColumnRecordDef<any>>({\n    default: null as any,\n    notNull: false,\n    usedInIndexes: ImSet(),\n    type: null as any,\n    name: null as any,\n});\n\nexport type _IRelation = _ITable | _ISequence | _INamedIndex | _IType | _IView;\n\nexport function asIndex(o: _IRelation): _INamedIndex;\nexport function asIndex(o: _IRelation | null): _INamedIndex | null;\nexport function asIndex(o: _IRelation | null) {\n    if (!o) {\n        return null;\n    }\n    if (o.type === 'index') {\n        return o;\n    }\n    throw new QueryError(`\"${o.name}\" is not an index`);\n}\n\nexport function asType(o: _IRelation): _IType;\nexport function asType(o: _IRelation | null): _IType | null;\nexport function asType(o: _IRelation | null) {\n    if (!o) {\n        return null;\n    }\n    if (o.type === 'type') {\n        return o;\n    }\n    throw new QueryError(`\"${o.name}\" is not a type`);\n}\n\nexport function asSeq(o: _IRelation): _ISequence;\nexport function asSeq(o: _IRelation | null): _ISequence | null;\nexport function asSeq(o: _IRelation | null) {\n    if (!o) {\n        return null;\n    }\n    if (o.type === 'sequence') {\n        return o;\n    }\n    throw new QueryError(`\"${o.name}\" is not a sequence`);\n}\n\nexport function asTable(o: _IRelation): _ITable;\nexport function asTable(o: _IRelation | null): _ITable | null;\nexport function asTable(o: _IRelation | null, nullIfNotType?: boolean): _ITable | null;\nexport function asTable(o: _IRelation | null, nullIfNotType?: boolean) {\n    if (!o) {\n        return null;\n    }\n    if (o.type === 'table') {\n        return o;\n    }\n    if (nullIfNotType) {\n        return null;\n    }\n    throw new QueryError(`\"${o.name}\" is not a table`);\n}\n\n\nexport type _ISelectable = _ITable | _IView;\nexport function asSelectable(o: _IRelation): _ISelectable;\nexport function asSelectable(o: _IRelation | null): _ISelectable | null;\nexport function asSelectable(o: _IRelation | null, nullIfNotType?: boolean): _ISelectable | null;\nexport function asSelectable(o: _IRelation | null, nullIfNotType?: boolean) {\n    if (!o) {\n        return null;\n    }\n    if (o.type === 'table' || o.type === 'view') {\n        return o;\n    }\n    if (nullIfNotType) {\n        return null;\n    }\n    throw new QueryError(`\"${o.name}\" is not selectable`);\n}\n\n\nexport function asView(o: _IRelation): _IView;\nexport function asView(o: _IRelation | null): _IView | null;\nexport function asView(o: _IRelation | null, nullIfNotType?: boolean): _IView | null;\nexport function asView(o: _IRelation | null, nullIfNotType?: boolean) {\n    if (!o) {\n        return null;\n    }\n    if (o.type === 'view') {\n        return o;\n    }\n    if (nullIfNotType) {\n        return null;\n    }\n    throw new QueryError({\n        code: '42809',\n        error: `\"${o.name}\" is not a view`,\n    });\n}\n\nexport interface _ISequence extends _RelationBase {\n\n    readonly type: 'sequence';\n    alter(t: _Transaction, opts: CreateSequenceOptions | AlterSequenceChange): this;\n    nextValue(t: _Transaction): number;\n    setValue(t: _Transaction, value: number): void;\n    currentValue(t: _Transaction): number;\n    drop(t: _Transaction): void;\n}\n\n\nexport interface AggregationComputer<TRet = any> {\n    readonly type: _IType;\n    /**  Compute from index  (ex: count(*) with a group-by) */\n    computeFromIndex?(key: IndexKey, index: _IIndex, t: _Transaction): TRet | undefined;\n    /**  Compute out of nowhere when there is no group\n     * (ex: when there is no grouping, count(*) on a table or count(xxx) when there is an index on xxx) */\n    computeNoGroup?(t: _Transaction): TRet | undefined;\n\n    /** When iterating, each new group will have its computer */\n    createGroup(t: _Transaction): AggregationGroupComputer<TRet>;\n}\n\nexport interface AggregationGroupComputer<TRet = any> {\n    /** When iterating, this will be called for each item in this group  */\n    feedItem(item: any): void;\n    /** Finish computation (sets aggregation on result) */\n    finish(): TRet | nil;\n}\n","import moment from 'moment';\nimport { List } from 'immutable';\nimport { IValue, NotSupported, RegClass, _IRelation, _ISchema, _ISelection, _ITable, _IType, _Transaction } from './interfaces-private';\nimport { BinaryOperator, DataTypeDef, Expr, ExprRef, ExprValueKeyword, Interval, nil, parse, QName, SelectedColumn } from 'pgsql-ast-parser';\nimport { ColumnNotFound, ISubscription, IType, QueryError, typeDefToStr } from './interfaces';\nimport { bufClone, bufCompare, isBuf } from './buffer-node';\n\nexport interface Ctor<T> extends Function {\n    new(...params: any[]): T; prototype: T;\n}\n\nexport type Optional<T> = { [key in keyof T]?: T[key] };\nexport type SRecord<T> = Record<string, T>;\n\n\nexport function trimNullish<T>(value: T, depth = 5): T {\n    if (depth < 0)\n        return value;\n    if (value instanceof Array) {\n        value.forEach(x => trimNullish(x, depth - 1))\n    }\n    if (typeof value !== 'object' || value instanceof Date || moment.isMoment(value) || moment.isDuration(value))\n        return value;\n\n    if (!value) {\n        return value;\n    }\n\n    for (const k of Object.keys(value)) {\n        const val = (value as any)[k];\n        if (nullIsh(val))\n            delete (value as any)[k];\n        else\n            trimNullish(val, depth - 1);\n    }\n    return value;\n}\n\n\nexport function watchUse<T>(rootValue: T): { checked: T; check?: () => string | null; } {\n    if (!rootValue || typeof globalThis !== 'undefined' && (globalThis as any)?.process?.env?.['NOCHECKFULLQUERYUSAGE'] === 'true') {\n        return { checked: rootValue };\n    }\n    if (typeof rootValue !== 'object') {\n        throw new NotSupported();\n    }\n    if (Array.isArray(rootValue)) {\n        throw new NotSupported();\n    }\n    const toUse = new Map<string, any>();\n    function recurse(value: any, stack: List<string> = List()): any {\n        if (!value || typeof value !== 'object') {\n            return value;\n        }\n        if (Array.isArray(value)) {\n            return value\n                .map((x, i) => recurse(x, stack.push(`[${i}]`)));\n        }\n        // watch object\n        const ret: any = {};\n        for (const [k, _v] of Object.entries(value)) {\n            if (k[0] === '_') { // ignore properties starting with '_'\n                ret[k] = _v;\n                continue;\n            }\n            const nstack = stack.push('.' + k);\n            let v = recurse(_v, nstack);\n            const nstackKey = nstack.join('');\n            toUse.set(nstackKey, _v);\n            Object.defineProperty(ret, k, {\n                get() {\n                    toUse.delete(nstackKey);\n                    return v;\n                },\n                enumerable: true,\n            });\n        }\n        return ret;\n    }\n\n    const final = recurse(rootValue);\n\n    const check = function () {\n        if (toUse.size) {\n            return `The query you ran generated an AST which parts have not been read by the query planner. \\\nThis means that those parts could be ignored:\n\n     ` + [...toUse.entries()]\n                    .map(([k, v]) => k + ' (' + JSON.stringify(v) + ')')\n                    .join('\\n     ');\n        }\n        return null;\n    }\n    return { checked: final, check };\n}\n\n\n\nexport function deepEqual<T>(a: T, b: T, strict?: boolean, depth = 10, numberDelta = 0.0001) {\n    return deepCompare(a, b, strict, depth, numberDelta) === 0;\n}\n\nexport function deepCompare<T>(a: T, b: T, strict?: boolean, depth = 10, numberDelta = 0.0001): number {\n    if (depth < 0) {\n        throw new NotSupported('Comparing too deep entities');\n    }\n\n    if (a === b) {\n        return 0;\n    }\n    if (!strict) {\n        // should not use '==' because it could call .toString() on objects when compared to strings.\n        // ... which is not ok. Especially when working with translatable objects, which .toString() returns a transaltion (a string, thus)\n        if (!a && !b) {\n            return 0;\n        }\n    }\n\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return -1; // [] < {}\n        }\n        if (a.length !== b.length) {\n            return a.length > b.length ? 1 : -1;\n        }\n        for (let i = 0; i < a.length; i++) {\n            const inner = deepCompare(a[i], b[i], strict, depth - 1, numberDelta);\n            if (inner)\n                return inner;\n        }\n        return 0;\n    }\n\n    if (Array.isArray(b)) {\n        return 1;\n    }\n\n    if (isBuf(a) || isBuf(b)) {\n        if (!isBuf(a)) {\n            return 1;\n        }\n        if (!isBuf(b)) {\n            return -1;\n        }\n        return bufCompare(a, b);\n    }\n\n    // handle dates\n    if (a instanceof Date || b instanceof Date || moment.isMoment(a) || moment.isMoment(b)) {\n        const am = moment(a);\n        const bm = moment(b);\n        if (am.isValid() !== bm.isValid()) {\n            return am.isValid()\n                ? -1\n                : 1;\n        }\n        const diff = am.diff(bm, 'seconds');\n        if (Math.abs(diff) < 0.001) {\n            return 0;\n        }\n        return diff > 0 ? 1 : -1;\n    }\n\n    // handle durations\n    if (moment.isDuration(a) || moment.isDuration(b)) {\n        const da = moment.duration(a);\n        const db = moment.duration(b);\n        if (da.isValid() !== db.isValid()) {\n            return da.isValid()\n                ? -1\n                : 1;\n        }\n        const diff = da.asMilliseconds() - db.asMilliseconds();\n        if (Math.abs(diff) < 1) {\n            return 0;\n        }\n        return diff > 0 ? 1 : -1;\n    }\n\n    const fa = Number.isFinite(<any>a);\n    const fb = Number.isFinite(<any>b);\n    if (fa && fb) {\n        if (Math.abs(<any>a - <any>b) <= numberDelta) {\n            return 0;\n        }\n        return a > b ? 1 : -1;\n    } else if (fa && b) {\n        return -1;\n    } else if (fb && a) {\n        return 1;\n    }\n\n    // === handle plain objects\n    if (typeof a !== 'object') {\n        return 1; // objects are at the end\n    }\n    if (typeof b !== 'object') {\n        return -1; // objects are at the end\n    }\n\n    if (!a || !b) {\n        return 0; // nulls\n    }\n\n    const ak = Object.keys(a);\n    const bk = Object.keys(b);\n    if (strict && ak.length !== bk.length) {\n        // longer objects at the end\n        return ak.length > bk.length ? 1 : -1;\n    }\n    const set: Iterable<string> = strict\n        ? Object.keys(a)\n        : new Set([...Object.keys(a), ...Object.keys(b)]);\n    for (const k of set) {\n        const inner = deepCompare((a as any)[k], (b as any)[k], strict, depth - 1, numberDelta);\n        if (inner) {\n            return inner;\n        }\n    }\n    return 0;\n}\n\n\ntype Json = { [key: string]: Json } | Json[] | string | number | null;\nexport function queryJson(a: Json, b: Json) {\n    if (!a || !b) {\n        return (a ?? null) === (b ?? null);\n    }\n    if (a === b) {\n        return true;\n    }\n\n    if (typeof a === 'string' || typeof b === 'string') {\n        return false;\n    }\n\n    if (typeof a === 'number' || typeof b === 'number') {\n        return false;\n    }\n\n    if (Array.isArray(a)) {\n        // expecting array\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        // => must match all those criteria\n        const toMatch = [...a];\n        for (const be of b) {\n            for (let i = 0; i < toMatch.length; i++) {\n                if (queryJson(toMatch[i], be)) {\n                    // matched this criteria\n                    toMatch.splice(i, 1);\n                    break;\n                }\n            }\n            if (!toMatch.length) {\n                break;\n            }\n        }\n        return !toMatch.length;\n    }\n\n    if (Array.isArray(b)) {\n        return false;\n    }\n\n    if ((typeof a === 'object') !== (typeof b === 'object')) {\n        return false;\n    }\n    const akeys = Object.keys(a);\n    const bkeys = Object.keys(b);\n    if (akeys.length > bkeys.length) {\n        return false;\n    }\n    for (const ak of akeys) {\n        if (!(ak in (b as any))) {\n            return false;\n        }\n        if (!queryJson(a[ak], b[ak])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function buildLikeMatcher(likeCondition: string, caseSensitive = true) {\n    // Escape regex characters from likeCondition\n    likeCondition = likeCondition.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n    let likeRegexString = likeCondition.replace(/\\%/g, \".*\").replace(/_/g, '.');\n    likeRegexString = \"^\" + likeRegexString + \"$\";\n    const reg = new RegExp(likeRegexString, caseSensitive ? '' : 'i');\n\n    return (stringToMatch: string | number) => {\n        if (nullIsh(stringToMatch)) {\n            return null;\n        }\n        if (typeof stringToMatch != \"string\") {\n            stringToMatch = stringToMatch.toString();\n        }\n        return reg.test(stringToMatch);\n    }\n}\n\nexport function nullIsh(v: any): boolean {\n    return v === null || v === undefined;\n}\nexport function hasNullish(...vals: any[]): boolean {\n    return vals.some(nullIsh);\n}\n\nexport function sum(v: number[]): number {\n    return v.reduce((sum, el) => sum + el, 0);\n}\n\nexport function deepCloneSimple<T>(v: T): T {\n    if (!v || typeof v !== 'object' || v instanceof Date) {\n        return v;\n    }\n    if (Array.isArray(v)) {\n        return (v as any[]).map(x => deepCloneSimple(x)) as any;\n    }\n    if (isBuf(v)) {\n        return bufClone(v) as any;\n    }\n\n    const ret: any = {};\n    for (const k of Object.keys(v)) {\n        ret[k] = deepCloneSimple((v as any)[k]);\n    }\n    for (const k of Object.getOwnPropertySymbols(v)) {\n        ret[k] = (v as any)[k]; // no need to deep clone that\n    }\n    return ret;\n}\n\n\nexport function isSelectAllArgList(select: Expr[]): boolean {\n    const [first] = select;\n    return select.length === 1\n        && first.type === 'ref'\n        && first.name === '*'\n        && !first.table;\n}\n\n\nexport function ignore(...val: any[]): void {\n    for (const v of val) {\n        if (!v) {\n            continue;\n        }\n        if (Array.isArray(v)) {\n            ignore(...v);\n            continue;\n        }\n        if (typeof v !== 'object') {\n            continue;\n        }\n        ignore(...Object.values(v));\n    }\n}\n\nexport function combineSubs(...vals: ISubscription[]): ISubscription {\n    return {\n        unsubscribe: () => {\n            vals.forEach(u => u?.unsubscribe());\n        },\n    };\n}\n\n\ninterface Ctx {\n    schema: _ISchema;\n    transaction: _Transaction;\n}\nconst curCtx: Ctx[] = [];\nexport function getContext(): Ctx {\n    if (!curCtx.length) {\n        throw new Error('Cannot call getFunctionContext() in this context');\n    }\n    return curCtx[curCtx.length - 1];\n}\n\nexport function pushContext<T>(ctx: Ctx, act: () => T): T {\n    try {\n        curCtx.push(ctx)\n        return act();\n    } finally {\n        curCtx.pop();\n    }\n}\n\nexport function indexHash(this: void, vals: (IValue | string)[]) {\n    return vals.map(x => typeof x === 'string' ? x : x.hash).sort().join('|');\n}\n\nexport function randomString(length = 8, chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'): string {\n    var result = '';\n    for (var i = length; i > 0; --i) result += chars[Math.floor(Math.random() * chars.length)];\n    return result;\n}\n\n\nexport function schemaOf(t: DataTypeDef): string | nil {\n    if (t.kind === 'array') {\n        return schemaOf(t.arrayOf);\n    }\n    return t.schema;\n}\n\n\nexport function isType(t: any): t is (_IType | IType) {\n    return !!t?.[isType.TAG];\n}\nisType.TAG = Symbol();\n\n\nexport function suggestColumnName(expr: Expr | nil): string | null {\n    if (!expr) {\n        return null;\n    }\n    // suggest a column result name\n    switch (expr.type) {\n        case 'call':\n            return expr.function.name;\n        case 'ref':\n            return expr.name;\n        case 'keyword':\n            return expr.keyword;\n        case 'cast':\n            return typeDefToStr(expr.to);\n    }\n    return null;\n}\n\nexport function findTemplate<T>(this: void, selection: _ISelection, t: _Transaction, template?: T, columns?: (keyof T)[]): Iterable<T> {\n    // === Build an SQL AST expression that matches\n    // this template\n    let expr: Expr | nil;\n    for (const [k, v] of Object.entries(template ?? {})) {\n        let right: Expr;\n        if (nullIsh(v)) {\n            // handle { myprop: null }\n            right = {\n                type: 'unary',\n                op: 'IS NULL',\n                operand: {\n                    type: 'ref',\n                    name: k,\n                },\n            };\n        } else {\n            let value: Expr;\n            let op: BinaryOperator = '=';\n            switch (typeof v) {\n                case 'number':\n                    // handle {myprop: 42}\n                    value = Number.isInteger(v)\n                        ? { type: 'integer', value: v }\n                        : { type: 'numeric', value: v };\n                    break;\n                case 'string':\n                    // handle {myprop: 'blah'}\n                    value = { type: 'string', value: v };\n                    break;\n                case 'object':\n                    // handle {myprop: new Date()}\n                    if (moment.isMoment(v)) {\n                        value = { type: 'string', value: v.toISOString() };\n                    } else if (v instanceof Date) {\n                        value = { type: 'string', value: moment(v).toISOString() };\n                    } else {\n                        // handle {myprop: {obj: \"test\"}}\n                        op = '@>';\n                        value = {\n                            type: 'string',\n                            value: JSON.stringify(v),\n                        };\n                    }\n                    break;\n                default:\n                    throw new Error(`Object type of property \"${k}\" not supported in template`);\n            }\n            right = {\n                type: 'binary',\n                op,\n                left: {\n                    type: 'ref',\n                    name: k,\n                },\n                right: value\n            };\n        }\n        expr = !expr ? right : {\n            type: 'binary',\n            op: 'AND',\n            left: expr,\n            right,\n        };\n    }\n\n    // === perform filter\n    let ret = selection\n        .filter(expr);\n    if (columns) {\n        ret = ret.select(columns.map<SelectedColumn>(x => ({\n            expr: { type: 'ref', name: x as string },\n        })));\n    }\n    return ret.enumerate(t);\n}\n\n\nfunction ver(v: string) {\n    if (!v || !/^\\d+(\\.\\d+)+$/.test(v)) {\n        throw new Error('Invalid semver ' + v)\n    }\n    return v.split(/\\./g).map(x => parseInt(x, 10));\n}\nexport function compareVersions(_a: string, _b: string): number {\n    const a = ver(_a);\n    const b = ver(_b);\n    const m = Math.max(a.length, b.length);\n    for (let i = 0; i < m; i++) {\n        const d = (b[i] || 0) - (a[i] || 0);\n        if (d !== 0) {\n            return d;\n        }\n    }\n    return 0;\n}\n\n\nexport function intervalToSec(v: Interval) {\n    return (v.milliseconds ?? 0) / 1000\n        + (v.seconds ?? 0)\n        + (v.minutes ?? 0) * 60\n        + (v.hours ?? 0) * 3600\n        + (v.days ?? 0) * 3600 * 24\n        + (v.months ?? 0) * 3600 * 24 * 30\n        + (v.years ?? 0) * 3600 * 24 * 30 * 12;\n}\n\nexport function parseRegClass(_reg: RegClass): QName | number {\n    let reg = _reg;\n    if (typeof reg === 'string' && /^\\d+$/.test(reg)) {\n        reg = parseInt(reg);\n    }\n    if (typeof reg === 'number') {\n        return reg;\n    }\n    // todo remove casts after next pgsql-ast-parser release\n    try {\n        const ret = parse(reg, 'qualified_name' as any) as QName;\n        return ret;\n    } catch (e) {\n        return { name: reg };\n    }\n}\n\n\nconst timeReg = /^(\\d+):(\\d+)(:(\\d+))?(\\.\\d+)?$/;\nexport function parseTime(str: string): moment.Moment {\n    const [_, a, b, __, c, d] = timeReg.exec(str) ?? [];\n    if (!_) {\n        throw new QueryError(`Invalid time format: ` + str);\n    }\n    const ms = d ? parseFloat(d) * 1000 : undefined;\n    let ret: moment.Moment;\n    if (c) {\n        ret = moment.utc({\n            h: parseInt(a, 10),\n            m: parseInt(b, 10),\n            s: parseInt(c, 10),\n            ms,\n        });\n    } else {\n        if (d) {\n            ret = moment.utc({\n                m: parseInt(a, 10),\n                s: parseInt(b, 10),\n                ms,\n            });\n        } else {\n            ret = moment.utc({\n                h: parseInt(a, 10),\n                m: parseInt(b, 10),\n                ms,\n            });\n        }\n    }\n    if (!ret.isValid()) {\n        throw new QueryError(`Invalid time format: ` + str);\n    }\n    return ret;\n}\n\n\nexport function colByName<T>(refs: Map<string, T>, ref: string | ExprRef, nullIfNotFound: boolean | nil): T | nil {\n    const nm = typeof ref === 'string' ? ref\n        : !ref.table ? ref.name\n            : null;\n    const got = nm ? refs.get(nm) : null;\n    if (!got && !nullIfNotFound) {\n        throw new ColumnNotFound(colToStr(ref));\n    }\n    return got;\n}\n\nexport function colToStr(col: string | ExprRef) {\n    if (typeof col === 'string') {\n        return col;\n    }\n    if (!col.table) {\n        return col.name;\n    }\n    return col.table.name + '.' + col.name;\n}\n\nexport function qnameToStr(col: string | QName) {\n    if (typeof col === 'string') {\n        return col;\n    }\n    if (!col.schema) {\n        return col.name;\n    }\n    return col.schema + '.' + col.name;\n}\n\nexport function asSingleName(col: string | ExprRef): string | nil {\n    if (typeof col === 'string') {\n        return col;\n    }\n    if (col.table) {\n        return null;\n    }\n    return col.name;\n}\n\nexport function asSingleQName(col: string | QName, allowedSchema?: string): string | nil {\n    if (typeof col === 'string') {\n        return col;\n    }\n    if (col.schema && col.schema !== allowedSchema) {\n        return null;\n    }\n    return col.name;\n}\n","import { IMigrate } from './migrate/migrate-interfaces';\nimport { TableConstraint, CreateColumnDef, NodeLocation, DataTypeDef, FunctionArgumentMode } from 'pgsql-ast-parser';\n\n\nexport type nil = undefined | null;\n\nexport type Schema = {\n    name: string;\n    fields: SchemaField[];\n    constraints?: TableConstraint[];\n}\n\n\nexport interface SchemaField extends Omit<CreateColumnDef, 'dataType' | 'kind' | 'name'> {\n    type: IType | DataType;\n    name: string;\n    serial?: boolean;\n}\n\nexport interface IType {\n    /** Data type */\n    readonly primary: DataType;\n    readonly name: string;\n    toString(): string;\n\n    /** Create an array type of this type */\n    asArray(): IType;\n}\n\n// todo support all types https://www.postgresql.org/docs/9.5/datatype.html\nexport enum DataType {\n\n    inet = 'inet',\n    record = 'record',\n    uuid = 'uuid',\n    text = 'text',\n    citext = 'citext',\n    array = 'array',\n    bigint = 'bigint',\n    float = 'float',\n    decimal = 'decimal',\n    integer = 'integer',\n    jsonb = 'jsonb',\n    regtype = 'regtype',\n    regclass = 'regclass',\n    json = 'json',\n    bytea = 'bytea',\n    interval = 'interval',\n    timestamp = 'timestamp',\n    timestamptz = 'timestamptz',\n    date = 'date',\n    time = 'time',\n    null = 'null',\n    bool = 'bool',\n\n    point = 'point',\n    line = 'line',\n    lseg = 'lseg',\n    box = 'box',\n    path = 'path',\n    polygon = 'polygon',\n    circle = 'circle',\n}\n\nexport interface MemoryDbOptions {\n    /**\n     * If set to true, pg-mem will stop embbeding info about the SQL statement\n     * that has failed in exception messages.\n     */\n    noErrorDiagnostic?: boolean;\n    /**\n     * If set to true, then the query runner will not check that no AST part\n     * has been left behind when parsing the request.\n     *\n     * ... so setting it to true could lead to unnoticed ignored query parts.\n     *\n     * (advice: only set it to true as a workaround while an issue on https://github.com/oguimbal/pg-mem is being fixed... )\n     */\n    noAstCoverageCheck?: boolean;\n    /**\n     *  If set to true, this will throw an exception if\n     * you try to use an unsupported index type\n     * (only BTREE is supported at time of writing)\n     */\n    noIgnoreUnsupportedIndices?: boolean;\n    /**\n     * When set to true, this will auto create an index on foreign table when adding a foreign key.\n     *  Recommanded when using Typeorm .synchronize(), which creates foreign keys but not indices !\n     **/\n    readonly autoCreateForeignKeyIndices?: boolean;\n}\n\nexport interface IMemoryDb {\n    /**\n     * Adapters to create wrappers of this db compatible with known libraries\n     */\n    readonly adapters: LibAdapters;\n    /**\n     * The default 'public' schema\n     */\n    readonly public: ISchema;\n    /**\n     * Get an existing schema\n     */\n    getSchema(db?: string | null): ISchema;\n    /**\n     * Create a schema in this database\n     */\n    createSchema(name: string): ISchema;\n    /**\n     * Get a table to inspect it (in the public schema... this is a shortcut for db.public.getTable())\n     */\n    getTable<T = any>(table: string): IMemoryTable<T>;\n    getTable<T = any>(table: string, nullIfNotFound?: boolean): IMemoryTable<T> | null;\n\n    /** Subscribe to a global event */\n    on(event: 'query', handler: (query: string) => any): ISubscription;\n    on(event: GlobalEvent, handler: () => any): ISubscription;\n    on(event: GlobalEvent, handler: () => any): ISubscription;\n    /** Subscribe to an event on all tables */\n    on(event: TableEvent, handler: (table: string) => any): ISubscription;\n\n    /**\n     * Creates a restore point.\n     *  This operation is O(1) (instantaneous, even with millions of records).\n     * */\n    backup(): IBackup;\n\n    /**\n     * Registers an extension (that can be installed using the 'create extension' statement)\n     * @param name Extension name\n     * @param install How to install this extension on a given schema\n     */\n    registerExtension(name: string, install: (schema: ISchema) => void): this;\n\n    /** Registers a new language, usable in 'DO' blocks, or in 'CREATE FUNCTION' blocks */\n    registerLanguage(languageName: string, compiler: LanguageCompiler): this;\n}\n\nexport type QueryInterceptor = (query: string) => any[] | nil;\n\n\nexport type ArgDef = DataType | IType | ArgDefDetails;\n\nexport interface ArgDefDetails {\n    /** Argument type */\n    type: IType;\n    /** Optional argument name */\n    name?: string;\n    /**\n     *  Arguments are 'in' by default, but you can change that.\n     */\n    mode?: FunctionArgumentMode;\n}\n\nexport type LanguageCompiler = (options: ToCompile) => CompiledFunction;\n\nexport interface ToCompile {\n    /** Function being compiled (null for \"DO\" statements compilations) */\n    functioName?: string | nil;\n    /** Code to compile */\n    code: string;\n    /** Expected arguments */\n    args: ArgDefDetails[];\n    /** Expected return type (if any) */\n    returns?: IType | nil;\n}\n\nexport class AdvancedResult {\n    constructor(readonly result: any, outArgs: any[]) {\n    }\n}\n\nexport type CompiledFunction = (...inArguments: any[]) => AdvancedResult | PlainResult;\n\nexport type PlainResult = Object | number | Date | null | void;\n\nexport interface CompiledFunctionResult {\n    /** The function result, if function \"returns\" something */\n    result?: any;\n    /** The functions out arguments, as indexed in the `args` passed to your language compiler function */\n    outArgs?: any[];\n}\n\nexport interface IBackup {\n    /**\n     * Restores data to the state when this backup has been performed.\n     *  This operation is O(1).\n     *  Schema must not have been changed since then !\n     **/\n    restore(): void;\n}\n\nexport interface LibAdapters {\n    /** Create a PG module that will be equivalent to require('pg') */\n    createPg(queryLatency?: number): { Pool: any; Client: any };\n\n    /** Create a pg-promise instance bound to this db */\n    createPgPromise(queryLatency?: number): any;\n\n    /** Create a slonik pool bound to this db */\n    createSlonik(queryLatency?: number): any;\n\n    /** Create a pg-native instance bound to this db */\n    createPgNative(queryLatency?: number): any;\n\n    /** Create a Typeorm connection bound to this db */\n    createTypeormConnection(typeOrmConnection: any, queryLatency?: number): any;\n\n    /** Create a Knex.js instance bound to this db */\n    createKnex(queryLatency?: number, knexConfig?: object): any;\n\n    /** Create a mikro-orm instance bound to this db */\n    createMikroOrm(mikroOrmOptions: any, queryLatency?: number): Promise<any>\n}\n\nexport interface ISchema {\n    /**\n     * Execute a query and return many results\n     */\n    many(query: string): any[];\n    /**\n     * Execute a query without results\n     */\n    none(query: string): void;\n    /**\n     * Execute a query with a single result\n     */\n    one(query: string): any;\n    /**\n     * Another way to create tables (equivalent to \"create table\" queries\")\n     */\n    declareTable(table: Schema): IMemoryTable;\n    /**\n     * Execute a query\n     */\n    query(text: string): QueryResult;\n\n\n    /**\n     * Progressively executes a query, yielding results until the end of enumeration (or an exception)\n     */\n    queries(text: string): Iterable<QueryResult>;\n\n    /**\n     * Get a table in this db to inspect it\n     */\n    getTable(table: string): IMemoryTable;\n    getTable(table: string, nullIfNotFound?: boolean): IMemoryTable | null;\n\n    /** Register a function */\n    registerFunction(fn: FunctionDefinition): this;\n\n    /** Register a simple type, which is equivalent to another */\n    registerEquivalentType(type: IEquivalentType): IType;\n\n    /** Get an existing type */\n    getType(name: DataType): IType;\n\n    /**\n     * Registers an enum type on this schema\n     * @param name Enum name\n     * @param values Possible values\n     */\n    registerEnum(name: string, values: string[]): void;\n\n    /**\n     * Database migration, node-sqlite flavor\n     *  Only working when runnin nodejs !\n     */\n    migrate(config?: IMigrate.MigrationParams): Promise<void>;\n\n\n    /**\n     * Intecept queries.\n     * If your interceptor returns an array, then the query will not be executed.\n     * The given result will be returned instead.\n     */\n    interceptQueries(interceptor: QueryInterceptor): ISubscription;\n}\n\nexport interface FunctionDefinition {\n    /** Function name (casing doesnt matter) */\n    name: string;\n\n    /** Expected arguments */\n    args?: ArgDef[] | nil;\n\n    /** Other arguments type (variadic arguments) */\n    argsVariadic?: DataType | IType | nil;\n\n    /** Returned data type */\n    returns?: DataType | IType | nil;\n\n    /**\n     * If the function is marked as impure, it will not be simplified\n     * (ex: \"select myFn(1) from myTable\" will call myFn() for each row in myTable, even if it does not depend on its result) */\n    impure?: boolean;\n\n    /** If true, the function will also be called when passing null arguments */\n    allowNullArguments?: boolean;\n\n    /** Actual implementation of the function */\n    implementation: CompiledFunction;\n}\n\nexport interface QueryResult {\n    /** Last command that has been executed */\n    command: string;\n    rowCount: number;\n    fields: Array<FieldInfo>;\n    rows: any[];\n\n    /** Ignored (because of an \"if not exists\" or equivalent) */\n    ignored?: boolean;\n    /** Location of the last \";\" prior to this statement */\n    location: NodeLocation;\n}\n\nexport interface FieldInfo {\n    name: string;\n}\n\n\n\nexport type TableEvent = 'seq-scan';\nexport type GlobalEvent = 'query' | 'query-failed' | 'catastrophic-join-optimization' | 'schema-change' | 'create-extension';\n\nexport interface IMemoryTable<T = any> {\n    /** Subscribe to an event on this table */\n    on(event: TableEvent, handler: () => any): ISubscription;\n    /** List existing indices defined on this table */\n    listIndices(): IndexDef[];\n\n    /**\n     * Inserts a raw item into this table.\n     *  Neither the record you provided, nor the returned value are the actual item stored. You wont be able to mutate internal state.\n     * @returns A copy of the inserted item (with assigned defaults)\n     */\n    insert(item: Partial<T>): T;\n\n    /** Find all items matching a specific template */\n    find(template?: Partial<T> | nil, columns?: (keyof T)[]): Iterable<T>;\n}\n\n\nexport interface ISubscription {\n    unsubscribe(): void;\n}\n\nexport interface IndexDef {\n    name: string;\n    expressions: string[];\n}\n\nexport class NotSupported extends Error {\n    constructor(what?: string) {\n        super(' Not supported  ' + (what ? ': ' + what : ''));\n    }\n\n    static never(value: never, msg?: string) {\n        return new NotSupported(`${msg ?? ''} ${JSON.stringify(value)}`);\n    }\n}\n\n\ninterface ErrorData {\n    readonly error: string;\n    readonly details?: string;\n    readonly hint?: string;\n    readonly code?: string;\n}\nexport class QueryError extends Error {\n    readonly data: ErrorData;\n    constructor(err: string | ErrorData, code?: string) {\n        super(typeof err === 'string' ? err : errDataToStr(err));\n        this.data = typeof err === 'string'\n            ? { error: err, code }\n            : err;\n    }\n}\n\nfunction errDataToStr(data: ErrorData) {\n    const ret = ['ERROR: ' + data.error];\n    if (data.details) {\n        ret.push('DETAIL: ' + data.details);\n    }\n    if (data.hint) {\n        ret.push('HINT: ' + data.hint)\n    }\n    return ret.join('\\n');\n}\n\n\nexport class CastError extends QueryError {\n    constructor(from: string | DataType | IType, to: string | DataType | IType, inWhat?: string) {\n        super(`cannot cast type ${typeof from === 'string'\n            ? from\n            : from.name} to ${typeof to === 'string'\n                ? to\n                : to.name}`\n            + (inWhat ? ' in ' + inWhat : ''));\n    }\n}\n\n\nexport class ColumnNotFound extends QueryError {\n    constructor(col: string) {\n        super(`column \"${col}\" does not exist`);\n    }\n}\n\nexport class AmbiguousColumn extends QueryError {\n    constructor(col: string) {\n        super(`column reference \"${col}\" is ambiguous`);\n    }\n}\n\nexport class RelationNotFound extends QueryError {\n    constructor(tableName: string) {\n        super(`relation \"${tableName}\" does not exist`);\n    }\n}\nexport class TypeNotFound extends QueryError {\n    constructor(t: string | number | DataTypeDef) {\n        super(`type \"${typeof t !== 'object' ? t : typeDefToStr(t)}\" does not exist`);\n    }\n}\n\nexport class RecordExists extends QueryError {\n    constructor() {\n        super('Records already exists');\n    }\n}\n\n\nexport class PermissionDeniedError extends QueryError {\n    constructor(what?: string) {\n        super(what\n            ? `permission denied: \"${what}\" is a system catalog`\n            : 'permission denied');\n    }\n}\n\n\nexport function typeDefToStr(t: DataTypeDef): string {\n    if (t.kind === 'array') {\n        return typeDefToStr(t.arrayOf) + '[]';\n    }\n    let ret = t.name;\n    if (t.schema) {\n        ret = t.schema + '.' + ret;\n    }\n    if (t.config?.length) {\n        ret = ret + '(' + t.config.join(',') + ')';\n    }\n    return ret;\n}\n\n/** A type definition that is equivalent to another type */\nexport interface IEquivalentType {\n    /** Type name */\n    readonly name: string;\n    /** Which underlying type is it equivalent to ? */\n    readonly equivalentTo: DataType | IType;\n    /**\n     * Is this value valid ?\n     */\n    isValid(value: any): boolean;\n}\n","export * from './datatypes';\n","// <== THERE MUST BE NO ACTUAL IMPORTS OTHER THAN IMPORT TYPES (dependency loop)\n// ... use 'kind-of' dependency injection below\nimport type { _ISelection, IValue, _IIndex, _ISchema, _IDb, _Transaction, _SelectExplanation, _Explainer, Stats, nil, _IAlias } from '../interfaces-private';\nimport type { buildSelection } from './selection';\nimport type { buildAlias } from './alias';\nimport type { buildFilter } from './build-filter';\nimport type { buildGroupBy } from './aggregation';\nimport type { buildLimit } from './limit';\nimport type { buildUnion } from './union';\nimport type { buildOrderBy } from './order-by';\nimport type { buildDistinct } from './distinct';\n\nimport { Expr, SelectedColumn, SelectStatement, LimitStatement, OrderByStatement, ExprRef } from 'pgsql-ast-parser';\nimport { RestrictiveIndex } from './restrictive-index';\n\ninterface Fns {\n    buildSelection: typeof buildSelection;\n    buildAlias: typeof buildAlias;\n    buildLimit: typeof buildLimit;\n    buildUnion: typeof buildUnion;\n    buildFilter: typeof buildFilter;\n    buildGroupBy: typeof buildGroupBy;\n    buildOrderBy: typeof buildOrderBy;\n    buildDistinct: typeof buildDistinct;\n}\nlet fns: Fns;\nexport function initialize(init: Fns) {\n    fns = init;\n}\n\nexport abstract class DataSourceBase<T> implements _ISelection<T> {\n    abstract enumerate(t: _Transaction): Iterable<T>;\n    abstract entropy(t: _Transaction): number;\n    abstract readonly columns: ReadonlyArray<IValue<any>>;\n    abstract getColumn(column: string, nullIfNotFound?: boolean): IValue<any>;\n    abstract hasItem(value: T, t: _Transaction): boolean;\n    abstract getIndex(forValue: IValue): _IIndex<any> | null | undefined;\n    abstract explain(e: _Explainer): _SelectExplanation;\n    abstract isOriginOf(a: IValue<any>): boolean;\n    abstract stats(t: _Transaction): Stats | null;\n\n    get db() {\n        return this.ownerSchema.db;\n    }\n\n    constructor(readonly ownerSchema: _ISchema) {\n    }\n\n    listColumns(): Iterable<IValue> {\n        return this.columns;\n    }\n\n    listSelectableIdentities(): Iterable<IValue> {\n        return this.columns;\n    }\n\n    select(select: (string | SelectedColumn)[] | nil): _ISelection<any> {\n        let sel: SelectedColumn[] | nil;\n        if (select?.some(v => typeof v === 'string')) {\n            sel = select.map<SelectedColumn>(v => typeof v !== 'string'\n                ? v\n                : {\n                    expr: { type: 'ref', name: v },\n                })\n        } else {\n            sel = select as SelectedColumn[] | nil;\n        }\n        return fns.buildSelection(this, sel);\n    }\n\n\n    selectAlias(alias: string): _IAlias | nil {\n        return this;\n    }\n\n\n    filter(filter: Expr | undefined | null): _ISelection {\n        if (!filter) {\n            return this;\n        }\n        const plan = fns.buildFilter(this, filter);\n        return plan;\n    }\n\n    groupBy(grouping: Expr[] | nil, select: SelectedColumn[]): _ISelection {\n        if (!grouping?.length) {\n            return this;\n        }\n        const plan = fns.buildGroupBy(this, grouping, select);\n        return plan;\n    }\n\n\n    setAlias(alias?: string): _ISelection<any> {\n        return fns.buildAlias(this, alias);\n    }\n\n\n    subquery(data: _ISelection<any>, op: SelectStatement): _ISelection {\n        // todo: handle refs to 'data' in op statement.\n        return this.ownerSchema.buildSelect(op);\n    }\n\n    limit(limit: LimitStatement): _ISelection {\n        if (!limit?.limit && !limit?.offset) {\n            return this;\n        }\n        return fns.buildLimit(this, limit)\n    }\n\n    orderBy(orderBy: OrderByStatement[] | nil): _ISelection<any> {\n        if (!orderBy?.length) {\n            return this;\n        }\n        return fns.buildOrderBy(this, orderBy);\n    }\n\n    distinct(exprs?: Expr[]): _ISelection<any> {\n        return fns.buildDistinct(this, exprs);\n    }\n\n    union(right: _ISelection<any>): _ISelection<any> {\n        return fns.buildUnion(this, right);\n    }\n\n}\n\nexport abstract class TransformBase<T> extends DataSourceBase<T> {\n\n\n    constructor(protected base: _ISelection) {\n        super(base.ownerSchema);\n    }\n\n    entropy(t: _Transaction): number {\n        return this.base.entropy(t);\n    }\n\n    isOriginOf(a: IValue<any>): boolean {\n        return a.origin === this || this.base?.isOriginOf(a);\n    }\n}\n\nexport abstract class FilterBase<T> extends TransformBase<T> {\n\n\n    constructor(_base: _ISelection<T>) {\n        super(_base);\n    }\n\n    get columns(): ReadonlyArray<IValue<any>> {\n        return this.base.columns;\n    }\n\n    /**\n    private _columns: IValue[];\n    private _columnMappings: Map<IValue, IValue>;\n    get columns(): ReadonlyArray<IValue<any>> {\n        this.initCols();\n        return this._columns;\n        // return this.base.columns;\n    }\n\n    private initCols() {\n        if (this._columns) {\n            return;\n        }\n        this._columns = [];\n        this._columnMappings = new Map();\n        for (const c of this.base.columns) {\n            const nc = c.setOrigin(this);\n            this._columns.push(nc);\n            this._columnMappings.set(c, nc);\n        }\n    }\n\n    getColumn(column: string, nullIfNotFound?: boolean): IValue<any> {\n        if (!this.base) { // istanbul ignore next\n            throw new Error('Should not call .getColumn() on join');\n        }\n        if (!('columns' in this.base)) { // istanbul ignore next\n            throw new Error('Should not call getColumn() on table');\n        }\n        this.initCols();\n        const col = this.base.getColumn(column, nullIfNotFound);\n        return col && this._columnMappings.get(col);\n    }\n     */\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue<any> | nil {\n        if (!this.base) { // istanbul ignore next\n            throw new Error('Should not call .getColumn() on join');\n        }\n        if (!('columns' in this.base)) { // istanbul ignore next\n            throw new Error('Should not call getColumn() on table');\n        }\n        return this.base.getColumn(column, nullIfNotFound);\n    }\n\n    getIndex(...forValue: IValue<any>[]): _IIndex<any> | null | undefined {\n        const index = this.base.getIndex(...forValue);\n        if (!index) {\n            return null;\n        }\n        return new RestrictiveIndex(index, this);\n    }\n}","import { _ISelection, IValue, _IType, _ISchema } from './interfaces-private';\nimport { trimNullish, queryJson, buildLikeMatcher, nullIsh, hasNullish, intervalToSec, parseTime, asSingleQName } from './utils';\nimport { DataType, CastError, QueryError, IType, NotSupported, nil } from './interfaces';\nimport hash from 'object-hash';\nimport { Value, Evaluator } from './evaluator';\nimport { Types, isNumeric, isInteger, reconciliateTypes, ArrayType } from './datatypes';\nimport { Expr, ExprBinary, UnaryOperator, ExprCase, ExprWhen, ExprMember, ExprArrayIndex, ExprTernary, BinaryOperator, SelectStatement, ExprValueKeyword, ExprExtract, parseIntervalLiteral, Interval, ExprOverlay, ExprSubstring } from 'pgsql-ast-parser';\nimport lru from 'lru-cache';\nimport { aggregationFunctions, Aggregation } from './transforms/aggregation';\nimport moment from 'moment';\nimport { IS_PARTIAL_INDEXING } from './clean-results';\n\n\nconst builtLru = new lru<_ISelection | null, lru<Expr, IValue>>({\n    max: 30,\n});\nexport function buildValue(data: _ISelection, val: Expr): IValue {\n    const ret = _buildValue(data, val);\n    checkNotUntypedArray(ret);\n    return ret;\n}\n\n\nfunction checkNotUntypedArray(value: IValue) {\n    // A bit ugly: check that this is not a non typed array (empty array)\n    // see https://github.com/oguimbal/pg-mem/issues/64\n    // + corresponding UTs\n    const type = value.type;\n    if (type instanceof ArrayType && type.of == Types.null) {\n        throw new QueryError(`cannot determine type of empty array`);\n    }\n}\n\nexport function uncache(data: _ISelection) {\n    builtLru.del(data);\n}\n\nfunction _buildValue(data: _ISelection | nil, val: Expr): IValue {\n    // cache expressions build (they almost are always rebuilt several times in a row)\n    let selLru = builtLru.get(data ?? null);\n    let got: IValue | nil;\n    if (selLru) {\n        got = selLru.get(val);\n        if (got) {\n            return got;\n        }\n    }\n    got = _buildValueReal(data!, val);\n    if (data instanceof Aggregation) {\n        got = data.checkIfIsKey(got);\n    }\n    if (!selLru) {\n        builtLru.set(data ?? null, selLru = new lru({\n            max: 50,\n        }));\n    }\n    selLru.set(val, got);\n    return got;\n}\n\nfunction _buildValueReal(data: _ISelection, val: Expr): IValue {\n    switch (val.type) {\n        case 'binary':\n            if (val.op === 'IN' || val.op === 'NOT IN') {\n                return buildIn(data, val.left, val.right, val.op === 'IN');\n            }\n            return buildBinary(data, val);\n        case 'unary':\n            return buildUnary(data, val.op, val.operand);\n        case 'ref':\n            return data.getColumn(val);\n        case 'string':\n            return Value.text(data.ownerSchema, val.value);\n        case 'null':\n            return Value.null(data.ownerSchema);\n        case 'list':\n        case 'array':\n            const vals = val.expressions.map(x => _buildValue(data, x));\n            return Value.array(data.ownerSchema, vals, val.type === 'list');\n        case 'numeric':\n            return Value.number(data.ownerSchema, val.value);\n        case 'integer':\n            return Value.number(data.ownerSchema, val.value, Types.integer);\n        case 'call':\n            // if (typeof val.function !== 'string') {\n            //     return buildKeyword(data.ownerSchema, val.function, val.args);\n            // }\n            const nm = asSingleQName(val.function, 'pg_catalog');\n            if (nm && aggregationFunctions.has(nm)) {\n                if (!(data instanceof Aggregation)) {\n                    throw new QueryError(`aggregate functions are not allowed in WHERE`);\n                }\n                return data.getAggregation(nm, val);\n            }\n            const args = val.args.map(x => _buildValue(data, x));\n            const schema = data.db.getSchema(val.function.schema);\n            return Value.function(schema, val.function, args);\n        case 'cast':\n            return _buildValue(data, val.operand)\n                .convert(data.ownerSchema.getType(val.to))\n        case 'case':\n            return buildCase(data, val);\n        case 'member':\n            return buildMember(data, val);\n        case 'arrayIndex':\n            return buildArrayIndex(data, val);\n        case 'boolean':\n            return Value.bool(data.ownerSchema, val.value);\n        case 'ternary':\n            return buildTernary(data, val);\n        case 'select':\n        case 'union':\n        case 'union all':\n        case 'with':\n            return buildSelectAsArray(data, val);\n        case 'array select':\n            return buildSelectAsArray(data, val.select);\n        case 'constant':\n            return Value.constant(data.ownerSchema, val.dataType as any, val.value);\n        case 'keyword':\n            return buildKeyword(data.ownerSchema, val, []);\n        case 'parameter':\n            throw new NotSupported('Parameters expressions');\n        case 'extract':\n            return buildExtract(data, val);\n        case 'overlay':\n            return buildOverlay(data, val);\n        case 'substring':\n            return buildSubstring(data, val);\n        default:\n            throw NotSupported.never(val);\n    }\n}\n\nfunction buildKeyword(schema: _ISchema, kw: ExprValueKeyword, args: Expr[]): IValue {\n    if (args.length) {\n        throw new NotSupported(`usage of \"${kw.keyword}\" keyword with arguments, please file an issue in https://github.com/oguimbal/pg-mem if you need it !`);\n    }\n    if (kw.type !== 'keyword') {\n        throw new Error('Invalid AST');\n    }\n    switch (kw.keyword) {\n        case 'current_catalog':\n        case 'current_role':\n        case 'current_user':\n        case 'session_user':\n        case 'user':\n            return Value.constant(schema, Types.text(), 'pg_mem');\n        case 'current_schema':\n            return Value.constant(schema, Types.text(), 'public');\n        case 'current_date':\n            return Value.constant(schema, Types.date, new Date());\n        case 'current_timestamp':\n        case 'localtimestamp':\n            return Value.constant(schema, Types.timestamp, new Date());\n        case 'localtime':\n        case 'current_time':\n            throw new NotSupported('\"date\" data type, please file an issue in https://github.com/oguimbal/pg-mem if you need it !');\n        case 'distinct':\n            throw new NotSupported(kw.keyword);\n        default:\n            throw NotSupported.never(kw.keyword);\n    }\n}\n\nfunction buildUnary(data: _ISelection, op: UnaryOperator, operand: Expr) {\n    const expr = _buildValue(data, operand);\n\n    switch (op) {\n        case 'IS NULL':\n        case 'IS NOT NULL':\n            return Value.isNull(data.ownerSchema, expr, op === 'IS NULL');\n        case 'IS TRUE':\n        case 'IS NOT TRUE':\n            return Value.isTrue(data.ownerSchema, expr, op === 'IS TRUE');\n        case 'IS FALSE':\n        case 'IS NOT FALSE':\n            return Value.isFalse(data.ownerSchema, expr, op === 'IS FALSE');\n        case '+':\n            if (!isNumeric(expr.type)) {\n                throw new CastError(expr.type.primary, DataType.float);\n            }\n            return expr;\n        case 'NOT':\n        case '-':\n            return Value.negate(expr);\n        default:\n            throw NotSupported.never(op, 'Unary operator not supported');\n    }\n}\n\nfunction buildIn(data: _ISelection, left: Expr, array: Expr, inclusive: boolean): IValue {\n    let leftValue = _buildValue(data, left);\n    let rightValue = _buildValue(data, array);\n    return Value.in(data.ownerSchema, leftValue, rightValue, inclusive);\n}\n\n\nfunction buildBinary(data: _ISelection, val: ExprBinary): IValue {\n    let leftValue = _buildValue(data, val.left);\n    let rightValue = _buildValue(data, val.right);\n    return buildBinaryValue(data, leftValue, val.op, rightValue);\n}\n\nexport function buildBinaryValue(data: _ISelection, leftValue: IValue, op: BinaryOperator, rightValue: IValue): IValue {\n    function expectSame() {\n        const type: _IType = reconciliateTypes([leftValue, rightValue]);\n        leftValue = leftValue.convert(type);\n        rightValue = rightValue.convert(type);\n        return type;\n    }\n    function expectBoth(t: _IType) {\n        leftValue = leftValue.convert(t);\n        rightValue = rightValue.convert(t);\n    }\n\n    let getter: (a: any, b: any) => any;\n    let returnType: _IType = Types.bool;\n    let commutative = true;\n    let forcehash: any = null;\n    let rejectNils = true;\n    switch (op) {\n        case '=': {\n            const type = expectSame();\n            getter = (a, b) => type.equals(a, b);\n            break;\n        }\n        case '!=': {\n            const type = expectSame();\n            getter = (a, b) => {\n                const ret = type.equals(a, b);\n                return nullIsh(ret) ? null : !ret;\n            };\n            break;\n        }\n        case '>': {\n            const type = expectSame();\n            getter = (a, b) => type.gt(a, b);\n            forcehash = { op: '>', left: leftValue.hash, right: rightValue.hash };\n            break;\n        }\n        case '<': {\n            const type = expectSame();\n            getter = (a, b) => type.lt(a, b);\n            forcehash = { op: '>', left: rightValue.hash, right: leftValue.hash };\n            break;\n        }\n        case '>=': {\n            const type = expectSame();\n            getter = (a, b) => type.ge(a, b);\n            forcehash = { op: '>=', left: leftValue.hash, right: rightValue.hash };\n            break;\n        }\n        case '<=': {\n            const type = expectSame();\n            getter = (a, b) => type.le(a, b);\n            forcehash = { op: '>=', left: rightValue.hash, right: leftValue.hash };\n            break;\n        }\n        case '+':\n        case '-':\n        case '*':\n        case '/': {\n            const type = expectSame();\n            if (!isNumeric(type)) {\n                throw new QueryError(`Cannot apply ${op} on non numeric type ${type.primary}`);\n            }\n            returnType = type;\n            switch (op) {\n                case '+':\n                    getter = (a, b) => a + b;\n                    commutative = true;\n                    break;\n                case '-':\n                    getter = (a, b) => a - b;\n                    break;\n                case '*':\n                    getter = (a, b) => a * b;\n                    commutative = true;\n                    break;\n                case '/':\n                    if (isInteger(type)) {\n                        getter = (a, b) => Math.trunc(a / b);\n                    } else {\n                        getter = (a, b) => a / b;\n                    }\n                    break;\n            }\n            break;\n        }\n        case 'AND':\n        case 'OR':\n            expectBoth(Types.bool);\n            rejectNils = false;\n            if (op === 'AND') {\n                getter = (a, b) => a && b;\n            } else {\n                getter = (a, b) => a || b;\n            }\n            break;\n        case '@>':\n            expectBoth(Types.jsonb);\n            getter = (a, b) => queryJson(b, a);\n            break;\n        case '&&':\n            if (leftValue.type.primary !== DataType.array || !rightValue.canConvert(leftValue.type)) {\n                throw new QueryError(`Operator does not exist: ${leftValue.type.name} && ${rightValue.type.name}`, '42883');\n            }\n            rightValue = rightValue.convert(leftValue.type);\n            getter = (a, b) => a.some((element: any) => b.includes(element));\n            break;\n        case '||':\n            expectBoth(Types.text());\n            getter = (a, b) => a + b;\n            returnType = Types.text();\n            break;\n        case 'LIKE':\n        case 'ILIKE':\n        case 'NOT LIKE':\n        case 'NOT ILIKE':\n            expectBoth(Types.text());\n            const caseSenit = op === 'LIKE' || op === 'NOT LIKE';\n            const not = op === 'NOT ILIKE' || op === 'NOT LIKE';\n            if (rightValue.isConstant) {\n                const pattern = rightValue.get();\n                if (pattern === null) {\n                    return Value.null(data.ownerSchema, Types.bool);\n                }\n                let matcher: (str: string | number) => boolean | nil;\n                if (rightValue.isAny) {\n                    // handle LIKE ANY()\n                    if (!Array.isArray(pattern)) {\n                        throw new QueryError('Unsupported use of ANY()');\n                    }\n                    const patterns = pattern.map(x => buildLikeMatcher(x, caseSenit));\n                    matcher = v => patterns.some(x => x(v));\n                } else {\n                    matcher = buildLikeMatcher(pattern, caseSenit);\n                }\n                getter = !not\n                    ? a => nullIsh(a) ? null : matcher(a)\n                    : a => {\n                        if (nullIsh(a)) {\n                            return null;\n                        }\n                        const val = matcher(a);\n                        return nullIsh(val) ? null : !val;\n                    };\n            } else {\n                getter = !not\n                    ? (a, b) => hasNullish(a, b) ? null : buildLikeMatcher(b, caseSenit)(a)\n                    : (a, b) => {\n                        if (hasNullish(a, b)) {\n                            return null;\n                        }\n                        const val = buildLikeMatcher(b, caseSenit)(a);\n                        return nullIsh(val) ? null : !val;\n                    };\n            }\n            break;\n        default:\n            // throw NotSupported.never(op, 'operator');\n            throw new NotSupported('operator ' + op);\n    }\n\n    const hashed = hash(forcehash\n        ?? (commutative\n            ? { op, vals: [leftValue.hash, rightValue.hash].sort() }\n            : { left: leftValue.hash, op, right: rightValue.hash }));\n\n    // handle cases like:  blah = ANY(stuff)\n    if (leftValue.isAny || rightValue.isAny) {\n        return buildBinaryAny(data.ownerSchema, leftValue, op, rightValue, returnType, getter, hashed);\n    }\n\n    return new Evaluator(\n        data.ownerSchema\n        , returnType\n        , null\n        , hashed\n        , [leftValue, rightValue]\n        , (raw, t) => {\n            const leftRaw = leftValue.get(raw, t);\n            const rightRaw = rightValue.get(raw, t);\n            if (rejectNils && (nullIsh(leftRaw) || nullIsh(rightRaw))) {\n                return null;\n            }\n            return getter(leftRaw, rightRaw);\n        });\n\n}\n\nfunction buildBinaryAny(schema: _ISchema, leftValue: IValue, op: BinaryOperator, rightValue: IValue, returnType: _IType, getter: (a: any, b: any) => boolean, hashed: string) {\n    if (leftValue.isAny && rightValue.isAny) {\n        throw new QueryError('ANY() cannot be compared to ANY()');\n    }\n    if (returnType !== Types.bool) {\n        throw new QueryError('Invalid ANY() usage');\n    }\n    return new Evaluator(\n        schema\n        , returnType\n        , null\n        , hashed\n        , [leftValue, rightValue]\n        , leftValue.isAny\n            ? (raw, t) => {\n                const leftRaw = leftValue.get(raw, t);\n                if (nullIsh(leftRaw)) {\n                    return null;\n                }\n                if (!Array.isArray(leftRaw)) {\n                    throw new QueryError('Invalid ANY() usage: was expacting an array');\n                }\n                for (const lr of leftRaw) {\n                    const rightRaw = rightValue.get(raw, t);\n                    if (getter(lr, rightRaw)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            : (raw, t) => {\n                const rightRaw = rightValue.get(raw, t);\n                if (nullIsh(rightRaw)) {\n                    return null;\n                }\n                if (!Array.isArray(rightRaw)) {\n                    throw new QueryError('Invalid ANY() usage: was expacting an array');\n                }\n                for (const rr of rightRaw) {\n                    const leftRaw = leftValue.get(raw, t);\n                    if (getter(leftRaw, rr)) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n}\n\n\nfunction buildCase(data: _ISelection, op: ExprCase): IValue {\n    const whens = !op.value\n        ? op.whens\n        : op.whens.map<ExprWhen>(v => ({\n            when: {\n                type: 'binary',\n                op: '=',\n                left: op.value!,\n                right: v.when,\n            },\n            value: v.value,\n        }));\n    if (op.else) {\n        whens.push({\n            when: { type: 'boolean', value: true },\n            value: op.else,\n        });\n    }\n\n    const whenExprs = whens.map(x => ({\n        when: buildValue(data, x.when).convert(Types.bool),\n        then: buildValue(data, x.value)\n    }));\n\n    const valueType = reconciliateTypes(whenExprs.map(x => x.then));\n    for (const v of whenExprs) {\n        v.then = v.then.convert(valueType);\n    }\n\n    return new Evaluator(\n        data.ownerSchema\n        , valueType\n        , null\n        , hash({ when: whenExprs.map(x => ({ when: x.when.hash, then: x.then.hash })) })\n        , [\n            ...whenExprs.map(x => x.when),\n            ...whenExprs.map(x => x.then)\n        ]\n        , (raw, t) => {\n            for (const w of whenExprs) {\n                const cond = w.when.get(raw, t);\n                if (cond) {\n                    return w.then.get(raw, t);\n                }\n            }\n            return null;\n        });\n}\n\nfunction buildMember(data: _ISelection, op: ExprMember): IValue {\n    const oop = op.op;\n    if (oop !== '->>' && oop !== '->') {\n        throw NotSupported.never(oop);\n    }\n    const onExpr = buildValue(data, op.operand);\n    if (onExpr.type !== Types.json && onExpr.type !== Types.jsonb) {\n        throw new QueryError(`Cannot use member expression ${op.op} on type ${onExpr.type.primary}`);\n    }\n\n    const conv = op.op === '->'\n        ? ((x: any) => x)\n        : ((x: any) => {\n            if (nullIsh(x)) {\n                return null;\n            }\n            if (typeof x === 'string') {\n                return x;\n            }\n            return JSON.stringify(x);\n        });\n\n    return new Evaluator(\n        data.ownerSchema\n        , op.op === '->' ? onExpr.type : Types.text()\n        , null\n        , hash([onExpr.hash, op.op, op.member])\n        , onExpr\n        , typeof op.member === 'string'\n            ? (raw, t) => {\n                const value = onExpr.get(raw, t);\n                if (!value || typeof value !== 'object') {\n                    return null;\n                }\n                return conv(value[op.member]);\n            }\n            : (raw, t) => {\n                const value = onExpr.get(raw, t);\n                if (!Array.isArray(value)) {\n                    return null;\n                }\n                return conv(value[op.member as number]);\n            });\n}\n\n\nfunction buildArrayIndex(data: _ISelection, op: ExprArrayIndex): IValue {\n    const onExpr = _buildValue(data, op.array);\n    if (onExpr.type.primary !== DataType.array) {\n        throw new QueryError(`Cannot use [] expression on type ${onExpr.type.primary}`);\n    }\n    const index = _buildValue(data, op.index).convert(Types.integer);\n    return new Evaluator(\n        data.ownerSchema\n        , (onExpr.type as ArrayType).of\n        , null\n        , hash({ array: onExpr.hash, index: index.hash })\n        , [onExpr, index]\n        , (raw, t) => {\n            const value = onExpr.get(raw, t);\n            if (!Array.isArray(value)) {\n                return null;\n            }\n            const i = index.get(raw, t);\n            if (typeof i !== 'number' || i <= 0 || i > value.length) {\n                return null;\n            }\n            const ret = value[i - 1]; // 1-base !\n\n            if (Array.isArray(ret)) {\n                // ugly hack.. see clean-results.ts\n                (ret as any)[IS_PARTIAL_INDEXING] = true;\n            }\n            return ret;\n        });\n}\n\n\nfunction buildTernary(data: _ISelection, op: ExprTernary): IValue {\n    const oop = op.op;\n    if (oop !== 'NOT BETWEEN' && oop !== 'BETWEEN') {\n        throw NotSupported.never(oop);\n    }\n    let value = _buildValue(data, op.value);\n    let hi = _buildValue(data, op.hi);\n    let lo = _buildValue(data, op.lo);\n    const type = reconciliateTypes([value, hi, lo]);\n    value = value.convert(type);\n    hi = hi.convert(type);\n    lo = lo.convert(type);\n    const conv = oop === 'NOT BETWEEN'\n        ? (x: boolean) => !x\n        : (x: boolean) => x;\n\n    return new Evaluator(\n        data.ownerSchema\n        , Types.bool\n        , null\n        , hash({ value: value.hash, lo: lo.hash, hi: hi.hash })\n        , [value, hi, lo]\n        , (raw, t) => {\n            const v = value.get(raw, t);\n            if (nullIsh(v)) {\n                return null;\n            }\n            const lov = lo.get(raw, t);\n            if (!nullIsh(lov) && type.lt(v, lov)) {\n                return conv(false);\n            }\n            const hiv = hi.get(raw, t);\n            if (!nullIsh(hiv) && type.gt(v, hiv)) {\n                return conv(false);\n            }\n            if (nullIsh(lov) || nullIsh(hiv)) {\n                return null;\n            }\n            return conv(true);\n        }\n    );\n}\n\n\nfunction buildSelectAsArray(data: _ISelection, op: SelectStatement): IValue {\n    const onData = data.subquery(data, op);\n    if (onData.columns.length !== 1) {\n        throw new QueryError('subquery has too many columns');\n    }\n    return new Evaluator(\n        data.ownerSchema\n        , onData.columns[0].type.asList()\n        , null\n        , Math.random().toString() // must not be indexable => always different hash\n        , null // , onData.columns[0]\n        , (raw, t) => {\n            const ret = [];\n            for (const v of onData.enumerate(t!)) {\n                ret.push(onData.columns[0].get(v, t));\n            }\n            return ret;\n        }, {\n        forceNotConstant: true\n    });\n}\n\n\nfunction buildExtract(data: _ISelection, op: ExprExtract): IValue {\n    const from = _buildValue(data, op.from);\n    function extract(as: _IType, fn: (v: any) => any, result = Types.integer) {\n        const conv = from.convert(as);\n        return new Evaluator(\n            data.ownerSchema\n            , result\n            , null\n            , hash({ extract: from.hash, field: op.field })\n            , [conv]\n            , (raw, t) => {\n                const got = conv.get(raw, t);\n                if (nullIsh(got)) {\n                    return null;\n                }\n                return fn(got);\n            }\n        )\n    }\n    switch (op.field.name) {\n        case 'millennium':\n            return extract(Types.date, x => Math.ceil(moment.utc(x).year() / 1000));\n        case 'century':\n            return extract(Types.date, x => Math.ceil(moment.utc(x).year() / 100));\n        case 'decade':\n            return extract(Types.date, x => Math.floor(moment.utc(x).year() / 10));\n        case 'day':\n            if (from.canConvert(Types.date)) {\n                return extract(Types.date, x => moment.utc(x).date());\n            }\n            return extract(Types.interval, (x: Interval) => x.days ?? 0);\n        case 'second':\n            if (from.canConvert(Types.time)) {\n                return extract(Types.time, x => {\n                    const t = parseTime(x);\n                    return t.second() + t.milliseconds() / 1000;\n                }, Types.float);\n            }\n            return extract(Types.interval, (x: Interval) => (x.seconds ?? 0) + (x.milliseconds ?? 0) / 1000, Types.float);\n        case 'minute':\n            if (from.canConvert(Types.time)) {\n                return extract(Types.time, x => parseTime(x).minute());\n            }\n            return extract(Types.interval, (x: Interval) => x.minutes ?? 0);\n        case 'milliseconds':\n            if (from.canConvert(Types.time)) {\n                return extract(Types.time, x => {\n                    const t = parseTime(x);\n                    return t.seconds() * 1000 + t.milliseconds();\n                });\n            }\n            return extract(Types.interval, (x: Interval) => (x.seconds ?? 0) * 1000 + (x.milliseconds ?? 0), Types.float);\n        case 'month':\n            if (from.canConvert(Types.date)) {\n                return extract(Types.date, x => moment.utc(x).month() + 1);\n            }\n            return extract(Types.interval, (x: Interval) => x.months ?? 0);\n        case 'year':\n            if (from.canConvert(Types.date)) {\n                return extract(Types.date, x => moment.utc(x).year());\n            }\n            return extract(Types.interval, (x: Interval) => x.years ?? 0);\n        case 'dow':\n            return extract(Types.date, x => moment.utc(x).day());\n        case 'isodow':\n            return extract(Types.date, x => {\n                const dow = moment.utc(x).day();\n                return dow ? dow : 7;\n            });\n        case 'doy':\n            return extract(Types.date, x => moment.utc(x).dayOfYear());\n        case 'epoch':\n            if (from.canConvert(Types.timestamp)) {\n                return extract(Types.timestamp, x => moment.utc(x).unix(), Types.float);\n            }\n            return extract(Types.interval, (x: Interval) => intervalToSec(x));\n        case 'hour':\n            if (from.canConvert(Types.timestamp)) {\n                return extract(Types.timestamp, x => moment.utc(x).hour());\n            }\n            return extract(Types.interval, (x: Interval) => x.hours ?? 0);\n        case 'isoyear':\n            return extract(Types.date, x => {\n                const d = moment.utc(x);\n                return d.dayOfYear() <= 1 ? d.year() - 1 : d.year();\n            });\n        case 'quarter':\n            return extract(Types.date, x => moment.utc(x).quarter());\n        case 'week':\n            return extract(Types.date, x => moment.utc(x).week());\n        case 'microseconds':\n            if (from.canConvert(Types.time)) {\n                return extract(Types.time, x => {\n                    const t = parseTime(x);\n                    return t.seconds() * 1000000 + t.milliseconds() * 1000;\n                });\n            }\n            return extract(Types.interval, (x: Interval) => (x.seconds ?? 0) * 1000000 + (x.milliseconds ?? 0) * 1000);\n        default:\n            throw new NotSupported('Extract type \"' + op.field + '\"');\n    }\n}\n\n\nfunction buildOverlay(data: _ISelection, op: ExprOverlay): IValue {\n    const value = _buildValue(data, op.value).convert(Types.text());\n    const placing = _buildValue(data, op.placing).convert(Types.text());\n    const from = _buildValue(data, op.from).convert(Types.integer);\n    const forr = op.for && _buildValue(data, op.for).convert(Types.integer);\n\n    return new Evaluator(\n        data.ownerSchema\n        , Types.text()\n        , null\n        , hash({ overlay: value.hash, placing: placing.hash, from: from.hash, for: forr?.hash })\n        , forr ? [value, placing, from, forr] : [value, placing, from]\n        , (raw, t) => {\n            const _value = value.get(raw, t) as string;\n            if (nullIsh(_value)) {\n                return null;\n            }\n            const _placing = placing.get(raw, t) as string;\n            if (nullIsh(_placing)) {\n                return null;\n            }\n            const _from = from.get(raw, t) as number;\n            if (nullIsh(_from)) {\n                return null;\n            }\n            const before = sqlSubstring(_value, 0, _from - 1);\n            let after: string | nil;\n            if (forr) {\n                const _for = forr.get(raw, t) as number;\n                if (nullIsh(_for)) {\n                    return null;\n                }\n                after = sqlSubstring(_value, _from + _for);\n            } else {\n                after = sqlSubstring(_value, _placing.length + _from);\n            }\n            if (nullIsh(after)) {\n                return null;\n            }\n            return before + _placing + after;\n        });\n}\n\nfunction buildSubstring(data: _ISelection, op: ExprSubstring): IValue {\n    const value = _buildValue(data, op.value).convert(Types.text());\n    const vals = [value];\n    const from = op.from && _buildValue(data, op.from).convert(Types.integer);\n    const forr = op.for && _buildValue(data, op.for).convert(Types.integer);\n    if (forr) {\n        vals.push(forr);\n    }\n    if (from) {\n        vals.push(from);\n    }\n\n    return new Evaluator(\n        data.ownerSchema\n        , Types.text()\n        , null\n        , hash({ substr: value.hash, from: from?.hash, for: forr?.hash })\n        , vals\n        , (raw, t) => {\n            const _value = value.get(raw, t) as string;\n            if (nullIsh(_value)) {\n                return null;\n            }\n            let start = 0;\n            let len: number | nil;\n            if (from) {\n                start = from.get(raw, t) as number;\n                if (nullIsh(start)) {\n                    return null;\n                }\n            }\n            if (forr) {\n                len = forr.get(raw, t) as number;\n                if (nullIsh(len)) {\n                    return null;\n                }\n            }\n            return sqlSubstring(_value, start, len);\n        });\n}\n\nexport function sqlSubstring(value: string, from = 0, len?: number | nil): string | null {\n    if (nullIsh(from) || nullIsh(value)) {\n        return null;\n    }\n    // sql substring is base-1\n    from--;\n    if (from < 0) {\n        from = 0;\n    }\n    if (!nullIsh(len)) {\n        if (len! < 0) {\n            throw new QueryError('negative substring length not allowed');\n        }\n        return value.substr(from, len!);\n    }\n    return value.substr(from);\n}\n","import { Evaluator } from '../evaluator';\nimport { CastError, DataType, IValue, nil, Reg, TR, _ISchema, _IType, _RelationBase, _Transaction } from '../interfaces-private';\nimport { ArrayType } from './datatypes';\nimport { isType, nullIsh } from '../utils';\nimport objectHash from 'object-hash';\nimport { QueryError } from '../interfaces';\n\nlet regCnt = 0;\n\nexport function regGen(): Reg {\n    return {\n        classId: ++regCnt,\n        typeId: ++regCnt,\n    };\n}\n\nexport abstract class TypeBase<TRaw = any> implements _IType<TRaw>, _RelationBase {\n    get [isType.TAG]() {\n        return true;\n    }\n\n    readonly reg: Reg;\n\n    get type(): 'type' {\n        return 'type';\n    }\n\n    constructor() {\n        this.reg = regGen();\n    }\n\n    private _asArray?: _IType<TRaw[]>;\n    private _asList?: _IType<TRaw[]>;\n\n    abstract primary: DataType;\n    get name(): string {\n        return this.primary;\n    }\n\n\n    /** Compute a custom unicty hash for a non null value */\n    doGetHash?(value: TRaw): string | number;\n\n    /** Can be casted to */\n    doCanCast?(to: _IType<TRaw>): boolean | nil;\n\n    /** Can be built to from (inverse of doCanCast()) */\n    doCanBuildFrom?(from: _IType): boolean | nil;\n\n    /**\n     * @see this.prefer() doc\n      */\n    doPrefer?(type: _IType<TRaw>): _IType | null;\n\n    /**\n     * @see this.canConvertImplicit() doc\n     */\n    doCanConvertImplicit?(to: _IType<TRaw>): boolean;\n\n    /** Perform conversion from this type to given type */\n    doCast?(value: Evaluator<TRaw>, to: _IType<TRaw>): Evaluator<any> | nil;\n\n    /** Perform conversion  given type to this type (inverse of doCast()) */\n    doBuildFrom?(value: Evaluator, from: _IType): Evaluator<TRaw> | nil;\n\n    doEquals(a: TRaw, b: TRaw): boolean {\n        return a === b;\n    }\n\n    doGt(a: TRaw, b: TRaw): boolean {\n        return a > b;\n    }\n\n    doLt(a: TRaw, b: TRaw): boolean {\n        return a < b;\n    }\n    toString(): string {\n        throw new Error('Method not implemented.');\n    }\n\n    equals(a: TRaw, b: TRaw): boolean | null {\n        if (a === null || b === null) {\n            return null;\n        }\n        return this.doEquals(a, b);\n    }\n\n    gt(a: TRaw, b: TRaw): boolean | null {\n        if (a === null || b === null) {\n            return null;\n        }\n        return this.doGt(a, b);\n    }\n    lt(a: TRaw, b: TRaw): boolean | null {\n        if (a === null || b === null) {\n            return null;\n        }\n        return this.doLt(a, b);\n    }\n\n    ge(a: TRaw, b: TRaw): boolean | null {\n        return this.gt(a, b) || this.equals(a, b);\n    }\n\n    le(a: TRaw, b: TRaw): boolean | null {\n        return this.lt(a, b) || this.equals(a, b);\n    }\n\n    /**\n     * When performing 'a+b', will be given 'b' type,\n     * this returns the prefered resulting type, or null if they are not compatible\n      */\n    prefer(to: _IType<TRaw>): _IType | nil {\n        if (to === this) {\n            return this;\n        }\n        if (this.doPrefer) {\n            const ret = this.doPrefer(to);\n            if (ret) {\n                return ret;\n            }\n        }\n        return (to as TypeBase).doPrefer?.(this);\n    }\n\n    /**\n     * Can constant literals be converted implicitely\n     * (without a cast... i.e. you can use both values as different values of a case expression, for instance)\n     **/\n    canConvertImplicit(to: _IType<TRaw>): boolean | nil {\n        if (to === this) {\n            return true;\n        }\n        return this.doCanConvertImplicit?.(to);\n    }\n\n    /** Can be explicitely casted to */\n    canConvert(to: _IType<TRaw>): boolean | nil {\n        if (to === this) {\n            return true;\n        }\n\n        // ask the target type if it know how to build itself from this\n        if ((to as TypeBase).doCanBuildFrom?.(this)) {\n            return true;\n        }\n\n        // asks this type if it knows how to convert itself to target\n        if (this.doCanCast?.(to)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /** Perform conversion */\n    convert(a: IValue<TRaw>, _to: _IType<any>): IValue<any> {\n        const to = _to as TypeBase;\n        if (to === this) {\n            return a;\n        }\n        if (!(a instanceof Evaluator)) {\n            throw new CastError(this.primary, to.primary);\n        }\n\n        let converted: Evaluator | nil;\n        if (to.doCanBuildFrom?.(this)) {\n            if (!to.doBuildFrom) {\n                throw new CastError(this.primary, to.primary);\n            }\n            converted = to.doBuildFrom(a, this);\n        } else {\n            if (!this.doCanCast?.(to) || !this.doCast) {\n                throw new CastError(this.primary, to.primary);\n            }\n            converted = this.doCast(a, to);\n        }\n\n        if (!converted) {\n            throw new CastError(this.primary, to.primary);\n        }\n        return converted.setType(to);\n    }\n\n    asArray(): _IType<TRaw[]> {\n        if (this._asArray) {\n            return this._asArray;\n        }\n        return this._asArray = new ArrayType(this, false);\n    }\n\n    asList(): _IType<TRaw[]> {\n        if (this._asList) {\n            return this._asList;\n        }\n        return this._asList = new ArrayType(this, true);\n    }\n\n    hash(value: any): string | number | null {\n        if (nullIsh(value)) {\n            return null;\n        }\n        if (this.doGetHash) {\n            return this.doGetHash(value);\n        }\n        if (typeof value === 'number') {\n            return value;\n        }\n        return objectHash(value);\n    }\n\n    drop(t: _Transaction): void {\n        throw new QueryError('drop type not implemented');\n    }\n\n}\n","import { _ITable, _ISelection, _ISchema, _Transaction, _IIndex, IValue, NotSupported, PermissionDeniedError, _Column, SchemaField, IndexDef, _Explainer, _SelectExplanation, _IType, ChangeHandler, Stats, DropHandler, IndexHandler, RegClass, RegType, Reg } from '../interfaces-private';\nimport { CreateColumnDef, ExprRef, TableConstraint } from 'pgsql-ast-parser';\nimport { DataSourceBase } from '../transforms/transform-base';\nimport { Schema, ColumnNotFound, nil, ISubscription } from '../interfaces';\nimport { buildAlias } from '../transforms/alias';\nimport { columnEvaluator } from '../transforms/selection';\nimport { colByName, findTemplate } from '../utils';\n\nexport abstract class ReadOnlyTable<T = any> extends DataSourceBase<T> implements _ITable, _ISelection<any> {\n\n\n    abstract entropy(t: _Transaction): number;\n    abstract enumerate(t: _Transaction): Iterable<T>;\n    abstract hasItem(value: T, t: _Transaction): boolean;\n    abstract readonly _schema: Schema;\n\n    reg!: Reg;\n\n    readonly selection: _ISelection = buildAlias(this);\n    readonly hidden = true;\n\n    isOriginOf(v: IValue): boolean {\n        return v.origin === this || v.origin === this.selection;\n    }\n\n\n    get type() {\n        return 'table' as const;\n    }\n\n    constructor(private schema: _ISchema) {\n        super(schema);\n    }\n\n    get name(): string {\n        return this._schema.name;\n    }\n\n    register() {\n        this.reg = this.schema._reg_register(this);\n    }\n\n    private columnsById = new Map<string, IValue>();\n    private _columns?: IValue[];\n\n\n    private build() {\n        if (this._columns) {\n            return;\n        }\n        this._columns = [];\n        for (const _col of this._schema.fields) {\n            const newCol = columnEvaluator(this, _col.name, _col.type as _IType);\n            this._columns.push(newCol);\n            this.columnsById.set(_col.name, newCol);\n        }\n    }\n\n    get columns(): ReadonlyArray<IValue<any>> {\n        this.build();\n        return this._columns!;\n    }\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue<any> | nil {\n        this.build();\n        return colByName(this.columnsById, column, nullIfNotFound);\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        throw new PermissionDeniedError(this.name);\n    }\n\n    listIndices(): IndexDef[] {\n        return [];\n    }\n\n    stats(t: _Transaction): Stats | null {\n        throw new NotSupported('stats (count, ...) on information schema');\n    }\n\n    rename(to: string): this {\n        throw new PermissionDeniedError(this.name);\n    }\n    update(t: _Transaction, toUpdate: any) {\n        throw new PermissionDeniedError(this.name);\n    }\n    addColumn(column: SchemaField | CreateColumnDef): _Column {\n        throw new PermissionDeniedError(this.name);\n    }\n    getColumnRef(column: string, nullIfNotFound?: boolean): _Column {\n        throw new PermissionDeniedError(this.name);\n    }\n    addConstraint(constraint: TableConstraint, t: _Transaction) {\n        throw new PermissionDeniedError(this.name);\n    }\n    insert(item: any) {\n        throw new PermissionDeniedError(this.name);\n    }\n    doInsert(toInsert: any): void {\n        throw new PermissionDeniedError(this.name);\n    }\n    delete(t: _Transaction, toDelete: T): void {\n        throw new PermissionDeniedError(this.name);\n    }\n    truncate(t: _Transaction): void {\n        throw new PermissionDeniedError(this.name);\n    }\n\n    createIndex(): this {\n        throw new PermissionDeniedError(this.name);\n    }\n    dropIndex(t: _Transaction, name: string): void {\n        throw new PermissionDeniedError(this.name);\n    }\n    setHidden(): this {\n        throw new PermissionDeniedError(this.name);\n    }\n    drop(t: _Transaction): void {\n        throw new PermissionDeniedError(this.name);\n    }\n\n    setReadonly(): this {\n        return this;\n    }\n\n    getIndex(...forValue: IValue[]): _IIndex<any> | nil {\n        return null;\n    }\n\n    on(): any {\n        throw new NotSupported('subscribing information schema');\n    }\n    onBeforeChange(columns: string[], check: ChangeHandler<T>) {\n        // nop\n        return { unsubscribe() { } }\n    }\n    onCheckChange(columns: string[], check: ChangeHandler<T>) {\n        // nop\n        return { unsubscribe() { } }\n    }\n    onTruncate(sub: DropHandler): ISubscription {\n        // nop\n        return { unsubscribe() { } }\n    }\n    onDrop(sub: DropHandler): ISubscription {\n        // nop\n        return { unsubscribe() { } }\n    }\n    onIndex(sub: IndexHandler): ISubscription {\n        // nop\n        return { unsubscribe() { } }\n    }\n\n\n    find(template?: T, columns?: (keyof T)[]): Iterable<T> {\n        return findTemplate(this.selection, this.db.data, template, columns);\n    }\n\n\n    make(table: _ITable, i: number, t: IValue<any>): any {\n        throw new Error('not implemented');\n    }\n\n\n    *itemsByTable(table: string | _ITable, t: _Transaction): IterableIterator<any> {\n        if (typeof table === 'string') {\n            for (const s of this.db.listSchemas()) {\n                const got = s.getTable(table, true);\n                if (got) {\n                    yield* this.itemsByTable(got, t);\n                }\n            }\n        } else {\n            let i = 0;\n            for (const f of table.selection.columns) {\n                yield this.make(table, ++i, f);\n            }\n        }\n    }\n}","module.exports = require(\"pgsql-ast-parser\");","module.exports = require(\"object-hash\");","import { IValue, _IIndex, _ISelection, _IType, _Transaction, _Explainer, _ExprExplanation, _ISchema } from './interfaces-private';\nimport { DataType, QueryError, CastError, nil, ISchema } from './interfaces';\nimport hash from 'object-hash';\nimport { Types, ArrayType, isNumeric } from './datatypes';\nimport { buildCall } from './function-call';\nimport { nullIsh } from './utils';\nimport { QName } from 'pgsql-ast-parser';\n\n\nexport class Evaluator<T = any> implements IValue<T> {\n\n    readonly isConstantLiteral: boolean;\n    readonly usedColumns = new Set<IValue>();\n    readonly forceNotConstant?: boolean;\n\n    get index(): _IIndex | nil {\n        return this.origin?.getIndex(this);\n    }\n\n    get isConstant(): boolean {\n        return !this.usedColumns.size && !this.forceNotConstant;\n    }\n\n    get isConstantReal(): boolean {\n        return typeof this.val !== 'function';\n    }\n\n    origin: _ISelection | nil;\n\n    get isAny(): boolean {\n        return this.opts?.isAny ?? false;\n    }\n\n    constructor(\n        readonly owner: _ISchema\n        , readonly type: _IType<T>\n        , readonly id: string | nil\n        , readonly hash: string\n        , dependencies: IValue | IValue[] | nil\n        , public val: nil | Object | number | string | Date | ((raw: any, transaction: _Transaction | nil) => any)\n        , private opts?: {\n            isAny?: boolean;\n            isColumnOf?: _ISelection;\n            forceNotConstant?: boolean;\n            unpure?: boolean;\n        }) {\n        this.isConstantLiteral = typeof val !== 'function';\n        if (opts?.forceNotConstant) {\n            this.forceNotConstant = true;\n        }\n\n        // fetch columns to depend on\n        let depArray: IValue[] | undefined = undefined;\n        let hasNotConstant = false;\n        if (dependencies) {\n            if (!Array.isArray(dependencies)) {\n                depArray = [dependencies];\n                this.usedColumns = dependencies.usedColumns as Set<IValue>;\n                hasNotConstant = !dependencies.isConstant;\n                this.origin = dependencies.origin;\n            } else {\n                this.usedColumns = new Set();\n                for (const d of dependencies) {\n                    if (d.origin) {\n                        if (this.origin && d.origin && this.origin !== d.origin) {\n                            throw new Error('You cannot evaluate an expression which is coming from multiple origins');\n                        }\n                        this.origin = d.origin;\n                    }\n                    if (!d.isConstant) {\n                        hasNotConstant = true;\n                    }\n                    for (const u of d.usedColumns) {\n                        this.usedColumns.add(u);\n                    }\n                }\n            }\n        }\n\n        if (opts?.isColumnOf) {\n            this.usedColumns.add(this);\n            this.origin = opts.isColumnOf;\n            delete opts.isColumnOf;\n        }\n        if (hasNotConstant && !this.usedColumns.size) {\n            this.forceNotConstant = true;\n        }\n\n        if (!this.usedColumns.size // no used columns\n            && !this.origin\n            && !this.opts?.unpure\n            && !this.forceNotConstant\n            && !depArray?.some(x => !x.isConstantReal)  // all real constant dependencies\n        ) {\n            // no dependency => this is a real constant => evaluate it.\n            if (typeof this.val === 'function') {\n                this.val = this.val(null, null);\n            }\n        }\n    }\n\n    setType(type: _IType) {\n        if (this.type === type) {\n            return this;\n        }\n        return new Evaluator<T>(\n            this.owner\n            , type\n            , this.id\n            , this.hash\n            , this\n            , this.val\n            , this.opts\n        );\n    }\n\n\n\n    setConversion(converter: (val: T, t: _Transaction | nil) => any\n        , hashConv: (hash: string) => any) {\n        return new Evaluator<T>(\n            this.owner\n            , this.type\n            , this.id\n            , hash(hashConv(this.hash))\n            , this\n            , (raw, t) => {\n                let got = this.get(raw, t);\n                if (nullIsh(got)) {\n                    return null;\n                }\n                if (!this.isAny) {\n                    return converter(got, t);\n                }\n                if (!Array.isArray(got)) {\n                    throw new QueryError('Unexpected use of ANY()');\n                }\n                return (got as any[]).map(x => converter(x, t));\n            }\n            , this.opts\n        );\n    }\n\n    setOrigin(origin: _ISelection): IValue<T> {\n        const ret = this.clone();\n        ret.origin = origin;\n        return ret;\n    }\n\n    clone(): Evaluator<T> {\n        return new Evaluator<T>(\n            this.owner\n            , this.type\n            , this.id\n            , this.hash\n            , this\n            , this.val\n            , this.opts\n        );\n    }\n\n\n    setWrapper(newOrigin: _ISelection, unwrap: (val: any) => any): IValue<T> {\n        if (this.isAny) {\n            throw new QueryError('Unexpected use of ANY()');\n        }\n        const ret = new Evaluator<T>(\n            this.owner\n            , this.type\n            , this.id\n            , this.hash\n            , this\n            , (raw, t) => {\n                const got = unwrap(raw)\n                if (nullIsh(got)) {\n                    return null;\n                }\n                return this.get(got, t);\n            }\n            , this.opts\n        );\n        ret.origin = newOrigin;\n        return ret;\n    }\n\n    setId(newId: string): IValue {\n        if (this.id === newId) {\n            return this;\n        }\n        return new Evaluator<T>(\n            this.owner\n            , this.type\n            , newId\n            , this.hash\n            , this\n            , this.val\n            , this.opts\n        );\n    }\n\n    get(): T;\n    get(raw: any, t: _Transaction | nil): T;\n    get(raw?: any, t?: _Transaction): T {\n        if ((nullIsh(raw) || !t) && !this.isConstant) {\n            throw new Error('Cannot be evaluated as constant');\n        }\n        if (typeof this.val !== 'function') {\n            return this.val as any;\n        }\n        return this.val(raw, t)\n    }\n\n    canConvert(to: _IType<T>): boolean {\n        return !!this.type.canConvert(to);\n    }\n\n    convert<T = any>(to: _IType<T>): IValue<T> {\n        return this.type.convert(this, to);\n    }\n\n    explain(e: _Explainer): _ExprExplanation {\n        if (!this.origin) {\n            return {\n                constant: true,\n            }\n        }\n        return {\n            on: e.idFor(this.origin),\n            col: this.id ?? '<complex expression>',\n        };\n    }\n}\n\n// export class ArrayEvaluator<T> implements IValue {\n\n//     constructor(\n//         readonly type: _IType<T>\n//         , readonly id: string\n//         , readonly sql: string\n//         , readonly hash: string\n//         , readonly selection: _ISelection\n//         , public val: T | ((raw: any) => T)) {\n//     }\n\n//     get index() {\n//         return this.selection?.getIndex(this);\n//     }\n\n//     get isConstant(): boolean {\n//         return typeof this.val !== 'function';\n//     }\n\n//     get(raw: any): T {\n//         if (typeof this.val !== 'function') {\n//             return this.val;\n//         }\n//         return (this.val as ((raw: any) => T))(raw);\n//     }\n\n//     asConstant(perform = true) {\n//         if (!perform || typeof this.val !== 'function') {\n//             return this;\n//         }\n//         return new Evaluator(this.type\n//             , this.id\n//             , this.sql\n//             , this.hash\n//             , this.selection\n//             , this.get(null));\n//     }\n\n\n//     setId(newId: string): IValue {\n//         if (this.id === newId) {\n//             return this;\n//         }\n//         return new Evaluator<T>(\n//             this.type\n//             , newId\n//             , this.sql\n//             , this.hash\n//             , this.selection\n//             , this.val\n//         );\n//     }\n\n//     canConvert(to: DataType | _IType<T>): boolean {\n//         return this.type.canConvert(to);\n//     }\n\n//     convert<T = any>(to: DataType | _IType<T>): IValue<T> {\n//         return this.type.convert(this, to);\n//     }\n// }\n\n\nexport const Value = {\n    null(owner: _ISchema, ofType?: _IType): IValue {\n        return new Evaluator(owner, ofType ?? Types.null, null, 'null', null, null, undefined);\n    },\n    text(owner: _ISchema, value: string, length: number | nil = null): IValue {\n        return new Evaluator(\n            owner\n            , Types.text(length)\n            , null\n            , value\n            , null\n            , value);\n    },\n    number(owner: _ISchema, value: number, type = Types.float): IValue {\n        return new Evaluator(\n            owner\n            , type\n            , null\n            , value.toString(10)\n            , null\n            , value);\n    },\n    function(schema: _ISchema, value: string | QName, args: IValue[]): IValue {\n        return buildCall(schema, value, args);\n    },\n    bool(owner: _ISchema, value: boolean): IValue {\n        const str = value ? 'true' : 'false';\n        return new Evaluator(\n            owner\n            , Types.bool\n            , null\n            , str\n            , null\n            , value);\n    },\n    /** @deprecated Use with care */\n    constant(owner: _ISchema, _type: _IType, value: any): IValue {\n        const type = value === null\n            ? Types.null\n            : _type;\n        return new Evaluator(\n            owner\n            , type\n            , null\n            , (null as any)\n            , null\n            , value);\n    },\n    in(owner: _ISchema, value: IValue, array: IValue, inclusive: boolean): IValue {\n        if (!value) {\n            throw new Error('Argument null');\n        }\n        if (array.type.primary !== DataType.array) {\n            array = Value.array(owner, [array], false);\n        }\n        const of = (array.type as ArrayType).of;\n        return new Evaluator(\n            owner\n            , Types.bool\n            , null\n            , hash({ val: value.hash, in: array.hash })\n            , [value, array]\n            , (raw, t) => {\n                const rawValue = value.get(raw, t);\n                const rawArray = array.get(raw, t);\n                if (!Array.isArray(rawArray)) {\n                    return false;\n                }\n                const has = rawArray.some(x => of.equals(rawValue, x));\n                return inclusive ? has : !has;\n            });\n    },\n    isNull(owner: _ISchema, leftValue: IValue, expectNull: boolean): IValue {\n        return new Evaluator(\n            owner\n            , Types.bool\n            , null\n            , hash({ isNull: leftValue.hash, expectNull })\n            , leftValue\n            , expectNull ? ((raw, t) => {\n                const left = leftValue.get(raw, t);\n                return left === null;\n            }) : ((raw, t) => {\n                const left = leftValue.get(raw, t);\n                return left !== null && left !== undefined;\n            }))\n    },\n    isTrue(owner: _ISchema, leftValue: IValue, expectTrue: boolean): IValue {\n        leftValue = leftValue.convert(Types.bool);\n        return new Evaluator(\n            owner\n            , Types.bool\n            , null\n            , hash({ isTrue: leftValue.hash, expectTrue })\n            , leftValue\n            , expectTrue ? ((raw, t) => {\n                const left = leftValue.get(raw, t);\n                return left === true; // never returns null\n            }) : ((raw, t) => {\n                const left = leftValue.get(raw, t);\n                return !(left === true); //  never returns null\n            }));\n    },\n    isFalse(owner: _ISchema, leftValue: IValue, expectFalse: boolean): IValue {\n        leftValue = leftValue.convert(Types.bool);\n        return new Evaluator(\n            owner\n            , Types.bool\n            , null\n            , hash({ isFalse: leftValue.hash, expectFalse })\n            , leftValue\n            , expectFalse ? ((raw, t) => {\n                const left = leftValue.get(raw, t);\n                return left === false; // never returns null\n            }) : ((raw, t) => {\n                const left = leftValue.get(raw, t);\n                return !(left === false); //  never returns null\n            }));\n    },\n    negate(value: IValue): IValue {\n        if (value.type === Types.bool) {\n            return (value as Evaluator)\n                .setConversion(x => !x, x => ({ not: x }));\n        }\n        if (!isNumeric(value.type)) {\n            throw new QueryError('Can only apply \"-\" unary operator to numeric types');\n        }\n        return (value as Evaluator)\n            .setConversion(x => -x, x => ({ neg: x }));\n    },\n    array(owner: _ISchema, values: IValue[], list: boolean = false): IValue {\n        const type = values.reduce((t, v) => {\n            if (v.canConvert(t)) {\n                return t;\n            }\n            if (!t.canConvert(v.type)) {\n                throw new CastError(t.primary, v.type.primary);\n            }\n            return v.type;\n        }, Types.null);\n        // const sel = values.find(x => !!x.selection)?.selection;\n        const converted = values.map(x => x.convert(type));\n        return new Evaluator(\n            owner\n            , list ? type.asList() : type.asArray()\n            , null\n            , hash(converted.map(x => x.hash))\n            , converted\n            , (raw, t) => {\n                const arr = values.map(x => x.get(raw, t));\n                return arr;\n            });\n    }\n} as const;","import { IValue, _IIndex, _ISelection, _IType, _ISchema } from '../interfaces-private';\nimport { DataType, CastError, IType, QueryError, nil } from '../interfaces';\nimport { nullIsh, getContext } from '../utils';\nimport { Evaluator, Value } from '../evaluator';\nimport { parseArrayLiteral } from 'pgsql-ast-parser';\nimport { parseGeometricLiteral } from 'pgsql-ast-parser';\nimport { bufCompare, bufFromString, bufToString, TBuffer } from '../buffer-node';\nimport { TypeBase } from './datatype-base';\nimport { BoxType, CircleType, LineType, LsegType, PathType, PointType, PolygonType } from './datatypes-geometric';\nimport { IntervalType } from './t-interval';\nimport { TimeType } from './t-time';\nimport { TimestampType } from './t-timestamp';\nimport { JSONBType } from './t-jsonb';\nimport { RegTypeImpl } from './t-regtype';\nimport { RegClassImpl } from './t-regclass';\nimport { RecordType } from './t-record';\nimport { INetType } from './t-inet';\n\n\nclass UUIDtype extends TypeBase<Date> {\n\n\n    get primary(): DataType {\n        return DataType.uuid;\n    }\n\n    doCanCast(to: _IType) {\n        switch (to.primary) {\n            case DataType.text:\n                return true;\n        }\n        return null;\n    }\n\n    doCast(value: Evaluator, to: _IType) {\n        switch (to.primary) {\n            case DataType.text:\n                return value;\n        }\n        throw new Error('Unexpected cast error');\n    }\n}\n\n\n\nclass NullType extends TypeBase<null> {\n\n    // get name() {\n    //     return null;\n    // }\n\n    get primary(): DataType {\n        return DataType.null;\n    }\n\n    doCast(value: Evaluator<any>, to: _IType): Evaluator<any> {\n        return new Evaluator(value.owner, to, null, 'null', null, null);\n    }\n\n    doCanCast(to: _IType): boolean {\n        return true;\n    }\n\n    doEquals(a: any, b: any): boolean {\n        return false;\n    }\n\n    doGt(a: any, b: any): boolean {\n        return false;\n    }\n\n    doLt(a: any, b: any): boolean {\n        return false;\n    }\n\n    doPrefer(type: _IType) {\n        return type; // always prefer notnull types\n    }\n}\n\nconst integers = new Set([DataType.integer, DataType.bigint]);\nconst numbers = new Set([DataType.integer, DataType.bigint, DataType.decimal, DataType.float]);\n\nexport function isNumeric(t: IType) {\n    return numbers.has(t.primary);\n}\nexport function isInteger(t: IType) {\n    return integers.has(t.primary);\n}\n\nclass NumberType extends TypeBase<number> {\n\n    constructor(readonly primary: DataType) {\n        super();\n    }\n\n    doCanConvertImplicit(to: _IType) {\n        switch (to.primary) {\n            case DataType.integer:\n            case DataType.bigint:\n            case DataType.float:\n            case DataType.decimal:\n            case DataType.regtype:\n            case DataType.regclass:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    doPrefer(type: _IType): _IType | null {\n        switch (type.primary) {\n            case DataType.integer:\n            case DataType.bigint:\n                return this;\n            case DataType.float:\n            case DataType.decimal:\n                return type;\n        }\n        return null;\n    }\n\n    doCanCast(to: _IType) {\n        switch (to.primary) {\n            case DataType.integer:\n            case DataType.bigint:\n            case DataType.float:\n            case DataType.decimal:\n            case DataType.regtype:\n            case DataType.regclass:\n                return true;\n            case DataType.text:\n                return true;\n            default:\n                return false;\n        }\n    }\n    doCast(value: Evaluator<any>, to: _IType): Evaluator<any> {\n        if (!integers.has(value.type.primary) && integers.has(to.primary)) {\n            return new Evaluator(\n                value.owner\n                , to\n                , value.id\n                , value.hash\n                , value\n                , (raw, t) => {\n                    const got = value.get(raw, t);\n                    return typeof got === 'number'\n                        ? Math.round(got)\n                        : got;\n                }\n            );\n        }\n        switch (to.primary) {\n            case DataType.regtype:\n                return value\n                    .setType(Types.regtype)\n                    .setConversion((int: number) => {\n                        const got = value.owner.getType(int, { nullIfNotFound: true });\n                        if (!got) {\n                            throw new CastError(DataType.integer, DataType.regtype);\n                        }\n                        return got.name;\n                    }\n                        , intToRegType => ({ intToRegType }));\n            case DataType.regclass:\n                return value\n                    .setType(Types.regclass)\n                    .setConversion((int: number) => {\n                        // === int -> regclass\n                        const { schema } = getContext();\n                        const obj = schema.getObjectByRegOrName(int, { nullIfNotFound: true });\n                        return obj?.reg.classId ?? int;\n                    }\n                        , intToRegClass => ({ intToRegClass }));\n            case DataType.text:\n                return value\n                    .setType(to)\n                    .setConversion((int: number) => int.toString()\n                        , toTxt => ({ toTxt }));\n        }\n        return value.setType(to);\n    }\n}\n\n\n\nclass ByteArrayType extends TypeBase<TBuffer> {\n\n    get primary(): DataType {\n        return DataType.bytea;\n    }\n\n\n    doCanCast(to: _IType) {\n        switch (to.primary) {\n            case DataType.text:\n                return true;\n        }\n        return null;\n    }\n\n    doCast(value: Evaluator, to: _IType) {\n        switch (to.primary) {\n            case DataType.text:\n                return value\n                    .setConversion(raw => bufToString(raw)\n                        , toStr => ({ toStr }));\n        }\n        throw new Error('Unexpected cast error');\n    }\n\n    doEquals(a: TBuffer, b: TBuffer): boolean {\n        return bufCompare(a, b) === 0;\n    }\n\n    doGt(a: TBuffer, b: TBuffer): boolean {\n        return bufCompare(a, b) > 0;\n    }\n\n    doLt(a: TBuffer, b: TBuffer): boolean {\n        return bufCompare(a, b) < 0;\n    }\n}\n\n\nclass TextType extends TypeBase<string> {\n\n    get name(): string {\n        if (this.citext) {\n            return 'citext';\n        }\n        return this.len ? 'character varying' : 'text';\n    }\n\n    get primary(): DataType {\n        return this.citext\n            ? DataType.citext\n            : DataType.text;\n    }\n\n    constructor(readonly len: number | null, private citext?: boolean) {\n        super();\n    }\n\n    doPrefer(to: _IType) {\n        if (this.canConvert(to)) {\n            return to;\n        }\n        return null;\n    }\n\n    doCanConvertImplicit(to: _IType): boolean {\n        // text is implicitely convertible to dates\n        switch (to.primary) {\n            case DataType.text:\n            case DataType.bool:\n            case DataType.uuid:\n            case DataType.bytea:\n                return true;\n        }\n        return false;\n    }\n\n    doCanCast(to: _IType): boolean | nil {\n        switch (to.primary) {\n            case DataType.text:\n            case DataType.citext:\n                return true;\n            case DataType.text:\n            case DataType.uuid:\n                return true;\n            case DataType.bool:\n                return true;\n            case DataType.array:\n                return this.canConvert((to as ArrayType).of);\n            case DataType.bytea:\n                return true;\n        }\n        if (numbers.has(to.primary)) {\n            return true;\n        }\n        if (isGeometric(to.primary)) {\n            return true;\n        }\n        return undefined;\n    }\n\n    doCast(value: Evaluator<string>, to: _IType) {\n        switch (to.primary) {\n            case DataType.citext:\n                return value.setType(to);\n            case DataType.bool:\n                return value\n                    .setConversion(rawStr => {\n                        if (nullIsh(rawStr)) {\n                            return null;\n                        }\n                        const str = (rawStr as string).toLowerCase();\n                        if ('true'.startsWith(str)) {\n                            return true;\n                        } else if ('false'.startsWith(str)) {\n                            return false;\n                        }\n                        if ('yes'.startsWith(str)) {\n                            return true;\n                        } else if ('no'.startsWith(str)) {\n                            return false;\n                        }\n                        throw new CastError(DataType.text, DataType.bool, 'string ' + rawStr);\n                    }\n                        , toBool => ({ toBool }));\n            case DataType.uuid:\n                return value\n                    .setConversion((_rawStr: string) => {\n                        let rawStr = _rawStr;\n                        if (nullIsh(rawStr)) {\n                            return null;\n                        }\n                        // check schema\n                        if (rawStr[0] === '{') {\n                            if (rawStr[rawStr.length - 1] !== '}') {\n                                throw new CastError(DataType.text, DataType.uuid, 'string: ' + JSON.stringify(_rawStr));\n                            }\n                            rawStr = rawStr.substr(1, rawStr.length - 2);\n                        }\n                        rawStr = rawStr.toLowerCase();\n                        const [full, a, b, c, d, e] = /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/.exec(rawStr) ?? [];\n                        if (!full) {\n                            throw new CastError(DataType.text, DataType.uuid, 'string: ' + JSON.stringify(_rawStr));\n                        }\n                        return `${a}-${b}-${c}-${d}-${e}`;\n                    }\n                        , toUuid => ({ toUuid }));\n            case DataType.text:\n                const fromStr = to as TextType;\n                const toStr = to as TextType;\n                if (toStr.len === null || (fromStr.len ?? -1) < toStr.len) {\n                    // no need to truncate\n                    return value;\n                }\n                return value\n                    .setConversion(str => {\n                        if (str?.length > toStr.len!) {\n                            throw new QueryError(`value too long for type character varying(${toStr.len})`);\n                        }\n                        return str;\n                    }\n                        , truncate => ({ truncate, len: toStr.len }));\n\n            case DataType.array:\n                return value\n                    .setType(to)\n                    .setConversion((str: string) => {\n                        const array = parseArrayLiteral(str);\n                        (to as ArrayType).convertLiteral(value.owner, array);\n                        return array;\n                    }\n                        , parseArray => ({ parseArray }));\n            case DataType.bytea:\n                return value\n                    .setConversion(str => {\n                        return bufFromString(str);\n                    }\n                        , toBytea => ({ toBytea }));\n\n        }\n        if (numbers.has(to.primary)) {\n            const isInt = integers.has(to.primary);\n            return value\n                .setConversion(str => {\n                    const val = Number.parseFloat(str);\n                    if (!Number.isFinite(val)) {\n                        throw new QueryError(`invalid input syntax for ${to.primary}: ${str}`);\n                    }\n                    if (isInt && Math.floor(val) !== val) {\n                        throw new QueryError(`invalid input syntax for ${to.primary}: ${str}`)\n                    }\n                    return val;\n                }\n                    , castNum => ({ castNum, to: to.primary }));\n        }\n        if (isGeometric(to.primary)) {\n            return value\n                .setConversion(str => {\n                    const ret = parseGeometricLiteral(str, to.primary as any);\n                    return ret;\n                }\n                    , castGeo => ({ castGeo, to: to.primary }));\n        }\n        return undefined;\n    }\n\n    doEquals(a: string, b: string) {\n        if (this.citext) {\n            return a.localeCompare(b, undefined, { sensitivity: 'accent' }) === 0;\n        }\n\n        return super.doEquals(a, b);\n    }\n}\n\n\n\nclass BoolType extends TypeBase<boolean> {\n    get primary(): DataType {\n        return DataType.bool;\n    }\n}\n\nexport class ArrayType extends TypeBase<any[]> {\n    get primary(): DataType {\n        return DataType.array;\n    }\n\n    get name(): string {\n        return this.of.name + '[]';\n    }\n\n\n    constructor(readonly of: _IType, private list: boolean) {\n        super();\n    }\n\n    doCanCast(to: _IType) {\n        if (to.primary === DataType.text) {\n            return this.of.canConvert(to);\n        }\n        return to instanceof ArrayType\n            && this.of.canConvert(to.of);\n    }\n\n    doCast(value: Evaluator, _to: _IType) {\n        if (_to.primary === DataType.text) {\n            return this.toText(_to, value);\n        }\n\n        const to = _to as ArrayType;\n        const valueType = value.type as ArrayType;\n        return new Evaluator(\n            value.owner\n            , to\n            , value.id\n            , value.hash!\n            , value\n            , (raw, t) => {\n                const arr = value.get(raw, t) as any[];\n                return arr.map(x => Value.constant(value.owner, valueType.of, x).convert(to.of).get(raw, t));\n            });\n    }\n\n    toText(to: _IType, value: Evaluator) {\n        const valueType = value.type as ArrayType;\n        return new Evaluator(\n            value.owner\n            , to\n            , value.id\n            , value.hash!\n            , value\n            , (raw, t) => {\n                const arr = value.get(raw, t) as any[];\n                const strs = arr.map(x => Value.constant(value.owner, valueType.of, x).convert(Types.text()).get(raw, t));\n                const data = strs.join(',');\n                return this.list\n                    ? '(' + data + ')'\n                    : '{' + data + '}';\n            });\n    }\n\n    doEquals(a: any[], b: any[]): boolean {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!this.of.equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    doGt(a: any[], b: any[]): boolean {\n        const len = Math.min(a.length, b.length);\n        for (let i = 0; i < len; i++) {\n            if (this.of.gt(a[i], b[i])) {\n                return true;\n            }\n        }\n        return a.length > b.length;\n    }\n\n    doLt(a: any[], b: any[]): boolean {\n        const len = Math.min(a.length, b.length);\n        for (let i = 0; i < len; i++) {\n            if (this.of.lt(a[i], b[i])) {\n                return true;\n            }\n        }\n        return a.length < b.length;\n    }\n\n    convertLiteral(owner: _ISchema, elts: any) {\n        if (nullIsh(elts)) {\n            return;\n        }\n        if (!Array.isArray(elts)) {\n            throw new QueryError('Array depth mismatch: was expecting an array item.');\n        }\n        if (this.of instanceof ArrayType) {\n            for (let i = 0; i < elts.length; i++) {\n                this.of.convertLiteral(owner, elts[i]);\n            }\n        } else {\n            for (let i = 0; i < elts.length; i++) {\n                if (Array.isArray(elts[i])) {\n                    throw new QueryError('Array depth mismatch: was not expecting an array item.');\n                }\n                elts[i] = Value.text(owner, elts[i])\n                    .convert(this.of)\n                    .get();\n            }\n        }\n        return elts;\n    }\n}\n\n\n/** Basic types */\nexport const Types = {\n    [DataType.record]: new RecordType() as _IType,\n    [DataType.bool]: new BoolType() as _IType,\n    [DataType.text]: (len: number | nil = null) => makeText(len) as _IType,\n    [DataType.citext]: new TextType(null, true),\n    [DataType.timestamp]: new TimestampType(DataType.timestamp) as _IType,\n    [DataType.timestamptz]: new TimestampType(DataType.timestamptz) as _IType,\n    [DataType.uuid]: new UUIDtype() as _IType,\n    [DataType.date]: new TimestampType(DataType.date) as _IType,\n    [DataType.interval]: new IntervalType() as _IType,\n    [DataType.time]: new TimeType() as _IType,\n    [DataType.jsonb]: new JSONBType(DataType.jsonb) as _IType,\n    [DataType.regtype]: new RegTypeImpl() as _IType,\n    [DataType.regclass]: new RegClassImpl() as _IType,\n    [DataType.json]: new JSONBType(DataType.json) as _IType,\n    [DataType.null]: new NullType() as _IType,\n    [DataType.float]: new NumberType(DataType.float) as _IType,\n    [DataType.integer]: new NumberType(DataType.integer) as _IType,\n    [DataType.bigint]: new NumberType(DataType.bigint) as _IType,\n    [DataType.bytea]: new ByteArrayType() as _IType,\n    [DataType.point]: new PointType() as _IType,\n    [DataType.line]: new LineType() as _IType,\n    [DataType.lseg]: new LsegType() as _IType,\n    [DataType.box]: new BoxType() as _IType,\n    [DataType.inet]: new INetType() as _IType,\n    [DataType.path]: new PathType() as _IType,\n    [DataType.polygon]: new PolygonType() as _IType,\n    [DataType.circle]: new CircleType() as _IType,\n}\n\nexport function isGeometric(dt: DataType) {\n    switch (dt) {\n        case DataType.point:\n        case DataType.line:\n        case DataType.lseg:\n        case DataType.box:\n        case DataType.path:\n        case DataType.polygon:\n        case DataType.circle:\n            return true;\n    }\n    return false;\n}\n\nconst texts = new Map<number | null, _IType>();\nfunction makeText(len: number | nil = null) {\n    len = len ?? null;\n    let got = texts.get(len);\n    if (!got) {\n        texts.set(len, got = new TextType(len));\n    }\n    return got;\n}\n\n\n\n\n\n\n\nexport const typeSynonyms: { [key: string]: DataType } = {\n    'varchar': DataType.text,\n    'char': DataType.text,\n    'character': DataType.text,\n    'character varying': DataType.text,\n\n    'int': DataType.integer,\n    'int4': DataType.integer,\n    'serial': DataType.integer,\n    'bigserial': DataType.integer,\n    'smallserial': DataType.integer,\n    'smallint': DataType.integer,\n    'bigint': DataType.integer,\n    'oid': DataType.integer,\n\n    'decimal': DataType.float,\n    'float': DataType.float,\n    'double precision': DataType.float,\n    'numeric': DataType.float,\n    'real': DataType.float,\n    'money': DataType.float,\n\n    'timestamptz': DataType.timestamp, //  => todo support timestamptz\n    'timestamp with time zone': DataType.timestamp, //  => todo support timestamptz\n    'timestamp without time zone': DataType.timestamp,\n\n    'boolean': DataType.bool,\n\n    'time with time zone': DataType.time,\n    'time without time zone': DataType.time,\n}\n\n\n/** Finds a common type by implicit conversion */\nexport function reconciliateTypes(values: IValue[], nullIfNoMatch?: false): _IType;\nexport function reconciliateTypes(values: IValue[], nullIfNoMatch: true): _IType | nil;\nexport function reconciliateTypes(values: IValue[], nullIfNoMatch?: boolean): _IType | nil\nexport function reconciliateTypes(values: IValue[], nullIfNoMatch?: boolean): _IType | nil {\n    // FROM  https://www.postgresql.org/docs/current/typeconv-union-case.html\n\n    const nonNull = values\n        .filter(x => x.type.primary !== DataType.null);\n\n    if (!nonNull.length) {\n        // If all inputs are of type unknown, resolve as type text (the preferred type of the string category). Otherwise, unknown inputs are ignored for the purposes of the remaining rules.\n        return Types.text();\n    }\n\n    // If all inputs are of the same type, and it is not unknown, resolve as that type.\n    const single = new Set(nonNull\n        .map(v => v.type.reg.typeId));\n    if (single.size === 1) {\n        return nonNull[0].type;\n    }\n\n    return reconciliateTypesRaw(nonNull, nullIfNoMatch);\n}\n\n\n\n/** Finds a common type by implicit conversion */\nfunction reconciliateTypesRaw(values: IValue[], nullIfNoMatch?: false): _IType;\nfunction reconciliateTypesRaw(values: IValue[], nullIfNoMatch: true): _IType | nil;\nfunction reconciliateTypesRaw(values: IValue[], nullIfNoMatch?: boolean): _IType | nil\nfunction reconciliateTypesRaw(values: IValue[], nullIfNoMatch?: boolean): _IType | nil {\n    // find the matching type among non constants\n    const foundType = values\n        .reduce((final, c) => {\n            if (c.type === Types.null) {\n                return final;\n            }\n            const pref = final.prefer(c.type);\n            if (!pref) {\n                throw new CastError(c.type.primary, final.primary, c.id ?? undefined);\n            }\n            return pref;\n        }, Types.null);\n\n    // check that all constant literals are matching this.\n    for (const x of values) {\n        if (!x.isConstantLiteral && !x.type.canConvertImplicit(foundType)) {\n            if (nullIfNoMatch) {\n                return null;\n            }\n            throw new CastError(x.type.primary, foundType.primary);\n        }\n    }\n\n    return foundType;\n}\n","import { _ISelection, _IIndex, IValue, setId, getId, _IType, _Transaction, _Column, _ITable, _Explainer, _SelectExplanation, IndexKey, _IndexExplanation, IndexExpression, IndexOp, Stats, _IAlias } from '../interfaces-private';\nimport { QueryError, ColumnNotFound, DataType, CastError, Schema, NotSupported, AmbiguousColumn, SchemaField, nil, typeDefToStr } from '../interfaces';\nimport { buildValue } from '../expression-builder';\nimport { Evaluator } from '../evaluator';\nimport { TransformBase } from './transform-base';\nimport { SelectedColumn, CreateColumnDef, ExprCall, Expr, astVisitor, ExprRef } from 'pgsql-ast-parser';\nimport { aggregationFunctions, buildGroupBy } from './aggregation';\n\nimport { asSingleQName, colByName, colToStr, isSelectAllArgList, suggestColumnName } from '../utils';\n\n\nexport function buildSelection(on: _ISelection, select: SelectedColumn[] | nil) {\n    select = select ?? [];\n\n    // if this is a \"SELECT *\" => just ignore\n    if (isSelectAllArgList(select.map(x => x.expr))) {\n        if (!on.columns.length) {\n            throw new QueryError('SELECT * with no tables specified is not valid');\n        }\n        return on;\n    }\n\n    // if there is any aggregation function\n    // check if there is any aggregation\n    for (const col of select ?? []) {\n        if ('expr' in col && hasAggreg(col.expr)) {\n            // yea, there is an aggregation somewhere in selection\n            return buildGroupBy(on, [], select);\n        }\n    }\n\n    return new Selection(on, select);\n}\n\n\nfunction hasAggreg(e: Expr) {\n    let has = false;\n    astVisitor(visitor => ({\n        call: expr => {\n            const nm = asSingleQName(expr.function, 'pg_catalog');\n            if (nm && aggregationFunctions.has(nm)) {\n                // yea, this is an aggregation\n                has = true;\n                return;\n            }\n            visitor.super().call(expr);\n        }\n    })).expr(e);\n    return has\n}\n\n\n\nexport function columnEvaluator(this: void, on: _ISelection, id: string, type: _IType) {\n    if (!id) {\n        throw new Error('Invalid column id');\n    }\n    const ret = new Evaluator(\n        on.ownerSchema\n        , type\n        , id\n        , id\n        , null\n        , raw => raw[id]\n        , {\n            isColumnOf: on,\n        });\n    return ret;\n}\n\nfunction* buildCols(this: void, base: _ISelection, columns: (SelectedColumn | CustomAlias)[]): Iterable<CustomAlias> {\n    for (const s of columns) {\n        if ('val' in s) {\n            if (s.val.origin !== base) {\n                throw new Error('Corrupted selection');\n            }\n            yield s;\n            continue;\n        }\n        if (s.expr.type === 'ref' && s.expr.name === '*') {\n            // handle select \"*\"\n            if (s.alias) {\n                throw new QueryError('Cannot alias *');\n            }\n            let of: _IAlias = base;\n            const alias = s.expr.table;\n            if (alias) {\n                // handle select \"x.*\"\n                const sub = base.selectAlias(alias.name);\n                if (!sub) {\n                    throw new QueryError(`Unknown alias \"${alias.name}\"`);\n                }\n                of = sub;\n            }\n\n            for (const val of of.listColumns()) {\n                yield { val };\n            }\n\n        } else {\n            const val = buildValue(base as _ISelection, s.expr);\n            yield { val, as: s.alias?.name, expr: s.expr };\n        }\n    }\n}\n\nexport interface CustomAlias {\n    val: IValue;\n    as?: string;\n    expr?: Expr\n}\n\nexport class Selection<T = any> extends TransformBase<T> implements _ISelection<T> {\n\n    private columnIds: string[] = [];\n    private columnsOrigin: IValue[] = [];\n    private columnMapping = new Map<IValue, IValue>();\n    private indexCache = new Map<IValue, _IIndex>();\n    private columnsById = new Map<string, IValue[]>();\n    private symbol = Symbol();\n\n    readonly columns: IValue[] = [];\n\n\n    constructor(base: _ISelection<any>, _columns: (SelectedColumn | CustomAlias)[]) {\n        super(base);\n\n        // build non-conflicting column ids based on existing ones\n        const columns = [...buildCols(base, _columns)];\n        this.columnIds = columns.map(x => x.as ?? x.val.id!);\n\n        // build column ids\n        let anonymousBases = new Map<string, number>();\n        for (let i = 0; i < this.columnIds.length; i++) {\n            if (!this.columnIds[i]) {\n                let id = suggestColumnName(columns[i].expr) ?? 'column';\n\n                // check no collision with an existing column\n                let cnt = anonymousBases.get(id);\n                this.columnIds[i] = id + (cnt ? cnt : '');\n                anonymousBases.set(id, (cnt ?? 0) + 1);\n            }\n        }\n\n\n        // build columns to select\n        for (let i = 0; i < columns.length; i++) {\n            this.refColumn(columns[i].val, this.columnIds[i]);\n        }\n\n\n        // ONLY ONCE COLUMNS HAVE BEEN REFERENCED BY ID,\n        // rename ids for columns which have the same id\n        // this allows yielding ambiguous columns data\n        const has = new Map<string, number>();\n        for (let i = 0; i < columns.length; i++) {\n            const orig = this.columnIds[i];\n            const oi = has.get(orig);\n            if (typeof oi !== 'number') {\n                has.set(orig, i);\n                continue;\n            }\n            let ret: string = orig;\n            let k = 0;\n            do {\n                ret = orig + (++k);\n            } while (this.columnIds.includes(ret));\n            this.columnIds[i] = ret;\n            has.set(ret, i);\n        }\n    }\n\n    private refColumn(fromCol: IValue, alias: string) {\n        const col = columnEvaluator(this, alias, fromCol.type);\n        this.columns.push(col);\n        this.columnMapping.set(col, fromCol);\n        this.columnsOrigin.push(fromCol);\n        if (!col.id) {\n            return;\n        }\n        let ci = this.columnsById.get(col.id);\n        if (!ci) {\n            this.columnsById.set(col.id, ci = []);\n        }\n        ci.push(col);\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return this.base.stats(t);\n    }\n\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        for (const item of this.base.enumerate(t)) {\n            yield this.build(item, t);\n        }\n    }\n\n    build(item: any, t: _Transaction): T {\n        const ret: any = {};\n        setId(ret, getId(item));\n        ret[this.symbol] = this.symbol;\n        for (let i = 0; i < this.columns.length; i++) {\n            const col = this.columnsOrigin[i];\n            ret[this.columnIds[i]] = col.get(item, t) ?? null;\n        }\n        return ret as any;\n    }\n\n    hasItem(value: T, t: _Transaction): boolean {\n        return (value as any)[this.symbol] === this.symbol;\n    }\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil {\n        const ret = colByName(this.columnsById, column, true);\n        if (!ret?.length) {\n            if (nullIfNotFound) {\n                return null;\n            }\n            throw new ColumnNotFound(colToStr(column));\n        }\n        if (ret.length !== 1) {\n            throw new AmbiguousColumn(colToStr(column));\n        }\n        return ret[0];\n    }\n\n    getIndex(val: IValue): _IIndex | nil {\n        if (this.indexCache.has(val)) {\n            return this.indexCache.get(val);\n        }\n        const mapped = this.columnMapping.get(val);\n        const originIndex = this.base.getIndex(mapped!);\n        const ret = originIndex && new SelectionIndex(this, originIndex);\n        this.indexCache.set(val, ret!);\n        return ret;\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'map',\n            of: this.base.explain(e),\n            select: this.columnIds.map((x, i) => ({\n                what: this.columnsOrigin[i].explain(e),\n                as: x\n            })),\n        };\n    }\n}\n\n\nexport class SelectionIndex<T> implements _IIndex<T> {\n    constructor(readonly owner: Selection<T>, private base: _IIndex) {\n    }\n\n    stats(t: _Transaction, key?: IndexKey) {\n        return this.base.stats(t, key);\n    }\n\n    iterateKeys(t: _Transaction) {\n        return this.base.iterateKeys(t);\n    }\n\n    get expressions(): IndexExpression[] {\n        return this.base.expressions;\n    }\n\n    entropy(op: IndexOp): number {\n        // same as source\n        return this.base.entropy(op);\n    }\n\n    eqFirst(rawKey: IndexKey, t: _Transaction) {\n        return this.base.eqFirst(rawKey, t);\n    }\n\n    *enumerate(op: IndexOp): Iterable<T> {\n        for (const i of this.base.enumerate(op)) {\n            yield this.owner.build(i, op.t);\n        }\n    }\n\n\n    explain(e: _Explainer): _IndexExplanation {\n        return {\n            _: 'indexMap',\n            of: this.base.explain(e),\n        }\n    }\n}","module.exports = require(\"immutable\");","module.exports = require(\"moment\");","export const JSON_NIL = Symbol('null');\nexport const IS_PARTIAL_INDEXING = Symbol('partial_indexing');\nexport const SELECT_ALL = Symbol('select *');\n\n\nexport function cleanResults(results: any[]): any {\n    // ugly hack to turn jsonb nulls & partial indexed results into actual nulls\n    // This will bite me someday ... but please dont judge me, I too try to have a life outside here \n    // The sane thing to do would be to refactor things & introduce a DBNULL value in pgmem\n    //   since the need of such DBNULL value could arise somehow on another type\n    //   see:\n    //   - `can select jsonb null` test in nulls.spec.ts\n    //   - `executes array multiple index incomplete indexing` test in operators.queries.spec.ts\n\n    function cleanObj(obj: any) {\n        if (!obj || typeof obj !== 'object') {\n            return;\n        }\n        for (const [k, v] of Object.entries(obj)) {\n            if (v === JSON_NIL) {\n                obj[k] = null;\n            } else if (Array.isArray(v)) {\n                if ((v as any)[IS_PARTIAL_INDEXING]) {\n                    obj[k] = null;\n                } else {\n                    for (let i = 0; i < v.length; i++) {\n                        if (obj[i] === JSON_NIL) {\n                            obj[i] = null;\n                        } else {\n                            cleanObj(v);\n                        }\n                    }\n                }\n            } else {\n                cleanObj(v);\n            }\n        }\n    }\n\n    for (let i = 0; i < results.length; i++) {\n        const sel = results[i][SELECT_ALL];\n        if (sel) {\n            results[i] = sel();\n        }\n        cleanObj(results[i]);\n    }\n    return results;\n}","export type TBuffer = Buffer;\n\n\nexport function bufToString(buf: TBuffer): string {\n    return buf?.toString('utf-8');\n}\n\nexport function bufCompare(a: TBuffer, b: TBuffer) {\n    return Buffer.compare(a, b);\n}\n\nexport function bufFromString(str: string) {\n    return Buffer.from(str);\n}\n\nexport function isBuf(v: any): v is TBuffer {\n    return Buffer.isBuffer(v);\n}\n\nexport function bufClone(buf: TBuffer): TBuffer {\n    const bufcopy = Buffer.alloc(buf.length);\n    buf.copy(bufcopy);\n    return bufcopy;\n}","module.exports = require(\"lru-cache\");","import { TransformBase } from './transform-base';\nimport { _ISelection, _Transaction, IValue, _IIndex, _Explainer, _SelectExplanation, _IType, IndexKey, _ITable, Stats, AggregationComputer, AggregationGroupComputer } from '../interfaces-private';\nimport { SelectedColumn, Expr, ExprRef, ExprCall } from 'pgsql-ast-parser';\nimport { buildValue } from '../expression-builder';\nimport { ColumnNotFound, nil, NotSupported, QueryError } from '../interfaces';\nimport { colByName, suggestColumnName } from '../utils';\nimport hash from 'object-hash';\nimport { Evaluator } from '../evaluator';\nimport { buildCount } from './aggregations/count';\nimport { buildMinMax } from './aggregations/max-min';\nimport { buildSum } from './aggregations/sum';\nimport { buildArrayAgg } from './aggregations/array_agg';\nimport { buildAvg } from './aggregations/avg';\n\nexport const aggregationFunctions = new Set([\n    'array_agg',\n    'avg',\n    'bit_and',\n    'bit_or',\n    'bool_and',\n    'bool_or',\n    'count',\n    'every',\n    'json_agg',\n    'jsonb_agg',\n    'json_object_agg',\n    'jsonb_object_agg',\n    'max',\n    'min',\n    'string_agg',\n    'sum',\n    'xmlagg',\n])\n\nexport function buildGroupBy(on: _ISelection, groupBy: Expr[], select: SelectedColumn[]) {\n    const group = groupBy.map(x => buildValue(on, x));\n    return new Aggregation(on, group, select);\n}\n\nexport class Aggregation<T> extends TransformBase<T> implements _ISelection<T> {\n\n    columns: readonly IValue<any>[];\n    /**\n     * Group-by values\n     * - key: column in source hash\n     * - value: column in this, evaluated against temporary entity.\n     **/\n    private groupByMapping = new Map<string, IValue>();\n    private building: 'groupby' | 'select' | null = 'groupby';\n    private readonly symbol = Symbol();\n    private readonly groupIndex?: _IIndex<any> | nil;\n    private columnsById: Map<string, IValue>;\n    private aggregations = new Map<string, {\n        getter: IValue;\n        id: symbol;\n        computer: AggregationComputer;\n    }>();\n\n    constructor(on: _ISelection, private readonly groupedBy: IValue[], select: SelectedColumn[]) {\n        super(on);\n\n        // preassign columns that are reachable (grouped by)\n        for (let _i = 0; _i < groupedBy.length; _i++) {\n            const i = _i;\n            const g = groupedBy[i];\n            this.groupByMapping.set(g.hash!, new Evaluator(\n                on.ownerSchema\n                , g.type\n                , g.id\n                , g.hash!\n                , [g]\n                , v => v[this.symbol][i]\n            ));\n        }\n\n        // try to find an index matching our groupby clause\n        this.groupIndex = on.getIndex(...groupedBy);\n\n        // build selection\n        const cols = new Map<string, IValue>();\n        let anonymous = 0;\n        this.building = 'select';\n        for (const s of select) {\n            const built = buildValue(this, s.expr);\n            if (s.alias && cols.has(s.alias.name)) {\n                throw new NotSupported('Ambiguous aliasing');\n            }\n            const name = s.alias?.name\n                ?? suggestColumnName(s.expr)\n                ?? built.id\n                ?? ('column' + (anonymous++));\n            cols.set(name, built);\n        }\n        this.building = null;\n        this.columnsById = cols;\n        this.columns = [...cols.values()];\n    }\n\n\n    entropy(t: _Transaction): number {\n        return this.groupByMapping.size || 1;\n    }\n\n    stats(): Stats | null {\n        // cannot be computed without iterating\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        for (const item of this._enumerate(t)) {\n            const ret: any = {};\n            ret[this.symbol] = true;\n            for (const [k, v] of this.columnsById) {\n                ret[k] = v.get(item, t);\n            }\n            yield ret;\n        }\n    }\n\n    private *_enumerate(t: _Transaction): Iterable<T> {\n        const aggs = [...this.aggregations.values()];\n\n        // ===== try to compute directly (will only succeed when no grouping, and simple statements like count(*))\n        const ret = this.computeDirect(t);\n        if (ret) {\n            yield ret;\n            return;\n        }\n\n        // ===== try to compute base on index\n        if (this.groupIndex) {\n            const allByGroup = !aggs.some(x => !x.computer.computeFromIndex);\n            if (allByGroup) {\n                let yielded = false;\n                let invalid = false;\n                // iterate all index keys\n                for (const k of this.groupIndex.iterateKeys(t)!) {\n                    if (invalid) {\n                        break;\n                    }\n                    const ret: any = { [this.symbol]: k };\n                    // try to compute from index\n                    for (const agg of aggs) {\n                        const val = agg.computer.computeFromIndex?.(k, this.groupIndex, t);\n                        if (typeof val === 'undefined') {\n                            if (yielded) {\n                                throw new Error('Compute from index has succeeded on an index key, but failed on another (which must not happen)');\n                            }\n                            invalid = false;\n                            break;\n                        }\n                        ret[agg.id] = val;\n                    }\n                    yield ret;\n                    yielded = true;\n                }\n                if (!invalid) {\n                    return;\n                }\n            }\n        }\n\n        // ==== seq-scan computation\n        yield* this.seqScan(t);\n    }\n\n\n    private *seqScan(t: _Transaction): Iterable<any> {\n        const aggs = [...this.aggregations.values()];\n        const groups = new Map<string, {\n            key: IndexKey;\n            aggs: {\n                id: symbol;\n                computer: AggregationGroupComputer;\n            }[];\n        }>();\n        // === feed all items\n        for (const item of this.base.enumerate(t)) {\n            const key: IndexKey = this.groupedBy.map(g => g.get(item, t));\n            const groupingKey = hash(key);\n            let group = groups.get(groupingKey);\n            if (!group) {\n                groups.set(groupingKey, group = {\n                    key,\n                    aggs: aggs.map(x => ({\n                        id: x.id,\n                        computer: x.computer.createGroup(t),\n                    })),\n                });\n            }\n            for (const g of group.aggs) {\n                g.computer.feedItem(item);\n            }\n        }\n\n        // if this.base is empty, and this is not a group by...\n        //   Must return a result.\n        //   ex:\n        //      - select max(a) from empty               [{max: null}]\n        //      - select max(a) from empty group by id   []\n        if (groups.size === 0 && !this.groupedBy.length) {\n            const key: IndexKey = this.groupedBy.map(() => null);\n            const groupingKey = hash(key);\n            groups.set(groupingKey, {\n                key,\n                aggs: aggs.map(x => ({\n                    id: x.id,\n                    computer: x.computer.createGroup(t),\n                })),\n            });\n        }\n\n        // === return results\n        for (const g of groups.values()) {\n            const ret: any = { [this.symbol]: g.key };\n            for (const { id, computer } of g.aggs) {\n                ret[id] = computer.finish() ?? null;\n            }\n            yield ret;\n        }\n    }\n\n    computeDirect(t: _Transaction) {\n        // When there is no grouping...\n        if (this.groupByMapping.size) {\n            return null;\n        }\n        // check if all selected aggregations can be computed directly (typically: count(*))\n        const aggs = [...this.aggregations.values()];\n        const allNoGroup = !aggs.some(x => !x.computer.computeNoGroup);\n        if (!allNoGroup) {\n            return null;\n        }\n        const ret: any = {\n            [this.symbol]: [],\n        };\n        for (const agg of this.aggregations.values()) {\n            const val = agg.computer.computeNoGroup?.(t);\n            if (typeof val === 'undefined') {\n                return null;\n            }\n            ret[agg.id] = val;\n        }\n        return ret;\n    }\n\n\n    checkIfIsKey(got: IValue<any>): IValue<any> {\n        if (this.building !== 'select') {\n            return got;\n        }\n        return this.groupByMapping.get(got.hash!) ?? got;\n    }\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue<any> | nil {\n        if (this.building) {\n            // when building, expressions are built agains \"this\"\n            // => must check if parent column exists (might be aliased => cannot check by name)\n            return this.base.getColumn(column, nullIfNotFound);\n        } else {\n            // normal behiavour (get columns from \"exterior\")\n            return colByName(this.columnsById, column, nullIfNotFound);\n        }\n    }\n\n    getAggregation(name: string, call: ExprCall): IValue {\n        const hashed = hash(call);\n        const agg = this.aggregations.get(hashed);\n        if (agg) {\n            return agg.getter;\n        }\n        const got = this._getAggregation(name, call);\n\n        const id = Symbol();\n        const getter = new Evaluator(\n            this.ownerSchema\n            , got.type\n            , null\n            , hashed\n            , []\n            , raw => raw[id]\n            , {\n                forceNotConstant: true,\n            });\n\n        this.aggregations.set(hashed, {\n            id,\n            getter,\n            computer: got,\n        });\n        return getter;\n    }\n\n    private _getAggregation(name: string, call: ExprCall): AggregationComputer {\n        switch (name) {\n            case 'count':\n                return buildCount(this.base, call);\n            case 'max':\n            case 'min':\n                return buildMinMax(this.base, call.args, name);\n            case 'sum':\n                return buildSum(this.base, call);\n            case 'array_agg':\n                return buildArrayAgg(this.base, call);\n            case 'avg':\n                return buildAvg(this.base, call);\n            default:\n                throw new NotSupported('aggregation function ' + name);\n        }\n    }\n\n\n    hasItem(value: T, t: _Transaction): boolean {\n        return !!(value as any)[this.symbol];\n    }\n\n    getIndex(forValue: IValue<any>): _IIndex<any> | nil {\n        // there is no index on aggregations\n        return null;\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            _: 'aggregate',\n            id: e.idFor(this),\n            aggregator: null as any,\n        }\n    }\n\n}\n","import { TransformBase, FilterBase } from './transform-base';\nimport { _Transaction, IValue, _Explainer, _ISelection, _SelectExplanation, QueryError, Stats, nil, _IAlias } from '../interfaces-private';\nimport { Evaluator } from '../evaluator';\nimport { Types } from '../datatypes';\nimport { ExprRef } from 'pgsql-ast-parser';\nimport { asSingleName, colToStr } from '../utils';\nimport { ColumnNotFound } from '../interfaces';\n\nexport function buildAlias(on: _ISelection, alias?: string): _ISelection<any> {\n    if (!alias) {\n        return on as any;\n    }\n    if (on instanceof Alias && on.name === alias) {\n        return on;\n    }\n    return new Alias(on, alias);\n}\n\nexport class Alias<T> extends TransformBase<T> implements _IAlias {\n\n    private oldToThis = new Map<IValue, IValue>();\n    private thisToOld = new Map<IValue, IValue>();\n    private _columns: IValue<any>[] | null = null;\n    private asRecord!: IValue;\n\n    constructor(sel: _ISelection, public name: string) {\n        super(sel);\n    }\n\n    *listSelectableIdentities(): Iterable<IValue> {\n        this.init();\n        yield* super.listSelectableIdentities();\n        yield this.asRecord;\n    }\n\n\n    rebuild() {\n        this._columns = null;\n        this.oldToThis.clear();\n        this.thisToOld.clear();\n    }\n\n    selectAlias(alias: string): _IAlias | nil {\n        if (this.name === alias) {\n            return this;\n        }\n        return null;\n    }\n\n    listColumns(): Iterable<IValue> {\n        return this.columns;\n    }\n\n\n    get debugId() {\n        return this.base.debugId;\n    }\n\n    get columns(): ReadonlyArray<IValue<any>> {\n        this.init();\n        return this._columns!;\n    }\n    init() {\n        if (this._columns) {\n            return;\n        }\n        this._columns = this.base.columns.map(x => {\n            const ret = x.setOrigin(this);\n            this.oldToThis.set(x, ret);\n            this.thisToOld.set(ret, x);\n            return ret;\n        });\n\n        this.asRecord = new Evaluator(this.ownerSchema\n            , Types.record\n            , this.name\n            , Math.random().toString()\n            , this._columns\n            , v => ({ ...v })\n            , { forceNotConstant: true });\n    }\n\n    stats(t: _Transaction): Stats | null {\n        return this.base.stats(t);\n    }\n\n    enumerate(t: _Transaction): Iterable<T> {\n        return this.base.enumerate(t);\n    }\n\n    hasItem(value: T, t: _Transaction): boolean {\n        return this.base.hasItem(value, t);\n    }\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil {\n        const col = this._getColumn(column);\n        if (col) {\n            return col;\n        }\n\n        if (asSingleName(column) === this.name) {\n            return this.asRecord;\n        }\n\n        if (nullIfNotFound) {\n            return null;\n        }\n        throw new ColumnNotFound(colToStr(column));\n    }\n\n    private _getColumn(column: string | ExprRef): IValue | nil {\n        if (typeof column !== 'string'\n            && column.table) {\n            if (!column.table.schema\n                && column.table.name !== this.name) {\n                return null;\n            }\n            column = column.name;\n        }\n        const got = this.base.getColumn(column, true);\n        if (!got) {\n            return got;\n        }\n        this.init();\n        const ret = this.oldToThis.get(got);\n        if (!ret) {\n            throw new Error('Corrupted alias');\n        }\n        return ret;\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        // no need to explain an alias... it does nothing.\n        return this.base.explain(e);\n        // return {\n        //     id: e.idFor(this),\n        //     type: 'alias',\n        //     alias: this.as,\n        //     of: this.base.explain(e),\n        // };\n    }\n\n    getIndex(...forValue: IValue[]) {\n        return this.base.getIndex(...forValue.map(v => this.thisToOld.get(v) ?? v));\n    }\n\n}","\nimport { QueryError } from './interfaces';\nimport LRUCache from 'lru-cache';\nimport hash from 'object-hash';\nimport { Expr, parse, Statement } from 'pgsql-ast-parser';\n\n\nconst astCache: LRUCache<any, any> = new LRUCache({\n    max: 1000,\n});\n\nlet locationTracking = false;\nexport function enableStatementLocationTracking() {\n    locationTracking = true;\n    astCache.reset();\n}\n\n\n/** Parse an AST from SQL */\nexport function parseSql(sql: string): Statement[];\nexport function parseSql(sql: string, entry: 'expr'): Expr;\nexport function parseSql(sql: string, entry?: string): any {\n    // when 'entry' is not specified, lets cache parsings\n    // => better perf on repetitive requests\n    const key = !entry && hash(sql);\n    if (!entry) {\n        const cached = astCache.get(key);\n        if (cached) {\n            return cached;\n        }\n    }\n\n    try {\n\n        let ret = parse(sql, {\n            entry,\n            locationTracking,\n        });\n\n        // cache result\n        if (!entry) {\n            astCache.set(key, ret);\n        }\n        return ret;\n\n    } catch (e) {\n        if (typeof e?.message !== 'string' || !/Syntax error/.test(e.message)) {\n            throw e;\n        }\n\n\n        // throw a nice parsing error.\n        throw new QueryError(` Your query failed to parse.\nThis is most likely due to a SQL syntax error. However, you might also have hit a bug, or an unimplemented feature of pg-mem.\nIf this is the case, please file an issue at https://github.com/oguimbal/pg-mem along with a query that reproduces this syntax error.\n\n Failed query:\n\n    ${sql}\n\n ${e.message}`);\n    }\n\n}\n","import { _IIndex, IValue, _ITable, _IDb, _Transaction, _Explainer, _IndexExplanation, IndexOp, IndexKey, Stats } from '../interfaces-private';\nimport { PermissionDeniedError, NotSupported } from '../interfaces';\n\nexport class TableIndex implements _IIndex {\n    readonly expressions: IValue<any>[];\n\n    get hash(): string {\n        throw new Error('not implemented');\n    }\n    explain(e: _Explainer): _IndexExplanation {\n        throw new Error('not implemented');\n    }\n\n    stats(t: _Transaction, key?: IndexKey): Stats | null {\n        return null;\n    }\n\n    iterateKeys() {\n        return null;\n    }\n\n    constructor(readonly onTable: _ITable & { itemsByTable(table: string, t: _Transaction): Iterable<any>; ownSymbol: any }, private col: IValue) {\n        this.expressions = [col];\n    }\n\n    get indexName(): string {\n        return 'index_table_name_name';\n    }\n\n    entropy(op: IndexOp): number {\n        return this.onTable.db.listSchemas()\n            .reduce((tot, s) => tot + s.tablesCount(op.t) * 10 * 3, 0);\n    }\n\n\n    add(raw: any): void {\n        throw new PermissionDeniedError('tables');\n    }\n\n    eqFirst([key]: any, t: _Transaction) {\n        for (const its of this.onTable.itemsByTable(key, t)) {\n            return its;\n        }\n    }\n    *eq([rawKey]: any, t: _Transaction): Iterable<any> {\n        for (const its of this.onTable.itemsByTable(rawKey, t)) {\n            yield its;\n        }\n    }\n\n    *nin(keys: any[][], t: _Transaction) {\n        const raws = keys.map(x => x[0]) as any[];\n        for (const i of this.onTable.selection.enumerate(t)) {\n            if (raws.includes(i.table_name)) {\n                continue;\n            }\n            yield i;\n        }\n    }\n\n    *neq([rawKey]: any, t: _Transaction) {\n        for (const i of this.onTable.selection.enumerate(t)) {\n            if (i.table_name !== rawKey) {\n                yield i;\n            }\n        }\n    }\n    *gt(rawKey: any, t: _Transaction): Iterable<any> {\n        for (const i of this.onTable.selection.enumerate(t)) {\n            if (i.table_name > rawKey) {\n                yield i;\n            }\n        }\n    }\n    *lt(rawKey: any, t: _Transaction): Iterable<any> {\n        for (const i of this.onTable.selection.enumerate(t)) {\n            if (i.table_name < rawKey) {\n                yield i;\n            }\n        }\n    }\n    *ge(rawKey: any, t: _Transaction): Iterable<any> {\n        for (const i of this.onTable.selection.enumerate(t)) {\n            if (i.table_name >= rawKey) {\n                yield i;\n            }\n        }\n    }\n    *le(rawKey: any, t: _Transaction): Iterable<any> {\n        for (const i of this.onTable.selection.enumerate(t)) {\n            if (i.table_name <= rawKey) {\n                yield i;\n            }\n        }\n    }\n\n\n    enumerate(op: IndexOp): Iterable<any> {\n        switch (op.type) {\n            case 'eq':\n                return this.eq(op.key, op.t);\n            case 'neq':\n                return this.neq(op.key, op.t);\n            case 'ge':\n                return this.ge(op.key, op.t);\n            case 'le':\n                return this.le(op.key, op.t);\n            case 'gt':\n                return this.gt(op.key, op.t);\n            case 'lt':\n                return this.lt(op.key, op.t);\n            case 'outside':\n                return this.outside(op.lo, op.hi, op.t);\n            case 'inside':\n                return this.inside(op.lo, op.hi, op.t);\n            case 'nin':\n                return this.nin(op.keys, op.t);\n            default:\n                throw NotSupported.never(op['type']);\n        }\n    }\n\n    *outside(lo: IndexKey, hi: IndexKey, t: _Transaction): Iterable<any> {\n        yield* this.lt(lo, t);\n        yield* this.gt(hi, t);\n    }\n\n    *inside(lo: IndexKey, hi: IndexKey, t: _Transaction): Iterable<any> {\n        throw new Error('Not implemented');\n    }\n}","// stolen from https://github.com/segmentio/pg-escape/blob/master/index.js\n\nexport function literal(val: any) {\n    if (null == val) return 'NULL';\n    if (Array.isArray(val)) {\n        var vals: any[] = val.map(literal)\n        return \"(\" + vals.join(\", \") + \")\"\n    }\n    var backslash = ~val.indexOf('\\\\');\n    var prefix = backslash ? 'E' : '';\n    val = val.replace(/'/g, \"''\");\n    val = val.replace(/\\\\/g, '\\\\\\\\');\n    return prefix + \"'\" + val + \"'\";\n};\n","import { IValue, _ISelection, _Transaction, _Explainer, _SelectExplanation, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { Types } from '../datatypes';\n\nexport class SeqScanFilter<T = any> extends FilterBase<T> {\n\n    get index() {\n        return null;\n    }\n\n    entropy(t: _Transaction) {\n        // boost source entropy (in case an index has the same items count)\n        return this.selection.entropy(t) * 1.5;\n    }\n\n    hasItem(raw: T, t: _Transaction): boolean {\n        return !!this.getter.get(raw, t);\n    }\n\n    constructor(private selection: _ISelection<T>, private getter: IValue<T>) {\n        super(selection);\n        this.getter = getter.convert(Types.bool);\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        for (const raw of this.selection.enumerate(t)) {\n            const cond = this.getter.get(raw, t);\n            if (cond) {\n                yield raw;\n            }\n        }\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'seqFilter',\n            filtered: this.selection.explain(e),\n        };\n    }\n}","export { newDb } from './db';\nexport { enableStatementLocationTracking } from './parse-cache';\nexport * from './interfaces';\n","import { Schema, IMemoryDb, ISchema, TableEvent, GlobalEvent, QueryError, IBackup, MemoryDbOptions, ISubscription, LanguageCompiler } from './interfaces';\nimport { _IDb, _ISelection, _ITable, _Transaction, _ISchema, _FunctionDefinition, GLOBAL_VARS } from './interfaces-private';\nimport { DbSchema } from './schema';\nimport { initialize } from './transforms/transform-base';\nimport { buildSelection } from './transforms/selection';\nimport { buildAlias } from './transforms/alias';\nimport { buildFilter } from './transforms/build-filter';\nimport { Adapters } from './adapters';\nimport { Transaction } from './transaction';\nimport { buildGroupBy } from './transforms/aggregation';\nimport { buildLimit } from './transforms/limit';\nimport { buildUnion } from './transforms/union';\nimport { buildDistinct } from './transforms/distinct';\nimport { buildOrderBy } from './transforms/order-by';\nimport { setupPgCatalog } from './schema/pg-catalog';\nimport { setupInformationSchema } from './schema/information-schema';\nimport { QName } from 'pgsql-ast-parser';\nimport { asSingleQName } from './utils';\n\nexport function newDb(opts?: MemoryDbOptions): IMemoryDb {\n    initialize({\n        buildSelection,\n        buildAlias,\n        buildFilter,\n        buildGroupBy,\n        buildLimit,\n        buildUnion,\n        buildOrderBy,\n        buildDistinct,\n    });\n    // root transaction\n    const root = Transaction.root();\n    const globals = root.getMap(GLOBAL_VARS)\n        .set('server_version', '12.2 (pg-mem)');\n    root.set(GLOBAL_VARS, globals);\n\n    // create db\n    return new MemoryDb(root, undefined, opts ?? {});\n}\n\nclass MemoryDb implements _IDb {\n\n    private handlers = new Map<TableEvent | GlobalEvent, Set<(...args: any[]) => any>>();\n    private schemas = new Map<string, _ISchema>();\n\n    schemaVersion = 1;\n\n    readonly adapters: Adapters = new Adapters(this);\n    private extensions: { [name: string]: (schema: ISchema) => void } = {};\n    private languages: { [name: string]: LanguageCompiler } = {};\n    readonly searchPath = ['pg_catalog', 'public'];\n\n    get public() {\n        return this.getSchema(null)\n    }\n\n    onSchemaChange() {\n        this.schemaVersion++;\n        this.raiseGlobal('schema-change', this);\n    }\n\n    constructor(public data: Transaction, schemas?: Map<string, _ISchema>, readonly options: MemoryDbOptions = {}) {\n        if (!schemas) {\n            this.createSchema('public');\n        } else {\n            this.schemas = schemas;\n        }\n        setupPgCatalog(this);\n        setupInformationSchema(this);\n    }\n\n    backup(): IBackup {\n        return new Backup(this);\n    }\n\n    registerExtension(name: string, install: (schema: ISchema) => void): this {\n        this.extensions[name] = install;\n        return this;\n    }\n\n    registerLanguage(languageName: string, compiler: LanguageCompiler): this {\n        this.languages[languageName.toLowerCase()] = compiler;\n        return this;\n    }\n\n    getLanguage(name: string): LanguageCompiler {\n        const ret = this.languages[name.toLowerCase()];\n        if (!ret) {\n            throw new QueryError(`Unkonwn language \"${name}\". If you plan to use a script language, you must declare it to pg-mem via \".registerLanguage()\"`);\n        }\n        return ret;\n    }\n\n\n    getExtension(name: string): (schema: ISchema) => void {\n        const ret = this.extensions[name];\n        if (!ret) {\n            throw new Error('Extension does not exist: ' + name);\n        }\n        return ret;\n    }\n\n\n    createSchema(name: string): DbSchema {\n        if (this.schemas.has(name)) {\n            throw new Error('Schema exists: ' + name);\n        }\n        this.onSchemaChange();\n        const ret = new DbSchema(name, this);\n        this.schemas.set(name, ret);\n        return ret;\n    }\n\n    getTable(name: string): _ITable;\n    getTable(name: string, nullIfNotExists?: boolean): _ITable | null {\n        return this.public.getTable(name, nullIfNotExists);\n    }\n\n    *getFunctions(name: string | QName, arrity: number): Iterable<_FunctionDefinition> {\n        const asSingle = asSingleQName(name);\n        if (asSingle) {\n            for (const sp of this.searchPath) {\n                yield* this.getSchema(sp).getFunctions(name, arrity, true);\n            }\n        } else {\n            const q = name as QName;\n            yield* this.getSchema(q.schema!).getFunctions(q.name, arrity, true);\n        }\n    }\n\n\n    on(event: GlobalEvent | TableEvent, handler: (...args: any[]) => any): ISubscription {\n        let lst = this.handlers.get(event);\n        if (!lst) {\n            this.handlers.set(event, lst = new Set());\n        }\n        lst.add(handler);\n        return {\n            unsubscribe: () => lst?.delete(handler),\n        };\n    }\n\n    raiseTable(table: string, event: TableEvent): void {\n        const got = this.handlers.get(event);\n        for (const h of got ?? []) {\n            h(table);\n        }\n    }\n\n    raiseGlobal(event: GlobalEvent, ...data: any[]): void {\n        const got = this.handlers.get(event);\n        for (const h of got ?? []) {\n            h(...data);\n        }\n    }\n\n\n    getSchema(db?: string | null, nullIfNotFound?: false): _ISchema;\n    getSchema(db: string, nullIfNotFound: true): _ISchema | null;\n    getSchema(db?: string | null, nullIfNotFound?: boolean): _ISchema | null {\n        db = db ?? 'public';\n        const got = this.schemas.get(db);\n        if (!got) {\n            if (nullIfNotFound) {\n                return null;\n            }\n            throw new QueryError('schema not found: ' + db);\n        }\n        return got;\n    }\n\n    listSchemas() {\n        return [...this.schemas.values()];\n    }\n\n}\n\nclass Backup implements IBackup {\n    private readonly data: Transaction;\n    private readonly schemaVersion: number;\n    constructor(private db: MemoryDb) {\n        this.data = db.data.clone();\n        this.schemaVersion = db.schemaVersion;\n    }\n\n    restore() {\n        if (this.schemaVersion !== this.db.schemaVersion) {\n            throw new Error('You cannot restore this backup: schema has been changed since this backup has been created => prefer .clone() in this kind of cases.');\n        }\n        this.db.data = this.data.clone();\n    }\n}","import { ISchema, QueryError, DataType, IType, NotSupported, RelationNotFound, Schema, QueryResult, SchemaField, nil, FunctionDefinition, PermissionDeniedError, TypeNotFound, ArgDefDetails, IEquivalentType, QueryInterceptor, ISubscription } from './interfaces';\nimport { _IDb, _ISelection, CreateIndexColDef, _ISchema, _Transaction, _ITable, _SelectExplanation, _Explainer, IValue, _IIndex, OnConflictHandler, _FunctionDefinition, _IType, _IRelation, QueryObjOpts, _ISequence, asSeq, asTable, _INamedIndex, asIndex, RegClass, Reg, TypeQuery, asType, ChangeOpts, GLOBAL_VARS, _ArgDefDetails, BeingCreated, asView, asSelectable } from './interfaces-private';\nimport { asSingleQName, ignore, isType, Optional, parseRegClass, pushContext, randomString, schemaOf, suggestColumnName, watchUse } from './utils';\nimport { buildValue } from './expression-builder';\nimport { ArrayType, Types, typeSynonyms } from './datatypes';\nimport { JoinSelection } from './transforms/join';\nimport { Statement, CreateTableStatement, SelectStatement, InsertStatement, CreateIndexStatement, UpdateStatement, AlterTableStatement, DeleteStatement, SetStatement, CreateExtensionStatement, CreateSequenceStatement, AlterSequenceStatement, QName, QNameAliased, astMapper, DropIndexStatement, DropTableStatement, DropSequenceStatement, toSql, TruncateTableStatement, CreateSequenceOptions, DataTypeDef, ArrayDataTypeDef, BasicDataTypeDef, Expr, WithStatement, WithStatementBinding, SelectFromUnion, ShowStatement, CreateViewStatement, CreateMaterializedViewStatement, CreateFunctionStatement, DoStatement, ColumnConstraint, CreateColumnsLikeTableOpt, NodeLocation, SelectedColumn } from 'pgsql-ast-parser';\nimport { MemoryTable } from './table';\nimport { buildSelection } from './transforms/selection';\nimport { ArrayFilter } from './transforms/array-filter';\nimport { parseSql } from './parse-cache';\nimport { Sequence } from './sequence';\nimport { IMigrate } from './migrate/migrate-interfaces';\nimport { migrate } from './migrate/migrate';\nimport { CustomEnumType } from './datatypes/t-custom-enum';\nimport { regGen } from './datatypes/datatype-base';\nimport { ValuesTable } from './schema/values-table';\nimport { cleanResults } from './clean-results';\nimport { EquivalentType } from './datatypes/t-equivalent';\nimport { View } from './view';\n\n\ntype WithableResult = number | _ISelection;\n\nexport class DbSchema implements _ISchema, ISchema {\n\n    readonly dualTable: _ITable;\n    private relsByNameCas = new Map<string, _IRelation>();\n    private relsByCls = new Map<number, _IRelation>();\n    private relsByTyp = new Map<number, _IRelation>();\n    private tempBindings = new Map<string, _ISelection | 'no returning'>();\n    private _tables = new Set<_ITable>();\n\n    private lastSelect?: _ISelection<any>;\n    private fns = new Map<string, _FunctionDefinition[]>();\n    private installedExtensions = new Set<string>();\n    private readonly: any;\n    private interceptors = new Set<{ readonly intercept: QueryInterceptor }>();\n\n    constructor(readonly name: string, readonly db: _IDb) {\n        this.dualTable = new MemoryTable(this, this.db.data, { fields: [], name: 'dual' }).register();\n        this.dualTable.insert({});\n        this.dualTable.setReadonly();\n        this._reg_unregister(this.dualTable);\n    }\n\n    setReadonly() {\n        this.readonly = true;\n        return this;\n    }\n\n\n    none(query: string): void {\n        this.query(query);\n    }\n\n    one(query: string): any {\n        const [result] = this.many(query);\n        return result;\n    }\n\n    many(query: string): any[] {\n        return this.query(query).rows;\n    }\n\n\n    query(text: string): QueryResult {\n        // intercept ?\n        for (const { intercept } of this.interceptors) {\n            const ret = intercept(text);\n            if (ret) {\n                return {\n                    command: text,\n                    fields: [],\n                    location: { start: 0, end: text.length },\n                    rowCount: 0,\n                    rows: ret,\n                };\n            }\n        }\n\n        // execute.\n        let last: QueryResult | undefined;\n        for (const r of this.queries(text)) {\n            last = r;\n        }\n        return last ?? {\n            command: text,\n            fields: [],\n            location: { start: 0, end: text.length },\n            rowCount: 0,\n            rows: [],\n        };\n    }\n\n    private parse(query: string) {\n        return parseSql(query);\n    }\n\n    *queries(query: string): Iterable<QueryResult> {\n        query = query + ';';\n        // console.log(query);\n        // console.log('\\n');\n        try {\n            let parsed = this.parse(query);\n            if (!Array.isArray(parsed)) {\n                parsed = [parsed];\n            }\n            let t = this.db.data.fork();\n            for (const _p of parsed) {\n                if (!_p) {\n                    continue;\n                }\n\n                const { transaction, last } = pushContext({\n                    transaction: t,\n                    schema: this\n                }, () => this._execOne(t, _p, parsed.length === 1 ? query : undefined));\n                yield last;\n                t = transaction;\n            }\n\n            // implicit final commit\n            t.fullCommit();\n            this.db.raiseGlobal('query', query);\n        } catch (e) {\n            this.db.raiseGlobal('query-failed', query);\n            throw e;\n        }\n    }\n\n\n    private _execOne(t: _Transaction, _p: Statement, pAsSql?: string) {\n        try {\n            // query execution\n            let last: QueryResult | undefined = undefined;\n            const { checked: p, check } = this.db.options.noAstCoverageCheck\n                ? { checked: _p, check: null }\n                : watchUse(_p);\n\n            switch (p.type) {\n                case 'start transaction':\n                case 'begin':\n                    ignore(p);\n                    t = t.fork();\n                    break;\n                case 'commit':\n                    t = t.commit();\n                    if (!t.isChild) {\n                        t = t.fork(); // recreate an implicit transaction\n                    }\n                    break;\n                case 'rollback':\n                    t = t.rollback();\n                    break;\n                case 'with':\n                    last = this.executeWith(t, p);\n                    break;\n                case 'select':\n                case 'delete':\n                case 'update':\n                case 'insert':\n                case 'union':\n                case 'union all':\n                    last = this.executeWithable(t, p);\n                    break;\n                case 'truncate table':\n                    last = this.executeTruncateTable(t, p);\n                    break;\n                case 'create table':\n                    t = t.fullCommit();\n                    last = this.executeCreateTable(t, p);\n                    t = t.fork();\n                    break;\n                case 'create index':\n                    t = t.fullCommit();\n                    last = this.executeCreateIndex(t, p);\n                    t = t.fork();\n                    break;\n                case 'alter table':\n                    t = t.fullCommit();\n                    last = this.executeAlterRequest(t, p);\n                    t = t.fork();\n                    break;\n                case 'create extension':\n                    this.executeCreateExtension(p);\n                    break;\n                case 'create sequence':\n                    t = t.fullCommit();\n                    last = this.executeCreateSequence(t, p);\n                    t = t.fork();\n                    break;\n                case 'alter sequence':\n                    t = t.fullCommit();\n                    last = this.executeAlterSequence(t, p);\n                    t = t.fork();\n                    break;\n                case 'drop index':\n                    t = t.fullCommit();\n                    last = this.executeDropIndex(t, p);\n                    t = t.fork();\n                    break;\n                case 'drop table':\n                    t = t.fullCommit();\n                    last = this.executeDropTable(t, p);\n                    t = t.fork();\n                    break;\n                case 'drop sequence':\n                    t = t.fullCommit();\n                    last = this.executeDropSequence(t, p);\n                    t = t.fork();\n                    break;\n                case 'show':\n                    last = this.executeShow(t, p);\n                    break;\n                case 'set':\n                case 'set timezone':\n                    if (p.type === 'set' && p.set.type === 'value') {\n                        t.set(GLOBAL_VARS, t.getMap(GLOBAL_VARS)\n                            .set(p.variable.name, p.set.value));\n                        break;\n                    }\n                    // todo handle set statements timezone ?\n                    // They are just ignored as of today (in order to handle pg_dump exports)\n                    ignore(p);\n                    break;\n                case 'create enum':\n                    t = t.fullCommit();\n                    (p.name.schema ? this.db.getSchema(p.name.schema) : this)\n                        .registerEnum(p.name.name, p.values.map(x => x.value));\n                    t = t.fork();\n                    break;\n                case 'tablespace':\n                    throw new NotSupported('\"TABLESPACE\" statement');\n                case 'prepare':\n                    throw new NotSupported('\"PREPARE\" statement');\n                case 'create view':\n                    t = t.fullCommit();\n                    last = this.executeCreateView(t, p);\n                    t = t.fork();\n                    break;\n                case 'create materialized view':\n                    t = t.fullCommit();\n                    last = this.executeCreateMaterializedView(t, p);\n                    t = t.fork();\n                    break;\n                case 'create schema':\n                    t = t.fullCommit();\n                    const sch = this.db.getSchema(p.name.name, true);\n                    if (!p.ifNotExists && sch) {\n                        throw new QueryError('schema already exists! ' + p.name);\n                    }\n                    if (sch) {\n                        ignore(p);\n                        break;\n                    }\n                    this.db.createSchema(p.name.name);\n                    t = t.fork();\n                    break;\n                case 'create function':\n                    last = this.createFunction(p);\n                    break;\n                case 'do':\n                    last = this.do(p);\n                    break;\n                case 'comment':\n                case 'raise':\n                    ignore(p);\n                    break;\n                default:\n                    throw NotSupported.never(p, 'statement type');\n            }\n            last = last ?? this.simple(p.type.toUpperCase(), p);\n            if (!last.ignored && check) {\n                const ret = check();\n                if (ret) {\n                    throw new NotSupported(ret);\n                }\n            }\n            return { last, transaction: t };\n        } catch (e) {\n\n            if (!this.db.options.noErrorDiagnostic && (e instanceof Error) || e instanceof NotSupported) {\n\n                // compute SQL\n                const msgs = [e.message];\n\n\n                if (e instanceof QueryError) {\n                    msgs.push(` This seems to be an execution error, which means that your request syntax seems okay,\nbut the resulting statement cannot be executed  Probably not a pg-mem error.`);\n                } else if (e instanceof NotSupported) {\n                    msgs.push(` pg-mem is work-in-progress, and it would seem that you've hit one of its limits.`);\n                } else {\n                    msgs.push(' This is a nasty error, which was unexpected by pg-mem. Also known \"a bug\"  Please file an issue !')\n                }\n\n                if (!this.db.options.noErrorDiagnostic) {\n                    if (pAsSql) {\n                        msgs.push(`* Failed SQL statement: ${pAsSql}`);\n                    } else {\n                        try {\n                            msgs.push(`* Reconsituted failed SQL statement: ${toSql.statement(_p)}`);\n                        } catch (f) {\n                            msgs.push(`* <Failed to reconsitute SQL - ${f?.message}>`);\n                        }\n                    }\n                }\n                msgs.push(' You can file an issue at https://github.com/oguimbal/pg-mem along with a way to reproduce this error (if you can), and  the stacktrace:')\n                e.message = msgs.join('\\n\\n') + '\\n\\n';\n            }\n            e.location = this.locOf(_p);\n            throw e;\n        }\n    }\n\n    private do(st: DoStatement) {\n        const lang = this.db.getLanguage(st.language?.name ?? 'plpgsql');\n        const compiled = lang({\n            args: [],\n            code: st.code,\n        });\n        // TODO ACCESS OUTER TRANSACTION WITHIN THIS CALL\n        compiled();\n        return this.simple('DO', st);\n    }\n\n    private createFunction(fn: CreateFunctionStatement) {\n        if (!fn.language) {\n            throw new QueryError('Unspecified function language');\n        }\n\n        const lang = this.db.getLanguage(fn.language.name);\n\n        // determine arg types\n        const args = fn.arguments.map<_ArgDefDetails>(a => ({\n            name: a.name?.name,\n            type: this.getType(a.type),\n            default: a.default && buildValue(this.dualTable.selection, a.default),\n            mode: a.mode,\n        }));\n\n        // determine return type\n        let returns: IType | null = null;\n        if (fn.returns) {\n            switch (fn.returns.kind) {\n                case 'table':\n                    // Todo: we're losing the typing here :(\n                    returns = Types.record.asArray();\n                    ignore(fn.returns.columns);\n                    break;\n                case 'array':\n                case null:\n                case undefined:\n                    returns = this.getType(fn.returns);\n                    break;\n                default:\n                    throw NotSupported.never(fn.returns);\n            }\n        }\n\n        let argsVariadic: _IType | nil;\n        const variad = args.filter(x => x.mode === 'variadic');\n        if (variad.length > 1) {\n            throw new QueryError(`Expected only one \"VARIADIC\" argument`);\n        } else if (variad.length) {\n            argsVariadic = variad[0].type;\n        }\n\n        // compile & register the associated function\n        const compiled = lang({\n            args,\n            code: fn.code,\n            returns,\n            functioName: fn.name.name,\n        });\n        this.registerFunction({\n            name: fn.name.name,\n            returns,\n            implementation: compiled,\n            args: args.filter(x => x.mode !== 'variadic'),\n            argsVariadic,\n            impure: fn.purity !== 'immutable',\n            allowNullArguments: fn.onNullInput === 'call',\n        }, fn.orReplace);\n        return this.simple('CREATE', fn);\n    }\n\n\n    private executeShow(t: _Transaction, p: ShowStatement): QueryResult {\n        const got = t.getMap(GLOBAL_VARS);\n        if (!got.has(p.variable.name)) {\n            throw new QueryError(`unrecognized configuration parameter \"${p.variable.name}\"`);\n        }\n        return {\n            rows: [{ [p.variable.name]: got.get(p.variable.name) }],\n            rowCount: 1,\n            command: 'SHOW',\n            fields: [],\n            location: this.locOf(p),\n        };\n    }\n\n    private executeWith(t: _Transaction, p: WithStatement): QueryResult {\n\n        try {\n            // ugly hack to ensure that the insert/select behaviour of postgres is OK\n            // see unit test \"only inserts once with statement is executed\" for an example.\n            const selTrans = p.in.type === 'select' || p.in.type === 'union' ? t.fork() : t;\n\n            // declare temp bindings\n            for (const { alias, statement } of p.bind) {\n                const prepared = this.prepareWithable(t, statement);\n                if (this.tempBindings.has(alias.name)) {\n                    throw new QueryError(` WITH query name \"${alias.name}\" specified more than once`);\n                }\n                this.tempBindings.set(alias.name, typeof prepared === 'number' ? 'no returning' : prepared);\n            }\n            // execute statement\n            return this.executeWithable(selTrans, p.in);\n        } finally {\n            // remove temp bindings\n            for (const { alias } of p.bind) {\n                this.tempBindings.delete(alias.name);\n            }\n        }\n    }\n\n    private buildWith(p: WithStatement): _ISelection {\n        throw new NotSupported('\"WITH\" statements');\n    }\n\n\n    private prepareWithable(t: _Transaction, p: WithStatementBinding): WithableResult {\n        switch (p.type) {\n            case 'select':\n            case 'union':\n            case 'union all':\n            case 'with':\n                return this.lastSelect = this.buildSelect(p);\n            case 'delete':\n                return this.executeDelete(t, p);\n            case 'update':\n                return this.executeUpdate(t, p);\n            case 'insert':\n                return this.executeInsert(t, p);\n            default:\n                throw NotSupported.never(p);\n        }\n    }\n\n    private executeWithable(t: _Transaction, p: WithStatementBinding) {\n        let last = this.prepareWithable(t, p);\n\n        const rows = typeof last === 'number'\n            ? []\n            : cleanResults([...last.enumerate(t)]);\n        return {\n            rows,\n            rowCount: typeof last === 'number' ? last : rows.length,\n            command: p.type.toUpperCase(),\n            fields: [],\n            location: this.locOf(p),\n        };\n    }\n\n\n    registerEnum(name: string, values: string[]) {\n        new CustomEnumType(this, name, values).install();\n    }\n\n    private checkExistence<T>(command: T, name: QName, ifNotExists: boolean | undefined, act: () => T | null | void): T {\n        // check if object exists\n        const exists = this.getObject(name, {\n            skipSearch: true,\n            nullIfNotFound: true\n        });\n        if (exists) {\n            if (ifNotExists) {\n                return {\n                    ...command,\n                    ignored: true,\n                };\n            }\n            throw new QueryError(`relation \"${name.name}\" already exists`);\n        }\n\n        // else, perform operation\n        return act() || command;\n    }\n\n    executeCreateExtension(p: CreateExtensionStatement) {\n        const ext = this.db.getExtension(p.extension.name);\n        const schema = p.schema\n            ? this.db.getSchema(p.schema.name)\n            : this;\n        this.db.raiseGlobal('create-extension', p.extension, schema, p.version, p.from);\n        const ne = p.ifNotExists; // evaluate outside\n        if (this.installedExtensions.has(p.extension.name)) {\n            if (ne) {\n                return;\n            }\n            throw new QueryError('Extension already created !');\n        }\n\n        ext(schema);\n        this.installedExtensions.add(p.extension.name);\n    }\n\n    executeCreateView(t: _Transaction, p: CreateViewStatement): QueryResult {\n\n        const nop = this.simple('CREATE', p);\n        const onSchema = p.name.schema && p.name.schema !== this.name\n            ? this.db.getSchema(p.name.schema)\n            : this;\n\n        // check existence\n        const existing = asView(this.getObject(p.name, { nullIfNotFound: true }));\n        if (p.orReplace && existing) {\n            existing.drop(t);\n        }\n\n        let view = this.buildSelect(p.query);\n\n        // optional column mapping\n        if (p.columnNames?.length) {\n            if (p.columnNames.length > view.columns.length) {\n                throw new QueryError('CREATE VIEW specifies more column names than columns', '42601');\n            }\n            view = view.select(view.columns.map<string | SelectedColumn>((x, i) => {\n                const alias = p.columnNames?.[i]?.name;\n                if (!alias) {\n                    return x.id!;\n                }\n                return {\n                    expr: { type: 'ref', name: x.id! },\n                    alias: { name: alias },\n                }\n            }));\n        }\n\n        // view creation\n        new View(onSchema, p.name.name, view)\n            .register();\n\n        return nop;\n\n    }\n\n    executeCreateMaterializedView(t: _Transaction, p: CreateMaterializedViewStatement): QueryResult {\n\n        const nop = this.simple('CREATE', p);\n        const onSchema = p.name.schema && p.name.schema !== this.name\n            ? this.db.getSchema(p.name.schema)\n            : this;\n\n        // check existence\n        const existing = asView(this.getObject(p.name, { nullIfNotFound: true }));\n        if (p.ifNotExists && existing) {\n            nop.ignored = true;\n            return nop;\n        }\n\n        const view = this.buildSelect(p.query);\n\n        // hack: materialized views are implemented as simple views :/  (todo ?)\n        new View(onSchema, p.name.name, view)\n            .register();\n\n        return nop;\n    }\n\n\n    private locOf(p: Statement): NodeLocation {\n        return p._location ?? { start: 0, end: 0 };\n    }\n\n\n    private simpleTypes: { [key: string]: _IType } = {};\n    private sizeableTypes: {\n        [key: string]: {\n            ctor: (...sz: number[]) => _IType;\n            regs: Map<number | string | undefined, _IType>;\n        };\n    } = {};\n\n\n    parseType(native: string): _IType {\n        if (/\\[\\]$/.test(native)) {\n            const inner = this.parseType(native.substr(0, native.length - 2));\n            return inner.asArray();\n        }\n        return this.getType({ name: native });\n    }\n\n\n    getOwnType(t: DataTypeDef): _IType | null {\n        if (t.kind === 'array') {\n            const $of = this.getOwnType(t.arrayOf);\n            if (!$of) {\n                return null;\n            }\n            return $of.asArray();\n        }\n        const name = typeSynonyms[t.name] ?? t.name;\n        const sizeable = this.sizeableTypes[name];\n        if (sizeable) {\n            const key = t.config?.length === 1\n                ? t.config[0]\n                : t.config?.join(',') ?? undefined;\n            let ret = sizeable.regs.get(key);\n            if (!ret) {\n                sizeable.regs.set(key, ret = sizeable.ctor(...t.config ?? []));\n            }\n            return ret;\n        }\n\n        return this.simpleTypes[name] ?? null;\n    }\n\n\n    getTypePub(t: DataType | IType): _IType {\n        return this.getType(t as TypeQuery);\n    }\n\n    getType(t: TypeQuery): _IType;\n    getType(_t: TypeQuery, opts?: QueryObjOpts): _IType | null {\n        if (typeof _t === 'number') {\n            const byOid = this.relsByTyp.get(_t);\n            if (byOid) {\n                return asType(byOid);\n            }\n            throw new TypeNotFound(_t);\n        }\n        if (typeof _t === 'string') {\n            return this.getType({ name: _t });\n        }\n        if (isType(_t)) {\n            return _t;\n        }\n        const t = _t;\n        function chk<T>(ret: T): T {\n            if (!ret && !opts?.nullIfNotFound) {\n                throw new TypeNotFound(t);\n            }\n            return ret;\n        }\n        const schema = schemaOf(t);\n        if (schema) {\n            if (schema === this.name) {\n                return chk(this.getOwnType(t));\n            } else {\n                return chk(this.db.getSchema(schema)\n                    .getType(t, opts));\n            }\n        }\n        if (opts?.skipSearch) {\n            return chk(this.getOwnType(t));\n        }\n        for (const sp of this.db.searchPath) {\n            const rel = this.db.getSchema(sp).getOwnType(t);\n            if (rel) {\n                return rel;\n            }\n        }\n        return chk(this.getOwnType(t));\n    }\n\n\n    getObject(p: QName): _IRelation;\n    getObject(p: QName, opts: BeingCreated): _IRelation;\n    getObject(p: QName, opts?: QueryObjOpts): _IRelation | null;\n    getObject(p: QName, opts?: QueryObjOpts): _IRelation | null {\n        function chk(ret: _IRelation | null): _IRelation | null {\n            const bc = opts?.beingCreated;\n            if (!ret && bc && (\n                !p.schema || p.schema === bc.ownerSchema?.name\n            ) && bc.name === p.name) {\n                ret = bc;\n            }\n            if (!ret && !opts?.nullIfNotFound) {\n                throw new RelationNotFound(p.name);\n            }\n            return ret;\n        }\n        if (p.schema) {\n            if (p.schema === this.name) {\n                return chk(this.getOwnObject(p.name));\n            } else {\n                return chk(this.db.getSchema(p.schema)\n                    .getObject(p, opts));\n            }\n        }\n\n        if (opts?.skipSearch) {\n            return chk(this.getOwnObject(p.name));\n        }\n        for (const sp of this.db.searchPath) {\n            const rel = this.db.getSchema(sp).getOwnObject(p.name);\n            if (rel) {\n                return rel;\n            }\n        }\n        return chk(this.getOwnObject(p.name));\n    }\n\n    getOwnObject(name: string): _IRelation | null {\n        return this.relsByNameCas.get(name)\n            ?? null;\n    }\n\n    getObjectByRegOrName(reg: RegClass): _IRelation;\n    getObjectByRegOrName(reg: RegClass, opts?: QueryObjOpts): _IRelation | null;\n    getObjectByRegOrName(_reg: RegClass, opts?: QueryObjOpts): _IRelation | null {\n        const reg = parseRegClass(_reg);\n\n        if (typeof reg === 'number') {\n            return this.getObjectByRegClassId(reg, opts);\n        }\n\n        return this.getObject(reg, opts);\n    }\n\n    getObjectByRegClassId(reg: number): _IRelation;\n    getObjectByRegClassId(reg: number, opts?: QueryObjOpts): _IRelation | null;\n    getObjectByRegClassId(reg: number, opts?: QueryObjOpts) {\n        function chk<T>(ret: T): T {\n            if (!ret && !opts?.nullIfNotFound) {\n                throw new RelationNotFound(reg.toString());\n            }\n            return ret;\n        }\n        if (opts?.skipSearch) {\n            return chk(this.getOwnObjectByRegClassId(reg));\n        }\n        for (const sp of this.db.searchPath) {\n            const rel = this.db.getSchema(sp).getOwnObjectByRegClassId(reg);\n            if (rel) {\n                return rel;\n            }\n        }\n        return chk(this.getOwnObjectByRegClassId(reg));\n    }\n\n    getOwnObjectByRegClassId(reg: number): _IRelation | null {\n        return this.relsByCls.get(reg)\n            ?? null;\n    }\n\n    executeAlterRequest(t: _Transaction, p: AlterTableStatement): QueryResult {\n        const table = asTable(this.getObject(p.table));\n\n        const nop = this.simple('ALTER', p);\n\n        function _ignore() {\n            nop.ignored = true;\n            return nop;\n        }\n        if (!table) {\n            return nop;\n        }\n\n        ignore(p.only);\n        const change = p.change;\n        switch (change.type) {\n            case 'rename':\n                table.rename(change.to.name);\n                return nop;\n            case 'add column': {\n                const col = table.selection.getColumn(change.column.name.name, true);\n                if (col) {\n                    if (change.ifNotExists) {\n                        return _ignore();\n                    } else {\n                        throw new QueryError('Column already exists: ' + col.id);\n                    }\n                }\n                table.addColumn(change.column, t);\n                return nop;\n            }\n            case 'drop column':\n                const col = table.getColumnRef(change.column.name, change.ifExists);\n                if (!col) {\n                    return _ignore();\n                }\n                col.drop(t);\n                return nop;\n            case 'rename column':\n                table.getColumnRef(change.column.name)\n                    .rename(change.to.name, t);\n                return nop;\n            case 'alter column':\n                table.getColumnRef(change.column.name)\n                    .alter(change.alter, t);\n                return nop;\n            case 'rename constraint':\n                throw new NotSupported('rename constraint');\n            case 'add constraint':\n                table.addConstraint(change.constraint, t);\n                return nop;\n            case 'owner':\n                // owner change statements are not supported.\n                // however, in order to support, pg_dump, we're just ignoring them.\n                return _ignore();\n            default:\n                throw NotSupported.never(change, 'alter request');\n\n        }\n    }\n\n    executeCreateIndex(t: _Transaction, p: CreateIndexStatement): QueryResult {\n        const indexName = p.indexName?.name;\n        const onTable = asTable(this.getObject(p.table));\n        if (p.using && p.using.name.toLowerCase() !== 'btree') {\n            if (this.db.options.noIgnoreUnsupportedIndices) {\n                throw new NotSupported('index type: ' + p.using);\n            }\n            ignore(p);\n            return this.simple('CREATE', p);\n        }\n        const columns = p.expressions\n            .map<CreateIndexColDef>(x => {\n                return {\n                    value: buildValue(onTable.selection, x.expression),\n                    nullsLast: x.nulls === 'last', // nulls are first by default\n                    desc: x.order === 'desc',\n                }\n            });\n        onTable\n            .createIndex(t, {\n                columns,\n                indexName,\n                unique: p.unique,\n                ifNotExists: p.ifNotExists,\n            });\n        return this.simple('CREATE', p);\n    }\n\n\n    private simple(op: string, p: Statement): QueryResult {\n        return {\n            command: op,\n            fields: [],\n            rowCount: 0,\n            rows: [],\n            location: this.locOf(p),\n        };\n    }\n\n    executeCreateSequence(t: _Transaction, p: CreateSequenceStatement): QueryResult {\n        const name: QName = p.name;\n        if ((name.schema ?? this.name) !== this.name) {\n            const sch = this.db.getSchema(name.schema) as DbSchema;\n            return sch.executeCreateSequence(t, p);\n        }\n\n        const ret = this.simple('CREATE', p);\n\n        // check existence\n        return this.checkExistence(ret, name, p.ifNotExists, () => {\n            if (p.temp) {\n                throw new NotSupported('temp sequences');\n            }\n            new Sequence(name.name, this)\n                .alter(t, p.options);\n            this.db.onSchemaChange();\n        });\n    }\n\n    createSequence(t: _Transaction, opts: CreateSequenceOptions | nil, _name: QName | nil): _ISequence {\n        _name = _name ?? {\n            name: randomString(),\n        };\n        if ((_name.schema ?? this.name) !== this.name) {\n            return this.db.getSchema(_name.schema)\n                .createSequence(t, opts, _name);\n        }\n        const name = _name.name;\n\n        let ret: _ISequence;\n        this.checkExistence(null, _name, false, () => {\n            ret = new Sequence(name, this)\n                .alter(t, opts);\n            this.db.onSchemaChange();\n        });\n        return ret!;\n    }\n\n    executeAlterSequence(t: _Transaction, p: AlterSequenceStatement): QueryResult {\n\n        const nop = this.simple('ALTER', p);\n\n        const got = asSeq(this.getObject(p.name, {\n            nullIfNotFound: p.ifExists,\n        }));\n\n        if (!got) {\n            nop.ignored = true;\n            return nop;\n        }\n\n        got.alter(t, p.change);\n\n        return nop;\n    }\n\n\n    executeDropIndex(t: _Transaction, p: DropIndexStatement): QueryResult {\n\n        const nop = this.simple('DROP', p);\n\n\n        const got = asIndex(this.getObject(p.name, {\n            nullIfNotFound: p.ifExists,\n        }));\n\n        ignore(p.concurrently);\n        if (!got) {\n            nop.ignored = true;\n            return nop;\n        }\n\n        got.onTable.dropIndex(t, got.name);\n        return nop;\n    }\n\n    executeDropTable(t: _Transaction, p: DropTableStatement): QueryResult {\n\n        const nop = this.simple('DROP', p);\n\n        const got = asTable(this.getObject(p.name, {\n            nullIfNotFound: p.ifExists,\n        }));\n\n        if (!got) {\n            nop.ignored = true;\n            return nop;\n        }\n\n        got.drop(t);\n        return nop;\n    }\n\n\n    executeDropSequence(t: _Transaction, p: DropSequenceStatement): QueryResult {\n\n        const nop = this.simple('DROP', p);\n\n        const got = asSeq(this.getObject(p.name, {\n            nullIfNotFound: p.ifExists,\n        }));\n\n        if (!got) {\n            nop.ignored = true;\n            return nop;\n        }\n\n        got.drop(t);\n        return nop;\n    }\n\n\n    executeCreateTable(t: _Transaction, p: CreateTableStatement): QueryResult {\n        const name: QName = p.name;\n        if ((name.schema ?? this.name) !== this.name) {\n            const sch = this.db.getSchema(name.schema) as DbSchema;\n            return sch.executeCreateTable(t, p);\n        }\n        const ret = this.simple('CREATE', p);\n\n        return this.checkExistence(ret, name, p.ifNotExists, () => {\n            let fields: SchemaField[] = [];\n            for (const f of p.columns) {\n                switch (f.kind) {\n                    case 'column':\n                        // TODO: #collation\n                        ignore(f.collate);\n                        const nf = {\n                            ...f,\n                            name: f.name.name,\n                            type: this.getType(f.dataType),\n                            serial: !f.dataType.kind && (f.dataType.name === 'serial' || f.dataType.name === 'bigserial'),\n                        };\n                        delete (nf as Optional<typeof nf>).dataType;\n                        fields.push(nf);\n                        break;\n                    case 'like table':\n                        throw new NotSupported('\"like table\" statement');\n                    default:\n                        throw NotSupported.never(f);\n                }\n            }\n\n            // perform creation\n            this.declareTable({\n                name: name.name,\n                constraints: p.constraints,\n                fields,\n            });\n        });\n    }\n\n    explainLastSelect(): _SelectExplanation | undefined {\n        return this.lastSelect?.explain(new Explainer(this.db.data));\n    }\n    explainSelect(sql: string): _SelectExplanation {\n        let parsed = this.parse(sql);\n        if (parsed.length !== 1) {\n            throw new Error('Expecting a single statement');\n        }\n        if (parsed[0].type !== 'select') {\n            throw new Error('Expecting a select statement');\n        }\n        return this.buildSelect(parsed[0])\n            .explain(new Explainer(this.db.data))\n    }\n\n    private executeDelete(t: _Transaction, p: DeleteStatement): WithableResult {\n        const table = asTable(this.getObject(p.from));\n        const toDelete = table\n            .selection\n            .filter(p.where);\n        const rows = [];\n        for (const item of toDelete.enumerate(t)) {\n            table.delete(t, item);\n            rows.push(item);\n        }\n        cleanResults(rows);\n        return p.returning\n            ? buildSelection(new ArrayFilter(table.selection, rows), p.returning)\n            : rows.length;\n    }\n\n    executeTruncateTable(t: _Transaction, p: TruncateTableStatement): QueryResult {\n        if (p.tables.length !== 1) {\n            throw new NotSupported('Multiple truncations');\n        }\n        const table = asTable(this.getObject(p.tables[0]));\n        table.truncate(t);\n        return this.simple('TRUNCATE', p);\n    }\n\n    private buildUnion(p: SelectFromUnion): _ISelection {\n        const left = this.buildSelect(p.left);\n        const right = this.buildSelect(p.right);\n        const ret = left.union(right);\n        if (p.type === 'union all') {\n            return ret;\n        }\n        return ret.distinct();\n    }\n\n    buildSelect(p: SelectStatement): _ISelection {\n        switch (p.type) {\n            case 'union':\n            case 'union all':\n                return this.buildUnion(p);\n            case 'with':\n                return this.buildWith(p);\n            case 'select':\n                break;\n            default:\n                throw NotSupported.never(p);\n        }\n        const distinct = !p.distinct || p.distinct === 'all'\n            ? null\n            : p.distinct;\n        let sel: _ISelection | undefined = undefined;\n        const aliases = new Set<string>();\n        for (const from of p.from ?? []) {\n            let alias: string;\n            switch (from.type) {\n                case 'table':\n                    alias = from.alias ?? from.name\n                    break;\n                case 'call':\n                    alias = from.alias?.name ?? suggestColumnName(from)!;\n                    break;\n                default:\n                    alias = from.alias?.name;\n                    break;\n            }\n\n            if (!alias) {\n                throw new Error('No alias provided');\n            }\n            if (aliases.has(alias)) {\n                throw new Error(`Table name \"${alias}\" specified more than once`)\n            }\n            // find what to select\n            let newT: _ISelection;\n            switch (from.type) {\n                case 'table':\n                    const temp = !from.schema\n                        && this.tempBindings.get(from.name);\n                    if (temp === 'no returning') {\n                        throw new QueryError(`WITH query \"${from.name}\" does not have a RETURNING clause`);\n                    }\n                    newT = temp || asSelectable(this.getObject(from)).selection;\n                    break;\n                case 'statement':\n                    newT = this.buildSelect(from.statement);\n                    break;\n                case 'values':\n                    newT = new ValuesTable(this, from.alias.name, from.values, from.columnNames?.map(x => x.name) ?? []).selection;\n                    break;\n                case 'call':\n                    const fnName = from.alias?.name ?? from.function?.name;\n                    newT = new ValuesTable(this, fnName, [[from]], [fnName]);\n                    break;\n                default:\n                    throw NotSupported.never(from);\n            }\n\n            // set its alias\n            newT = newT.setAlias(alias);\n\n            if (!sel) {\n                // first table to be selected\n                sel = newT;\n                continue;\n            }\n\n            switch (from.join?.type) {\n                case 'INNER JOIN':\n                    sel = new JoinSelection(this, sel, newT, from.join!, true);\n                    break;\n                case 'LEFT JOIN':\n                    sel = new JoinSelection(this, sel, newT, from.join!, false);\n                    break;\n                case 'RIGHT JOIN':\n                    sel = new JoinSelection(this, newT, sel, from.join!, false);\n                    break;\n                default:\n                    throw new NotSupported('Joint type not supported ' + (from.join?.type ?? '<no join specified>'));\n            }\n        }\n\n        // filter & select\n        sel = sel ?? this.dualTable.selection;\n        sel = sel.filter(p.where);\n\n        if (p.groupBy) {\n            sel = sel.groupBy(p.groupBy, p.columns!);\n            sel = sel.orderBy(p.orderBy);\n\n            // when grouping by, distinct is handled after selection\n            //  => can distinct on key, or selected\n            if (Array.isArray(p.distinct)) {\n                sel = sel.distinct(p.distinct);\n            }\n        } else {\n            sel = sel.orderBy(p.orderBy);\n\n            // when not grouping by, distinct is handled before\n            // selection => can distinct on non selected values\n            if (Array.isArray(p.distinct)) {\n                sel = sel.distinct(p.distinct);\n            }\n\n            sel = sel.select(p.columns!);\n        }\n\n        // handle 'distinct' on result set\n        if (distinct === 'distinct') {\n            sel = sel.distinct();\n        }\n\n        if (p.limit) {\n            sel = sel.limit(p.limit);\n        }\n        return sel;\n    }\n\n    private executeUpdate(t: _Transaction, p: UpdateStatement): WithableResult {\n        const into = asTable(this.getObject(p.table));\n\n        const items = into\n            .selection\n            .filter(p.where);\n\n        const setter = this.createSetter(t, into, items, p.sets);\n        const ret: any[] = [];\n        let rowCount = 0;\n        const returning = p.returning && buildSelection(new ArrayFilter(items, ret), p.returning);\n        for (const i of items.enumerate(t)) {\n            rowCount++;\n            setter(i, i);\n            ret.push(into.update(t, i));\n        }\n\n        return returning ?? rowCount;\n    }\n\n    private createSetter(t: _Transaction, setTable: _ITable, setSelection: _ISelection, _sets: SetStatement[]) {\n\n        const sets = _sets.map(x => {\n            const col = (setTable as MemoryTable).getColumnRef(x.column.name);\n            return {\n                col,\n                value: x.value,\n                getter: x.value !== 'default'\n                    ? buildValue(setSelection, x.value).convert(col.expression.type)\n                    : null,\n            };\n        });\n\n        return (target: any, source: any) => {\n            for (const s of sets) {\n                if (s.value === 'default') {\n                    target[s.col.expression.id!] = s.col.default?.get() ?? null;\n                } else {\n                    target[s.col.expression.id!] = s.getter?.get(source, t) ?? null;\n                }\n            }\n        }\n    }\n\n    private executeInsert(t: _Transaction, p: InsertStatement): WithableResult {\n        if (p.type !== 'insert') {\n            throw new NotSupported();\n        }\n\n        // get table to insert into\n        const table = asTable(this.getObject(p.into));\n        const selection = table\n            .selection\n            .setAlias(p.into.alias);\n\n\n        const ret: any[] = [];\n        const returning = p.returning && buildSelection(new ArrayFilter(selection, ret), p.returning);\n\n\n        type V = (Expr | 'default' | { _custom: any });\n        let values: V[][] | nil = p.values;\n        let columns: string[];\n\n        if (p.select) {\n            const toInsert = this.buildSelect(p.select);\n\n            // check not inserting too many values\n            columns = p.columns?.map(x => x.name)\n                ?? table.selection.columns.map(x => x.id!)\n                    .slice(0, toInsert.columns.length);\n            if (toInsert.columns.length > columns.length) {\n                throw new QueryError(`INSERT has more expressions than target columns`);\n            }\n\n            values = [];\n\n            // check insert types\n            for (let i = 0; i < columns.length; i++) {\n                const valueType = toInsert.columns[i].type;\n                const insertIntoType = table.selection.getColumn(columns[i]).type;\n                if (!valueType.canConvertImplicit(insertIntoType)) {\n                    throw new QueryError(`column \"${columns[i]}\" is of type ${insertIntoType.name} but expression is of type ${valueType.name}`);\n                }\n            }\n\n            // enumerate & get\n            for (const o of toInsert.enumerate(t)) {\n                const nv: V[] = [];\n                for (let i = 0; i < columns.length; i++) {\n                    const _custom = toInsert.columns[i].get(o, t);\n                    nv.push({\n                        _custom\n                    });\n                }\n                values.push(nv);\n            }\n        } else {\n\n            if (!values) {\n                throw new QueryError('Nothing to insert');\n            }\n\n            // get columns to insert into\n            columns = p.columns?.map(x => x.name)\n                ?? table.selection.columns\n                    .map(x => x.id!)\n                    .slice(0, values[0].length);\n        }\n\n\n\n\n        // build 'on conflict' strategy\n        let ignoreConflicts: OnConflictHandler | nil = undefined;\n        if (p.onConflict) {\n            // find the targeted index\n            const on = p.onConflict.on?.map(x => buildValue(table.selection, x));\n            let onIndex: _IIndex | nil = null;\n            if (on) {\n                onIndex = table.getIndex(...on);\n                if (!onIndex?.unique) {\n                    throw new QueryError(`There is no unique or exclusion constraint matching the ON CONFLICT specification`);\n                }\n            }\n\n            // check if 'do nothing'\n            if (p.onConflict.do === 'do nothing') {\n                ignoreConflicts = { ignore: onIndex ?? 'all' };\n            } else {\n                if (!onIndex) {\n                    throw new QueryError(`ON CONFLICT DO UPDATE requires inference specification or constraint name`);\n                }\n                const subject = new JoinSelection(this\n                    , selection\n                    // fake data... we're only using this to get the multi table column resolution:\n                    , new ArrayFilter(table.selection, []).setAlias('excluded')\n                    , {\n                        type: 'LEFT JOIN',\n                        on: { type: 'boolean', value: false }\n                    }\n                    , false\n                );\n                const setter = this.createSetter(t, table, subject, p.onConflict.do.sets);\n                ignoreConflicts = {\n                    onIndex,\n                    update: (item, excluded) => {\n                        const jitem = subject.buildItem(item, excluded);\n                        setter(item, jitem);\n                    },\n                }\n            }\n        }\n\n        // insert values\n        let rowCount = 0;\n        const opts: ChangeOpts = {\n            onConflict: ignoreConflicts,\n            overriding: p.overriding\n        };\n        for (const val of values) {\n            rowCount++;\n            if (val.length !== columns.length) {\n                throw new QueryError('Insert columns / values count mismatch');\n            }\n            const toInsert: any = {};\n            for (let i = 0; i < val.length; i++) {\n                const v: V = val[i];\n                const col = table.selection.getColumn(columns[i]);\n                if (v === 'default') {\n                    continue;\n                }\n                if ('_custom' in v) {\n                    toInsert[columns[i]] = v._custom;\n                } else {\n                    const notConv = buildValue(table.selection, v);\n                    const converted = notConv.convert(col.type);\n                    if (!converted.isConstant) {\n                        throw new QueryError('Cannot insert non constant expression');\n                    }\n                    toInsert[columns[i]] = converted.get();\n                }\n            }\n            ret.push(table.doInsert(t, toInsert, opts));\n        }\n\n        return returning ?? rowCount;\n    }\n\n\n    getTable(name: string): _ITable;\n    getTable(name: string, nullIfNotFound?: boolean): _ITable | null;\n    getTable(name: string, nullIfNotFound?: boolean): _ITable | null {\n        const ret = this.getOwnObject(name);\n        if ((!ret || ret.type !== 'table')) {\n            if (nullIfNotFound) {\n                return null;\n            }\n            throw new RelationNotFound(name);\n        }\n        return ret;\n    }\n\n\n\n    declareTable(table: Schema, noSchemaChange?: boolean): MemoryTable {\n        const trans = this.db.data.fork();\n        const ret = new MemoryTable(this, trans, table).register();\n        trans.commit();\n        if (!noSchemaChange) {\n            this.db.onSchemaChange();\n        }\n        return ret;\n    }\n\n    registerEquivalentType(type: IEquivalentType): IType {\n        const ret = new EquivalentType(type);\n        this._registerType(ret);\n        return ret;\n    }\n\n    _registerTypeSizeable(name: string, ctor: (sz?: number) => _IType): this {\n        if (this.simpleTypes[name] || this.sizeableTypes[name]) {\n            throw new QueryError(`type \"${name}\" already exists`);\n        }\n        this.sizeableTypes[name] = {\n            ctor,\n            regs: new Map(),\n        };\n        return this;\n    }\n\n    _registerType(type: _IType): this {\n        if (this.simpleTypes[type.primary] || this.sizeableTypes[type.primary] || this.getOwnObject(type.primary)) {\n            throw new QueryError(`type \"${type.primary}\" already exists`);\n        }\n        this.simpleTypes[type.primary] = type;\n        this._reg_register(type);\n        return this;\n    }\n\n\n    _reg_register(rel: _IRelation): Reg {\n        if (this.readonly) {\n            throw new PermissionDeniedError()\n        }\n        if (this.relsByNameCas.has(rel.name)) {\n            throw new Error(`relation \"${rel.name}\" already exists`);\n        }\n        const ret: Reg = regGen();\n        this.relsByNameCas.set(rel.name, rel);\n        this.relsByCls.set(ret.classId, rel);\n        this.relsByTyp.set(ret.typeId, rel);\n        if (rel.type === 'table') {\n            this._tables.add(rel);\n        }\n        return ret;\n    }\n\n    _reg_unregister(rel: _IRelation): void {\n        if (this.readonly) {\n            throw new PermissionDeniedError()\n        }\n        this.relsByNameCas.delete(rel.name);\n        this.relsByCls.delete(rel.reg.classId);\n        this.relsByTyp.delete(rel.reg.typeId);\n        if (rel.type === 'table') {\n            this._tables.delete(rel);\n        }\n    }\n\n    _reg_rename(rel: _IRelation, oldName: string, newName: string): void {\n        if (this.readonly) {\n            throw new PermissionDeniedError()\n        }\n        if (this.relsByNameCas.has(newName)) {\n            throw new Error('relation exists: ' + newName);\n        }\n        if (this.relsByNameCas.get(oldName) !== rel) {\n            throw new Error('consistency error while renaming relation');\n        }\n        this.relsByNameCas.delete(oldName);\n        this.relsByNameCas.set(newName, rel);\n    }\n\n\n\n    tablesCount(t: _Transaction): number {\n        return this._tables.size;\n    }\n\n\n    *listTables(): Iterable<_ITable> {\n        for (const t of this._tables.values()) {\n            if (!t.hidden) {\n                yield t;\n            }\n        }\n    }\n\n    registerFunction(fn: FunctionDefinition, replace?: boolean): this {\n        let fns = this.fns.get(fn.name);\n        if (!fns) {\n            this.fns.set(fn.name, fns = []);\n        }\n        fns.push({\n            args: (fn.args?.map<ArgDefDetails>(x => {\n                if (typeof x === 'string' || isType(x)) {\n                    return {\n                        type: this.getTypePub(x),\n                    };\n                }\n                return x;\n            }) ?? []) as _ArgDefDetails[],\n            argsVariadic: fn.argsVariadic && this.getTypePub(fn.argsVariadic),\n            returns: fn.returns && this.getTypePub(fn.returns),\n            impure: !!fn.impure,\n            implementation: fn.implementation,\n            allowNullArguments: fn.allowNullArguments,\n        });\n        return this;\n    }\n\n    getFunctions(name: string | QName, arrity: number, forceOwn?: boolean): Iterable<_FunctionDefinition> {\n        const asSingle = asSingleQName(name, this.name);\n        if (!asSingle || !forceOwn) {\n            return this.db.getFunctions(name, arrity);\n        }\n        const matches = this.fns.get(asSingle);\n        return !matches\n            ? []\n            : matches.filter(m => m.args.length === arrity\n                || m.args.length < arrity && m.argsVariadic);\n    }\n\n\n    async migrate(config?: IMigrate.MigrationParams) {\n        await migrate(this, config);\n    }\n\n\n\n    interceptQueries(intercept: QueryInterceptor): ISubscription {\n        const qi = { intercept } as const;\n        this.interceptors.add(qi);\n        return {\n            unsubscribe: () => {\n                this.interceptors.delete(qi);\n            }\n        };\n    }\n}\n\nclass Explainer implements _Explainer {\n    private sels = new Map<_ISelection, number>();\n    constructor(readonly transaction: _Transaction) {\n    }\n\n    idFor(sel: _ISelection<any>): string | number {\n        if (sel.debugId) {\n            return sel.debugId;\n        }\n        if (this.sels.has(sel)) {\n            return this.sels.get(sel)!;\n        }\n        const id = this.sels.size + 1;\n        this.sels.set(sel, id);\n        return id;\n    }\n\n}\n","import { DataType, QueryError } from '../interfaces';\nimport { _IType } from '../interfaces-private';\nimport { Box, Circle, Line, Path, Point, Polygon, Segment } from 'pgsql-ast-parser';\nimport { Evaluator } from '../evaluator';\nimport { TypeBase } from './datatype-base';\n\nexport function pointToStr(p: Point) {\n    return `(${p.x},${p.y})`;\n}\n\nexport function pointEq(a: Point, b: Point) {\n    return a.x === b.x && a.y === b.y;\n}\n\nexport class PointType extends TypeBase<Point> {\n    get primary(): DataType {\n        return DataType.point;\n    }\n    get name() {\n        return 'point';\n    }\n    doCanCast(t: _IType) {\n        return t.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<Point>, to: _IType) {\n        if (to.primary !== DataType.text) {\n            throw new QueryError(`Invalid cast to: ` + to.primary);\n        }\n        return value\n            .setConversion((p: Point) => {\n                return pointToStr(p);\n            }\n                , pointToTxt => ({ pointToTxt }));\n    }\n\n    doEquals(a: Point, b: Point) {\n        return pointEq(a, b);\n    }\n\n    doGt(a: Point, b: Point) {\n        if (a.x !== b.x) {\n            return a.x > b.x;\n        }\n        return a.y > b.y;\n    }\n\n    doLt(a: Point, b: Point) {\n        if (a.x !== b.x) {\n            return a.x < b.x;\n        }\n        return a.y < b.y;\n    }\n}\n\n\n\nexport class LineType extends TypeBase<Line> {\n\n    get primary(): DataType {\n        return DataType.line;\n    }\n    get name() {\n        return 'line';\n    }\n    doCanCast(t: _IType) {\n        return t.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<Line>, to: _IType) {\n        if (to.primary !== DataType.text) {\n            throw new QueryError(`Invalid cast to: ` + to.primary);\n        }\n        return value\n            .setConversion((l: Line) => {\n                return `{${l.a},${l.b},${l.c}}`;\n            }\n                , lineToTxt => ({ lineToTxt }));\n    }\n\n    doEquals(a: Line, b: Line) {\n        return a.a === b.a && a.b === b.b && a.c === b.c;\n    }\n}\n\nexport class LsegType extends TypeBase<Segment> {\n\n    get primary(): DataType {\n        return DataType.lseg;\n    }\n    get name() {\n        return 'lseg';\n    }\n    doCanCast(t: _IType) {\n        return t.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<Segment>, to: _IType) {\n        if (to.primary !== DataType.text) {\n            throw new QueryError(`Invalid cast to: ` + to.primary);\n        }\n        return value\n            .setConversion(([a, b]: Segment) => {\n                return `[${pointToStr(a)},${pointToStr(b)}]`;\n            }\n                , SegmentToTxt => ({ SegmentToTxt }));\n    }\n\n    doEquals([as, ae]: Segment, [bs, be]: Segment) {\n        return pointEq(as, bs) && pointEq(ae, be);\n    }\n}\n\nexport class BoxType extends TypeBase<Box> {\n\n    get primary(): DataType {\n        return DataType.box;\n    }\n    get name() {\n        return 'box';\n    }\n    doCanCast(t: _IType) {\n        return t.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<Box>, to: _IType) {\n        if (to.primary !== DataType.text) {\n            throw new QueryError(`Invalid cast to: ` + to.primary);\n        }\n        return value\n            .setConversion(([a, b]: Box) => {\n                return `${pointToStr(a)},${pointToStr(b)}`;\n            }\n                , BoxToTxt => ({ BoxToTxt }));\n    }\n\n    doEquals([as, ae]: Box, [bs, be]: Box) {\n        return pointEq(as, bs) && pointEq(ae, be);\n    }\n}\n\nexport class PathType extends TypeBase<Path> {\n\n    get primary(): DataType {\n        return DataType.path;\n    }\n    get name() {\n        return 'path';\n    }\n    doCanCast(t: _IType) {\n        return t.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<Path>, to: _IType) {\n        if (to.primary !== DataType.text) {\n            throw new QueryError(`Invalid cast to: ` + to.primary);\n        }\n        return value\n            .setConversion((p: Path) => {\n                const vals = p.path.map(pointToStr).join(',');\n                return p.closed\n                    ? '(' + vals + ')'\n                    : '[' + vals + ']';\n            }\n                , PathToTxt => ({ PathToTxt }));\n    }\n\n    doEquals(a: Path, b: Path) {\n        // Yup, you read that right ...\n        //  Try it... path equality always returns true (???)\n        return true;\n        // return !!a.closed === !!b.closed\n        //     && a.path.length === b.path.length\n        //     && a.path.every((x, i) => pointEq(x, b.path[i]));\n    }\n}\n\nexport class PolygonType extends TypeBase<Polygon> {\n\n    get primary(): DataType {\n        return DataType.polygon;\n    }\n    get name() {\n        return 'polygon';\n    }\n    doCanCast(t: _IType) {\n        return t.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<Polygon>, to: _IType) {\n        if (to.primary !== DataType.text) {\n            throw new QueryError(`Invalid cast to: ` + to.primary);\n        }\n        return value\n            .setConversion((p: Polygon) => {\n                const vals = p.map(pointToStr).join(',');\n                return '(' + vals + ')';\n            }\n                , PolygonToTxt => ({ PolygonToTxt }));\n    }\n\n    doEquals(a: Polygon, b: Polygon) {\n        return a.length === b.length\n            && a.every((x, i) => pointEq(x, b[i]));\n    }\n}\n\n\nexport class CircleType extends TypeBase<Circle> {\n\n    get primary(): DataType {\n        return DataType.circle;\n    }\n    get name() {\n        return 'circle';\n    }\n    doCanCast(t: _IType) {\n        return t.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<Circle>, to: _IType) {\n        if (to.primary !== DataType.text) {\n            throw new QueryError(`Invalid cast to: ` + to.primary);\n        }\n        return value\n            .setConversion((p: Circle) => {\n                return `<${pointToStr(p.c)},${p.r}>`\n            }\n                , CircleToTxt => ({ CircleToTxt }));\n    }\n\n    doEquals(a: Circle, b: Circle) {\n        return pointEq(a.c, b.c) && a.r === b.r;\n    }\n}\n","import { DataType, nil, _IType } from '../interfaces-private';\nimport { Interval, normalizeInterval, parseIntervalLiteral } from 'pgsql-ast-parser';\nimport { TypeBase } from './datatype-base';\nimport { Evaluator } from '../evaluator';\nimport { intervalToSec } from '../utils';\n\nexport class IntervalType extends TypeBase<Interval> {\n\n    get primary(): DataType {\n        return DataType.interval;\n    }\n\n    doCanBuildFrom(from: _IType) {\n        switch (from.primary) {\n            case DataType.text:\n                return true;\n        }\n        return false;\n    }\n\n    doBuildFrom(value: Evaluator, from: _IType): Evaluator<Interval> | nil {\n        switch (from.primary) {\n            case DataType.text:\n                return value\n                    .setConversion(str => {\n                        const conv = normalizeInterval(parseIntervalLiteral(str));\n                        return conv;\n                    }\n                        , toInterval => ({ toInterval }));\n        }\n        return null;\n    }\n\n    doEquals(a: Interval, b: Interval): boolean {\n        return intervalToSec(a) === intervalToSec(b);\n    }\n    doGt(a: Interval, b: Interval): boolean {\n        return intervalToSec(a) > intervalToSec(b);\n    }\n    doLt(a: Interval, b: Interval): boolean {\n        return intervalToSec(a) < intervalToSec(b);\n    }\n}\n","import { DataType, nil, QueryError, _IType } from '../interfaces-private';\nimport { TypeBase } from './datatype-base';\nimport { Evaluator } from '../evaluator';\nimport { Types } from './datatypes';\nimport { parseTime } from '../utils';\n\n\nexport class TimeType extends TypeBase<string> {\n\n\n    get primary(): DataType {\n        return DataType.time;\n    }\n\n\n    doCanCast(to: _IType) {\n        switch (to.primary) {\n            case DataType.text:\n                return true;\n        }\n        return null;\n    }\n\n    doCast(value: Evaluator, to: _IType) {\n        switch (to.primary) {\n            case DataType.text:\n                return value\n                    .setType(Types.text())\n        }\n        throw new Error('Unexpected cast error');\n    }\n\n\n    doCanBuildFrom(from: _IType) {\n        switch (from.primary) {\n            case DataType.text:\n                return true;\n        }\n        return false;\n    }\n\n    doBuildFrom(value: Evaluator, from: _IType): Evaluator<string> | nil {\n        switch (from.primary) {\n            case DataType.text:\n                return value\n                    .setConversion(str => {\n                        const conv = parseTime(str);\n                        const ret = conv.format('HH:mm:ss');\n                        const ms = conv.milliseconds();\n                        return ms\n                            ? ret + (ms / 1000).toString(10).substr(1)\n                            : ret;\n                    }\n                        , toTime => ({ toTime }));\n        }\n        return null;\n    }\n\n}\n","import { DataType, nil, QueryError, _IType } from '../interfaces-private';\nimport { TypeBase } from './datatype-base';\nimport { Evaluator } from '../evaluator';\nimport moment from 'moment';\n\nexport class TimestampType extends TypeBase<Date> {\n\n\n    constructor(readonly primary: DataType) {\n        super();\n    }\n\n    doCanCast(to: _IType) {\n        switch (to.primary) {\n            case DataType.timestamp:\n            case DataType.date:\n            case DataType.time:\n                return true;\n        }\n        return null;\n    }\n\n    doCast(value: Evaluator, to: _IType) {\n        switch (to.primary) {\n            case DataType.timestamp:\n                return value;\n            case DataType.date:\n                return value\n                    .setConversion(raw => moment.utc(raw).startOf('day').toDate()\n                        , toDate => ({ toDate }));\n            case DataType.time:\n                return value\n                    .setConversion(raw => moment.utc(raw).format('HH:mm:ss') + '.000000'\n                        , toDate => ({ toDate }));\n        }\n        throw new Error('Unexpected cast error');\n    }\n\n\n    doCanBuildFrom(from: _IType) {\n        switch (from.primary) {\n            case DataType.text:\n                return true;\n        }\n        return false;\n    }\n\n    doBuildFrom(value: Evaluator, from: _IType): Evaluator<Date> | nil {\n        switch (from.primary) {\n            case DataType.text:\n                switch (this.primary) {\n                    case DataType.timestamp:\n                        return value\n                            .setConversion(str => {\n                                const conv = moment.utc(str);\n                                if (!conv.isValid()) {\n                                    throw new QueryError(`Invalid timestamp format: ` + str);\n                                }\n                                return conv.toDate()\n                            }\n                                , toTs => ({ toTs }));\n                    case DataType.date:\n                        return value\n                            .setConversion(str => {\n                                const conv = moment.utc(str);\n                                if (!conv.isValid()) {\n                                    throw new QueryError(`Invalid timestamp format: ` + str);\n                                }\n                                return conv.startOf('day').toDate();\n                            }\n                                , toDate => ({ toDate }));\n                }\n        }\n        return null;    \n    }\n\n\n\n    doEquals(a: any, b: any): boolean {\n        return Math.abs(moment(a).diff(moment(b))) < 0.1;\n    }\n    doGt(a: any, b: any): boolean {\n        return moment(a).diff(moment(b)) > 0;\n    }\n    doLt(a: any, b: any): boolean {\n        return moment(a).diff(moment(b)) < 0;\n    }\n}","import { DataType, nil, _IType } from '../interfaces-private';\nimport { TypeBase } from './datatype-base';\nimport { Evaluator } from '../evaluator';\nimport { deepCompare, deepEqual } from '../utils';\nimport { Types } from './datatypes';\nimport { JSON_NIL } from '../clean-results';\nimport { QueryError } from '../interfaces';\n\nexport class JSONBType extends TypeBase<any> {\n\n\n    constructor(readonly primary: DataType) {\n        super();\n    }\n\n    doCanCast(_to: _IType): boolean | nil {\n        switch (_to.primary) {\n            case DataType.text:\n            case DataType.json:\n            case DataType.jsonb:\n            case DataType.float:\n            case DataType.bool:\n            case DataType.integer:\n                return true;\n        }\n        return null;\n    }\n\n    doCast(a: Evaluator, to: _IType): Evaluator {\n        switch (to.primary) {\n            case DataType.json:\n                return a\n                    .setType(Types.text())\n                    .setConversion(json => JSON.stringify(this.toResult(json))\n                        , toJsonB => ({ toJsonB }))\n                    .convert(to) as Evaluator; // <== might need truncation\n            case DataType.jsonb:\n                return a.setType(to);\n            case DataType.float:\n            case DataType.integer:\n                const isInt = to.primary === DataType.integer;\n                return a\n                    .setType(to)\n                    .setConversion(json => {\n                        if (typeof json !== 'number') {\n                            throw new QueryError('cannot cast jsonb string to type ' + isInt ? 'integer' : 'double precision', '22023');\n                        }\n                        return isInt ? Math.round(json) : json;\n                    }, toFloat => ({ toFloat }));\n            case DataType.bool:\n                return a\n                    .setType(to)\n                    .setConversion(json => {\n                        if (typeof json !== 'boolean') {\n                            throw new QueryError('cannot cast jsonb string to type boolean', '22023');\n                        }\n                        return json;\n                    }, toFloat => ({ toFloat }));\n            default:\n                return a.setType(to);\n        }\n\n    }\n\n\n\n    doCanBuildFrom(from: _IType) {\n        switch (from.primary) {\n            case DataType.text:\n                return true;\n        }\n        return false;\n    }\n\n    doBuildFrom(value: Evaluator, from: _IType): Evaluator<Date> | nil {\n        switch (from.primary) {\n            case DataType.text:\n                return value\n                    .setConversion(raw => {\n                        try {\n                            return JSON.parse(raw, (_, x) => x ?? JSON_NIL) ?? JSON_NIL\n                        } catch (e) {\n                            throw new QueryError({\n                                error: `invalid input syntax for type json`,\n                                details: e.message,\n                                code: '22P02',\n                            });\n                        }\n                    }\n                        , toJsonb => ({ toJsonb }));\n        }\n        return null;\n    }\n\n\n\n    doEquals(a: any, b: any): boolean {\n        return deepEqual(this.toResult(a), this.toResult(b), false);\n    }\n\n    doGt(a: any, b: any): boolean {\n        return deepCompare(this.toResult(a), this.toResult(b)) > 0;\n    }\n\n    doLt(a: any, b: any): boolean {\n        return deepCompare(this.toResult(a), this.toResult(b)) < 0;\n    }\n\n    toResult(result: any): any {\n        return result === JSON_NIL\n            ? null\n            : result;\n    }\n\n}\n","import { DataType, nil, QueryError, RegClass, RegType, _IType } from '../interfaces-private';\nimport { TypeBase } from './datatype-base';\nimport { Evaluator } from '../evaluator';\nimport { Types } from './datatypes';\n\nexport class RegTypeImpl extends TypeBase<RegType> {\n\n\n    get primary(): DataType {\n        return DataType.regtype;\n    }\n\n    doCanCast(_to: _IType): boolean | nil {\n        switch (_to.primary) {\n            case DataType.text:\n            case DataType.integer:\n                return true;\n        }\n        return null;\n    }\n\n    doCast(a: Evaluator<RegType>, to: _IType): Evaluator {\n        switch (to.primary) {\n            case DataType.text:\n                return a\n                    .setType(to)\n                    .setConversion(raw => raw.toString(10)\n                        , toText => ({ toText }))\n            case DataType.integer:\n                return a\n                    .setType(to)\n                    .setConversion((raw: RegType) => {\n                        if (typeof raw === 'number') {\n                            return raw;\n                        }\n                        const t = a.owner.parseType(raw);\n                        return t.reg.typeId;\n                    }\n                        , toText => ({ toText }))\n        }\n        throw new Error('failed to cast');\n    }\n\n\n    doCanBuildFrom(from: _IType) {\n        switch (from.primary) {\n            case DataType.text:\n                return true;\n        }\n        return false;\n    }\n\n    doBuildFrom(value: Evaluator, from: _IType): Evaluator<RegClass> | nil {\n        switch (from.primary) {\n            case DataType.text:\n                return value\n                    .setType(Types.regtype)\n                    .setConversion((str: string) => {\n                        let repl = str.replace(/[\"\\s]+/g, '');\n                        if (repl.startsWith('pg_catalog.')) {\n                            repl = repl.substr('pg_catalog.'.length);\n                        }\n                        return value.owner.parseType(repl).name;\n                    }\n                        , strToRegType => ({ strToRegType }));\n        }\n        return null;\n    }\n\n}\n","import { DataType, nil, QueryError, RegClass, _IType } from '../interfaces-private';\nimport { TypeBase } from './datatype-base';\nimport { Evaluator } from '../evaluator';\nimport { getContext, parseRegClass } from '../utils';\nimport { Types } from './datatypes';\n\nexport class RegClassImpl extends TypeBase<RegClass> {\n\n\n\n    get primary(): DataType {\n        return DataType.regclass;\n    }\n\n    doCanCast(_to: _IType): boolean | nil {\n        switch (_to.primary) {\n            case DataType.text:\n            case DataType.integer:\n                return true;\n        }\n        return null;\n    }\n\n    doCast(a: Evaluator, to: _IType): Evaluator {\n        switch (to.primary) {\n            case DataType.text:\n                return a\n                    .setType(Types.text())\n                    .setConversion((raw: RegClass) => {\n                        return raw?.toString();\n                    }\n                        , toText => ({ toText }))\n            case DataType.integer:\n                return a\n                    .setType(Types.text())\n                    .setConversion((raw: RegClass) => {\n\n                        // === regclass -> int\n\n                        const cls = parseRegClass(raw);\n                        const { schema } = getContext();\n\n                        // if its a number, then try to get it.\n                        if (typeof cls === 'number') {\n                            return schema.getObjectByRegOrName(cls)\n                                ?.reg.classId\n                                ?? cls;\n                        }\n\n                        // get the object or throw\n                        return schema.getObjectByRegOrName(raw)\n                            .reg.classId;\n                    }\n                        , toText => ({ toText }))\n        }\n        throw new Error('failed to cast');\n    }\n\n\n\n    doCanBuildFrom(from: _IType) {\n        switch (from.primary) {\n            case DataType.text:\n                return true;\n        }\n        return false;\n    }\n\n    doBuildFrom(value: Evaluator, from: _IType): Evaluator<RegClass> | nil {\n        switch (from.primary) {\n            case DataType.text:\n                return value\n                    .setConversion((str: string) => {\n                        // === text -> regclass\n\n                        const cls = parseRegClass(str);\n                        const { schema } = getContext();\n\n                        // if its a number, then try to get it.\n                        if (typeof cls === 'number') {\n                            return schema.getObjectByRegOrName(cls)\n                                ?.name\n                                ?? cls;\n                        }\n\n                        // else, get or throw.\n                        return schema.getObject(cls)\n                            .name;\n                    }\n                        , strToRegClass => ({ strToRegClass }));\n        }\n        return null;\n    }\n\n}\n","import { DataType, getId, nil, QueryError, _IType } from '../interfaces-private';\nimport { TypeBase } from './datatype-base';\nimport { Evaluator } from '../evaluator';\nimport { deepCompare, deepEqual } from '../utils';\n\n\nexport class RecordType extends TypeBase<any> {\n\n    get primary(): DataType {\n        return DataType.record;\n    }\n\n    doEquals(a: any, b: any): boolean {\n        return getId(a) === getId(b);\n    }\n}","import { Evaluator } from '../evaluator';\nimport { TypeBase } from './datatype-base';\nimport { DataType, nil, QueryError } from '../interfaces';\nimport { _ISchema, _IType } from '../interfaces-private';\n\n// https://www.postgresql.org/docs/13/datatype-net-types.html#DATATYPE-INET\n\nexport class INetType extends TypeBase<string> {\n\n    get primary(): DataType {\n        return DataType.inet\n    }\n\n    doCanCast(to: _IType) {\n        return to.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<string>, to: _IType<string>): Evaluator<any> | nil {\n        return value;\n    }\n\n    prefer(type: _IType<any>): _IType | nil {\n        return this;\n    }\n\n    doCanBuildFrom(from: _IType): boolean | nil {\n        return from.primary === DataType.text;\n    }\n\n    doBuildFrom(value: Evaluator<string>, from: _IType<string>): Evaluator<string> | nil {\n        return value\n            .setConversion(x => {\n                const [_, a, b, c, d, __, m] = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)(\\/(\\d+))?$/.exec(x) ?? []\n                if ([a, b, c, d].some(notByte) || notMask(m)) {\n                    throw new QueryError(`invalid input syntax for type inet: ${x}`);\n                }\n                return x;\n            }, toInet => ({ toInet }));\n    }\n}\n\nfunction notByte(b: string) {\n    return !b\n        || b.length > 1 && b[0] === '0'\n        || parseInt(b, 10) > 255;\n}\n\nfunction notMask(b: string) {\n    return b\n        && (b.length > 1 && b[0] === '0'\n            || parseInt(b, 10) > 32);\n}","import { IValue, _IType, _ISelection, _ISchema, _IDb, _Transaction } from './interfaces-private';\nimport { Types, ArrayType } from './datatypes';\nimport { QueryError, NotSupported, nil } from './interfaces';\nimport { Evaluator } from './evaluator';\nimport hash from 'object-hash';\nimport { parseArrayLiteral, QName } from 'pgsql-ast-parser';\nimport { asSingleQName, colToStr, nullIsh, qnameToStr } from './utils';\n\n\nexport function buildCall(schema: _ISchema, name: string | QName, args: IValue[]) {\n    let type: _IType | nil = null;\n    let get: (...args: any[]) => any;\n\n    let impure = false;\n    let acceptNulls = false;\n\n    // put your ugly hack here   ...\n    switch (asSingleQName(name)) {\n        case 'any':\n            return buildAnyCall(schema, args);\n        case 'current_schema':\n            type = Types.text();\n            get = () => 'public';\n            break;\n        // a set of functions that are calledby Tyopeorm, but we dont needto support them yet\n        // since there is not result (function never actually called)\n        case 'pg_get_constraintdef':\n        case 'pg_get_expr':\n            type = Types.text();\n            get = () => {\n                throw new NotSupported(qnameToStr(name) + ' is not supported');\n            };\n            break;\n        case 'unnest':\n            if (args.length !== 1) {\n                throw new QueryError('unnest expects 1 arguments, given ' + args.length);\n            }\n            const utype = args[0].type;\n            if (!(utype instanceof ArrayType)) {\n                throw new QueryError('unnest expects enumerable argument ' + utype.primary);\n            }\n            type = utype.of;\n            get = () => {\n                throw new NotSupported(qnameToStr(name) + ' is not supported');\n            };\n            break;\n        case 'coalesce':\n            acceptNulls = true;\n            args = args.map(x => x.convert(args[0].type));\n            type = args[0].type;\n            get = (...args: any[]) => args.find(x => !nullIsh(x));\n            break;\n        default:\n            // try to find a matching custom function overloads\n            acceptNulls = true;\n            for (const o of schema.getFunctions(name, args.length)) {\n                let ok = true;\n                for (let i = 0; i < args.length; i++) {\n                    const t = o.args[i]?.type ?? o.argsVariadic;\n                    // calling 'out' arguments not supported\n                    if (!t || !args[i].canConvert(t) || o.args[i]?.mode === 'out') {\n                        ok = false;\n                        break;\n                    }\n                }\n\n                if (ok) {\n                    args = args.map((x, i) => x.convert(o.args[i]?.type ?? o.argsVariadic));\n                    type = o.returns;\n                    get = o.implementation;\n                    impure = !!o.impure;\n                    acceptNulls = !!o.allowNullArguments;\n                    break;\n                }\n            }\n\n\n    }\n    if (!get!) {\n        throw new QueryError({\n            error: `function ${qnameToStr(name)}(${args.map(a => a.type.name).join(',')}) does not exist`,\n            hint: ` Please note that pg-mem implements very few native functions.\n\n             You can specify the functions you would like to use via \"db.public.registerFunction(...)\"`\n        })\n    }\n    return new Evaluator(\n        schema\n        , type ?? Types.null\n        , null\n        , hash({ call: name, args: args.map(x => x.hash) })\n        , args\n        , (raw, t) => {\n            const argRaw = args.map(x => x.get(raw, t));\n            if (!acceptNulls && argRaw.some(nullIsh)) {\n                return null;\n            }\n            return get(...argRaw);\n        }, impure ? { unpure: impure } : undefined);\n}\n\n\nfunction buildAnyCall(schema: _ISchema, args: IValue[]) {\n    if (args.length !== 1) {\n        throw new QueryError('ANY() expects 1 argument, given ' + args.length);\n    }\n    const array = args[0];\n\n    // == if ANY(select something) ... get the element type\n    if (array.type instanceof ArrayType) {\n        return new Evaluator(\n            schema\n            , array.type.of\n            , null\n            , hash({ any: array.hash })\n            , args\n            , (raw, t) => {\n                return array.get(raw, t);\n            }\n            , { isAny: true } // <== isAny !\n        );\n    }\n\n    // == if ANY('{elements}') ... will be an array of text => keep text\n\n    if (array.type !== Types.text() || !array.isConstantLiteral) {\n        throw new QueryError('ANY() expects either a selection, or an array literal');\n    }\n    // parse ANY() array literal\n    const arrayValue = parseArrayLiteral(array.get());\n    return new Evaluator(\n        schema\n        , Types.text()\n        , null\n        , hash({ any: array.hash })\n        , args\n        , arrayValue\n        , { isAny: true } // <== isAny !\n    );\n}","import { _IIndex, IValue, IndexExpression, _Transaction, IndexKey, _Explainer, _IndexExplanation, IndexOp, _ISelection, Stats } from '../interfaces-private';\n\nexport class RestrictiveIndex<T> implements _IIndex<T> {\n    constructor(private base: _IIndex<T>, readonly filter: _ISelection<T>) {\n        // , readonly match: (raw: T, t: _Transaction) => boolean) {\n    }\n\n    private match(raw: T, t: _Transaction) {\n        return this.filter.hasItem(raw, t);\n    }\n\n    get expressions(): IndexExpression[] {\n        return this.base.expressions;\n    }\n\n    stats(t: _Transaction, key?: IndexKey): Stats | null {\n        // cannot comput without iterating\n        return null;\n    }\n\n    iterateKeys() {\n        // cannot comput without iterating\n        return null;\n    }\n\n    eqFirst(rawKey: IndexKey, t: _Transaction) {\n        for (const i of this.base.enumerate({\n            key: rawKey,\n            t: t,\n            type: 'eq',\n        })) {\n            if (this.match(i, t)) {\n                return i;\n            }\n        }\n        return null;\n    }\n\n\n    entropy(t: IndexOp): number {\n        return this.base.entropy(t);\n    }\n\n    *enumerate(op: IndexOp): Iterable<T> {\n        for (const i of this.base.enumerate(op)) {\n            if (this.match(i, op.t)) {\n                yield i;\n            }\n        }\n    }\n\n    explain(e: _Explainer): _IndexExplanation {\n        return {\n            _: 'indexRestriction',\n            lookup: this.base.explain(e),\n            for: this.filter.explain(e),\n            // criteria: this.restrict.explain(e),\n        }\n    }\n}","import { AggregationComputer, AggregationGroupComputer, IndexKey, IValue, QueryError, _IIndex, _ISelection, _IType, _Transaction } from '../../interfaces-private';\nimport { ExprCall } from 'pgsql-ast-parser';\nimport { isSelectAllArgList, nullIsh } from '../../utils';\nimport { buildValue } from '../../expression-builder';\nimport { Types } from '../../datatypes';\nimport objectHash from 'object-hash';\n\nexport function buildCount(this: void, base: _ISelection, call: ExprCall) {\n    const args = call.args;\n    if (isSelectAllArgList(args)) {\n        return new CountStar(base);\n    }\n    if (args.length !== 1) {\n        throw new QueryError('COUNT expects one argument, given ' + args.length);\n    }\n    if (call.distinct) {\n        if (!args.length) {\n            throw new QueryError('distinct() must take at least one argument');\n        }\n        if (args.length === 1 && args[0].type === 'list') {\n            // hack in case we get a record-like thing - ex: select count(distinct (a,b))\n            // cf UT behaves nicely with nulls on multiple count\n            const distinctArgs = args[0].expressions.map(x => buildValue(base, x));\n            return new CountDistinct(distinctArgs);\n        } else {\n            const distinctArgs = args.map(x => buildValue(base, x));\n            return new CountDistinct(distinctArgs);\n        }\n    }\n    const what = buildValue(base, args[0]);\n    return new CountExpr(what);\n}\n\nclass CountStar implements AggregationComputer<number> {\n\n    constructor(private on: _ISelection) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint;\n    }\n\n    computeFromIndex(key: IndexKey, index: _IIndex<any>, t: _Transaction) {\n        const stats = index.stats(t, key);\n        return stats?.count;\n    }\n\n    computeNoGroup(t: _Transaction) {\n        return this.on.stats(t)?.count;\n    }\n\n    createGroup(): AggregationGroupComputer<number> {\n        let cnt = 0;\n        return {\n            feedItem: () => cnt++,\n            finish: () => cnt,\n        };\n    }\n\n}\n\nclass CountExpr implements AggregationComputer<number> {\n\n    constructor(private exp: IValue) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint;\n    }\n\n    createGroup(t: _Transaction): AggregationGroupComputer<number> {\n        let cnt = 0;\n        return {\n            feedItem: (item) => {\n                const value = this.exp.get(item, t);\n                if (!nullIsh(value)) {\n                    cnt++;\n                }\n            },\n            finish: () => cnt,\n        };\n    }\n}\n\nclass CountDistinct implements AggregationComputer<number> {\n\n    constructor(private exps: IValue[]) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint;\n    }\n\n    createGroup(t: _Transaction): AggregationGroupComputer<number> {\n        const unique = new Set();\n        return {\n            feedItem: this.exps.length === 1\n                ? (item) => {\n                    const value = this.exps[0].type.hash(this.exps[0].get(item, t));\n                    if (nullIsh(value)) {\n                        return; // ignore single nulls.\n                    }\n                    unique.add(value);\n                } : (item) => {\n                    const value = this.exps.map(x => x.type.hash(x.get(item, t)));\n                    unique.add(objectHash(value));\n                },\n            finish: () => unique.size,\n        };\n    }\n}\n","import { AggregationComputer, AggregationGroupComputer, IValue, nil, QueryError, _ISelection, _IType, _Transaction } from '../../interfaces-private';\nimport { Expr } from 'pgsql-ast-parser';\nimport { buildValue } from '../../expression-builder';\nimport { Types } from '../../datatypes';\nimport { nullIsh } from '../../utils';\n\n\nclass MinMax implements AggregationComputer<number> {\n\n    constructor(private exp: IValue, private isMax: boolean) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint;\n    }\n\n    createGroup(t: _Transaction): AggregationGroupComputer<number> {\n        let val: number | nil = null;\n        return {\n            feedItem: (item) => {\n                const value = this.exp.get(item, t);\n                if (!nullIsh(value) && (nullIsh(val) || (\n                    this.isMax\n                        ? val! < value\n                        : val! > value\n                ))) {\n                    val = value;\n                }\n            },\n            finish: () => val,\n        };\n    }\n}\n\n\nexport function buildMinMax(this: void, base: _ISelection, args: Expr[], op: 'max' | 'min') {\n    if (args.length !== 1) {\n        throw new QueryError(op.toUpperCase() + ' expects one argument, given ' + args.length);\n    }\n\n    const what = buildValue(base, args[0]);\n    return new MinMax(what, op === 'max');\n}\n","import { AggregationComputer, AggregationGroupComputer, IValue, nil, QueryError, _ISelection, _IType, _Transaction } from '../../interfaces-private';\nimport { ExprCall } from 'pgsql-ast-parser';\nimport { buildValue } from '../../expression-builder';\nimport { Types } from '../../datatypes';\nimport { nullIsh } from '../../utils';\n\n\nclass SumExpr implements AggregationComputer<number> {\n\n    constructor(private exp: IValue) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint;\n    }\n\n    createGroup(t: _Transaction): AggregationGroupComputer<number> {\n        let val: number | nil = null;\n        return {\n            feedItem: (item) => {\n                const value = this.exp.get(item, t);\n                if (!nullIsh(value)) {\n                    val = nullIsh(val) ? value : val + value;\n                }\n            },\n            finish: () => val,\n        }\n    }\n}\n\nclass SumDistinct implements AggregationComputer<number> {\n\n    constructor(private exp: IValue) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint\n    }\n    createGroup(t: _Transaction): AggregationGroupComputer<number> {\n        const unique = new Set<number>();\n        return {\n            feedItem: (item) => {\n                const value = this.exp.get(item, t)\n                if (!nullIsh(value)) {\n                    unique.add(value);\n                }\n            },\n            finish: () => unique.size === 0 ? null : [...unique].reduce((acc, cur) => acc + cur, 0)\n        }\n    }\n\n}\n\nexport function buildSum(this: void, base: _ISelection, call: ExprCall) {\n    const args = call.args;\n    if (args.length !== 1) {\n        throw new QueryError('SUM expects one argument, given ' + args.length);\n    }\n\n    if (call.distinct) {\n        if (args.length !== 1) {\n            throw new QueryError('\"sum distinct\" only takes one argument');\n        }\n        const distinctArg = buildValue(base, args[0]);\n        return new SumDistinct(distinctArg);\n    }\n\n    const what = buildValue(base, args[0]);\n    return new SumExpr(what);\n}\n","import { AggregationComputer, AggregationGroupComputer, IValue, nil, QueryError, _ISelection, _IType, _Transaction } from '../../interfaces-private';\nimport { ExprCall } from 'pgsql-ast-parser';\nimport { buildValue } from '../../expression-builder';\nimport { Types } from '../../datatypes';\n\n\nclass ArrayAggExpr implements AggregationComputer<any[]> {\n\n    constructor(private exp: IValue) {\n    }\n\n    get type(): _IType<any> {\n        return Types.integer.asArray();\n    }\n\n    createGroup(t: _Transaction): AggregationGroupComputer<any[]> {\n        let val: any[] = [];\n        return {\n            feedItem: (item) => {\n                const value = this.exp.get(item, t);\n                val = [...val, value];\n            },\n            finish: () => val,\n        }\n    }\n}\n\nexport function buildArrayAgg(this: void, base: _ISelection, call: ExprCall) {\n    const args = call.args;\n    if (args.length !== 1) {\n        throw new QueryError('ARRAY_AGG expects one argument, given ' + args.length);\n    }\n\n    const what = buildValue(base, args[0]);\n    return new ArrayAggExpr(what);\n}\n","import { AggregationComputer, AggregationGroupComputer, IValue, nil, QueryError, _ISelection, _IType, _Transaction } from '../../interfaces-private';\nimport { ExprCall } from 'pgsql-ast-parser';\nimport { buildValue } from '../../expression-builder';\nimport { Types } from '../../datatypes';\nimport { nullIsh, sum } from '../../utils';\n\n\nclass AvgExpr implements AggregationComputer<number> {\n\n    constructor(private exp: IValue) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint;\n    }\n\n    createGroup(t: _Transaction): AggregationGroupComputer<number> {\n        let full: number[] = [];\n        return {\n            feedItem: (item) => {\n                const value = this.exp.get(item, t);\n                if (!nullIsh(value)) {\n                    full.push(value);\n                }\n            },\n            finish: () => full.length === 0 ? null : sum(full)/full.length,\n        }\n    }\n}\n\nclass SumDistinct implements AggregationComputer<number> {\n\n    constructor(private exp: IValue) {\n    }\n\n    get type(): _IType<any> {\n        return Types.bigint\n    }\n    createGroup(t: _Transaction): AggregationGroupComputer<number> {\n        const unique = new Set<number>();\n        return {\n            feedItem: (item) => {\n                const value = this.exp.get(item, t)\n                if (!nullIsh(value)) {\n                    unique.add(value);\n                }\n            },\n            finish: () => unique.size === 0 ? null : sum([...unique])/unique.size\n        }\n    }\n\n}\n\nexport function buildAvg(this: void, base: _ISelection, call: ExprCall) {\n    const args = call.args;\n    if (args.length !== 1) {\n        throw new QueryError('AVG expects one argument, given ' + args.length);\n    }\n\n    if (call.distinct) {\n        const distinctArg = buildValue(base, args[0]);\n        return new SumDistinct(distinctArg);\n    }\n\n    const what = buildValue(base, args[0]);\n    return new AvgExpr(what);\n}\n","import { _ISelection, IValue, _IIndex, _IDb, setId, getId, _Transaction, _ISchema, _SelectExplanation, _Explainer, IndexExpression, IndexOp, IndexKey, _IndexExplanation, Stats, _IAlias, TR } from '../interfaces-private';\nimport { buildBinaryValue, buildValue, uncache } from '../expression-builder';\nimport { QueryError, ColumnNotFound, NotSupported, nil, DataType } from '../interfaces';\nimport { DataSourceBase, TransformBase } from './transform-base';\nimport { Expr, ExprRef, JoinClause, Name, SelectedColumn } from 'pgsql-ast-parser';\nimport { colToStr, nullIsh, SRecord } from '../utils';\nimport { Types } from '../datatypes';\nimport { SELECT_ALL } from '../clean-results';\nimport { CustomAlias, Selection } from './selection';\n\nlet jCnt = 0;\n\ninterface JoinRaw<TLeft, TRight> {\n    '>restrictive': TLeft;\n    '>joined': TRight;\n}\ninterface JoinStrategy {\n    iterate: _ISelection<any>;\n    iterateSide: 'joined' | 'restrictive';\n    joinIndex: _IIndex<any>;\n    onValue: IValue;\n    othersPredicate?: IValue<any>;\n}\n\ninterface Equality {\n    left: IValue;\n    right: IValue;\n    eq: IValue;\n}\n\nfunction* extractAnds(this: void, on: Expr): Iterable<Expr> {\n    if (on.type === 'binary' && on.op === 'AND') {\n        yield* extractAnds(on.left);\n        yield* extractAnds(on.right);\n        return;\n    }\n    yield on;\n}\n\nfunction chooseStrategy(this: void, t: _Transaction, strategies: JoinStrategy[]) {\n    strategies.sort((a, b) => a.iterate.entropy(t) > b.iterate.entropy(t) ? 1 : -1);\n    return strategies[0];\n}\n\nexport class JoinSelection<TLeft = any, TRight = any> extends DataSourceBase<JoinRaw<TLeft, TRight>> {\n\n    private _columns: IValue<any>[] = [];\n    private seqScanExpression!: IValue<any>;\n    private joinId: number;\n    private columnsMappingParentToThis = new Map<IValue, IValue>();\n    private columnsMappingThisToParent = new Map<IValue, {\n        side: 'joined' | 'restrictive';\n        col: IValue;\n    }>();\n    private indexCache = new Map<IValue, _IIndex>();\n    strategies: JoinStrategy[] = [];\n    private building = false;\n    private ignoreDupes?: Set<IValue>;\n    private mergeSelect?: Selection;\n\n\n    isOriginOf(a: IValue<any>): boolean {\n        return this.joined.isOriginOf(a) || this.restrictive.isOriginOf(a);\n    }\n\n    get columns(): IValue<any>[] {\n        return this._columns;\n    }\n\n    entropy(t: _Transaction): number {\n        const strategy = chooseStrategy(t, this.strategies);\n        if (!strategy) {\n            // catastophic join... very high entropy...\n            return this.restrictive.entropy(t) * this.joined.entropy(t);\n        }\n\n        // todo: multiply that by the mean count per keys in strategy.joinIndex ?\n        const ret = strategy.iterate.entropy(t);\n        return ret;\n    }\n\n    constructor(db: _ISchema\n        , readonly restrictive: _ISelection<TLeft>\n        , readonly joined: _ISelection<TRight>\n        , on: JoinClause\n        , private innerJoin: boolean) {\n        super(db);\n\n\n        this.joinId = jCnt++;\n        for (const c of this.restrictive.listSelectableIdentities()) {\n            const nc = c.setWrapper(this, x => (x as any)['>restrictive']);\n            this.columnsMappingParentToThis.set(c, nc);\n            if (c.type.primary === DataType.record) {\n                continue;\n            }\n            this._columns.push(nc);\n            this.columnsMappingThisToParent.set(nc, {\n                col: c,\n                side: 'restrictive'\n            });\n        }\n        for (const c of this.joined.listSelectableIdentities()) {\n            const nc = c.setWrapper(this, x => (x as any)['>joined']);\n            this.columnsMappingParentToThis.set(c, nc);\n            if (c.type.primary === DataType.record) {\n                continue;\n            }\n            this._columns.push(nc);\n            this.columnsMappingThisToParent.set(nc, {\n                col: c,\n                side: 'joined',\n            });\n        }\n\n        if (on.on) {\n            this.fetchOnStrategies(on.on);\n        } else if (on.using?.length) {\n            this.fetchUsingStrategies(on.using);\n        } else {\n            throw new Error('Unspecified join ON clause');\n        }\n    }\n\n    private wrap(v: IValue) {\n        const ret = this.columnsMappingParentToThis.get(v);\n        if (!ret) {\n            throw new Error('Corrupted join (unknown column)');\n        }\n        return ret;\n    }\n\n    listSelectableIdentities(): Iterable<IValue> {\n        return this.columnsMappingParentToThis.values();\n    }\n\n    private fetchOnStrategies(_on: Expr) {\n        // build equalities eligible to a strategy\n        const ands: Equality[] = [];\n        const others: IValue[] = [];\n        for (const on of extractAnds(_on)) {\n            if (on.type !== 'binary' || on.op !== '=') {\n                // join 'ON' clause not compatible with an indexed strategy\n                others.push(buildValue(this, on));\n                continue;\n            }\n            this.building = true;\n            const left = buildValue(this, on.left);\n            const right = buildValue(this, on.right);\n            this.building = false;\n            // necessary because of the 'this.building' hack\n            uncache(this);\n            ands.push({\n                left,\n                right,\n                eq: buildValue(this, on),\n            });\n        }\n\n        // compute strategies\n        this.fetchAndStrategies(ands, others);\n\n\n        // build seq-scan expression\n        this.seqScanExpression = buildValue(this, _on).convert(Types.bool);\n    }\n\n    private fetchUsingStrategies(_using: Name[]) {\n        // build equalities eligible to a strategy\n        const ands = _using.map<Equality>(n => {\n            const left = this.restrictive.getColumn(n.name);\n            const right = this.joined.getColumn(n.name);\n            return {\n                left,\n                right,\n                eq: buildBinaryValue(this\n                    , this.wrap(left)\n                    , '='\n                    , this.wrap(right))\n            }\n        });\n        this.ignoreDupes = new Set(ands.map(x => this.wrap(x.left)));\n\n        // compute strategies\n        this.fetchAndStrategies(ands, []);\n\n        // build seq-scan expression\n        this.seqScanExpression = ands.slice(1)\n            .reduce((a, b) => buildBinaryValue(this, a, 'AND', b.eq), ands[0].eq);\n    }\n\n    private fetchAndStrategies(ands: Equality[], otherPredicates: IValue[]) {\n\n        for (let i = 0; i < ands.length; i++) {\n            const { left, right } = ands[i];\n            const strats = [...this.fetchEqStrategyOn(left, right)];\n            if (!strats.length) {\n                continue;\n            }\n            const others = [\n                ...ands.slice(0, i).map(x => x.eq),\n                ...ands.slice(i + 1).map(x => x.eq),\n                ...otherPredicates\n            ];\n            if (others.length) {\n                const and = others.slice(1)\n                    .reduce<IValue>((v, c) => buildBinaryValue(this, c, 'AND', v)\n                        , others[0]);\n                for (const s of strats) {\n                    s.othersPredicate = and;\n                }\n            }\n            this.strategies.push(...strats);\n        }\n    }\n\n    private *fetchEqStrategyOn(a: IValue, b: IValue): Iterable<JoinStrategy> {\n        let restrictedVal: IValue | undefined = undefined;\n        let joinedVal: IValue | undefined = undefined;\n\n        // const aIndex = a.wrappedOrigin?.getIndex()\n        if (this.restrictive.isOriginOf(a) && this.joined.isOriginOf(b)) {\n            restrictedVal = a;\n            joinedVal = b;\n        } else if (this.restrictive.isOriginOf(b) && this.joined.isOriginOf(a)) {\n            restrictedVal = b;\n            joinedVal = a;\n        }\n\n        let processInner = this.innerJoin;\n        let iterateSide: 'restrictive' | 'joined' = 'restrictive'\n        while (restrictedVal && joinedVal) {\n            // can always iterat on restricted value & use joined table foreign index\n            const jindex = joinedVal.index;\n            if (jindex && jindex.expressions.length === 1) {\n                yield {\n                    iterate: iterateSide === 'restrictive' ? this.restrictive : this.joined,\n                    iterateSide,\n                    onValue: restrictedVal,\n                    joinIndex: jindex,\n                }\n            }\n            if (!processInner) {\n                break;\n            }\n            // if is an inner join, then both sides can be interverted\n            processInner = false;\n            const t = restrictedVal;\n            restrictedVal = joinedVal;\n            joinedVal = t;\n            iterateSide = 'joined';\n        }\n    }\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue<any> | nil {\n        let onLeft = this.restrictive.getColumn(column, true);\n        let onRight = this.joined.getColumn(column, true);\n        if (!onLeft && !onRight) {\n            if (nullIfNotFound) {\n                return null;\n            }\n            throw new ColumnNotFound(colToStr(column));\n        }\n        if (!!onLeft && !!onRight) {\n            throw new QueryError(`column reference \"${colToStr(column)}\" is ambiguous`);\n        }\n        const on = onLeft ?? onRight;\n        if (this.building) {\n            return on;\n        }\n        const mapped = this.columnsMappingParentToThis.get(on!);\n        if (mapped) {\n            return mapped;\n        }\n        throw new Error('Corrupted join');\n    }\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<any> {\n        const strategy = chooseStrategy(t, this.strategies);\n        if (strategy) {\n            // choose the iterator that has less values\n            // find the right value using index\n            for (const l of strategy.iterate.enumerate(t)) {\n                yield* this.iterateStrategyItem(l, strategy, t);\n            }\n        } else {\n            // perform a seq scan\n            this.db.raiseGlobal('catastrophic-join-optimization');\n            const others = [...this.joined.enumerate(t)];\n            for (const l of this.restrictive.enumerate(t)) {\n                yield* this.iterateCatastrophicItem(l, others, 'restrictive', t);\n            }\n        }\n    }\n\n\n    selectAlias(alias: string): _IAlias | nil {\n        let onLeft = this.restrictive.selectAlias(alias);\n        let onRight = this.joined.selectAlias(alias);\n        if (!onLeft && !onRight) {\n            return null;\n        }\n        if (!!onLeft && !!onRight) {\n            throw new QueryError(`alias \"${alias}\" is ambiguous`);\n        }\n        return new JoinMapAlias(this, onLeft ?? onRight!, onLeft ? '>restrictive' : '>joined');\n    }\n\n    *iterateCatastrophicItem(item: any, others: any[], side: 'joined' | 'restrictive', t: _Transaction) {\n        const { template, buildItem } = this.builder(item, side);\n        let yielded = false;\n        for (const cr of others) {\n            const combined = buildItem(cr);\n            const result = this.seqScanExpression.get(combined, t);\n            if (result) {\n                yielded = true;\n                yield combined;\n            }\n        }\n        if (!this.innerJoin && !yielded) {\n            yield template;\n        }\n    }\n\n    private builder(item: any, side: 'joined' | 'restrictive') {\n\n        // if we're in an inner join, and the chosen strategy\n        // has inverted join order, then invert built items\n        let template: any;\n        let buildItem: (x: any) => any;\n        if (side === 'joined') {\n            buildItem = x => this.buildItem(x, item);\n            template = this.buildItem(null as any, item);\n        } else {\n            buildItem = x => this.buildItem(item, x);\n            template = this.buildItem(item, null as any);\n        }\n        return { buildItem, template };\n    }\n\n    *iterateStrategyItem(item: any, strategy: JoinStrategy, t: _Transaction) {\n\n        const { template, buildItem } = this.builder(item, strategy.iterateSide);\n\n        const joinValue = strategy.onValue.get(item, t);\n        let yielded = false;\n        if (!nullIsh(joinValue)) {\n            // get corresponding right value(s)\n            for (const o of strategy.joinIndex.enumerate({\n                type: 'eq',\n                key: [joinValue],\n                t,\n            })) {\n\n                // build item\n                const item = buildItem(o);\n\n                // check othre predicates (in case the join has an AND statement)\n                if (strategy.othersPredicate) {\n                    const others = strategy.othersPredicate.get(item, t);\n                    if (!others) {\n                        continue;\n                    }\n                }\n\n                // finally, yieldvalue\n                yielded = true;\n                yield item;\n            }\n        }\n\n        if (!this.innerJoin && !yielded) {\n            yield template;\n        }\n    }\n\n    buildItem(l: TLeft, r: TRight) {\n        const ret = {\n            '>joined': r,\n            '>restrictive': l,\n            [SELECT_ALL]: () => this.merge(ret),\n        }\n        setId(ret, `join${this.joinId}-${getId(l)}-${getId(r)}`);\n        return ret;\n    }\n\n    private merge(item: any) {\n        if (!this.mergeSelect) {\n            let sel = this.columns.map<CustomAlias>(val => ({ val }));\n            if (this.ignoreDupes) {\n                sel = sel.filter(t => !this.ignoreDupes?.has(t.val));\n            }\n            this.mergeSelect = new Selection(this, sel);\n        }\n\n        // nb: second argument is null... this is a hack : we KNOW it wont use the transaction.\n        const ret = this.mergeSelect.build(item, Symbol('hack') as any);\n        return ret;\n    }\n\n    hasItem(value: JoinRaw<TLeft, TRight>): boolean {\n        throw new NotSupported('lookups on joins');\n    }\n\n    getIndex(forValue: IValue<any>): _IIndex<any> | nil {\n        if (this.indexCache.has(forValue)) {\n            return this.indexCache.get(forValue);\n        }\n        // todo: filter using indexes of tables (index propagation)'\n        const mapped = this.columnsMappingThisToParent.get(forValue);\n        if (!mapped) {\n            return null;\n        }\n        const originIndex = mapped.col.index;\n        if (!originIndex) {\n            return null;\n        }\n        const ret = new JoinIndex(this, originIndex, mapped.side);\n        this.indexCache.set(forValue, ret);\n        return ret;\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        const strategy = chooseStrategy(e.transaction, this.strategies);\n        return {\n            id: e.idFor(this),\n            _: 'join',\n            restrictive: this.restrictive.explain(e),\n            joined: this.joined.explain(e),\n            inner: this.innerJoin,\n            on: strategy ? {\n                iterate: e.idFor(strategy.iterate),\n                iterateSide: strategy.iterateSide,\n                joinIndex: strategy.joinIndex.explain(e),\n                matches: strategy.onValue.explain(e),\n                ...strategy.othersPredicate ? { filtered: true } : {},\n            } : {\n                seqScan: this.seqScanExpression.explain(e),\n            },\n        };\n    }\n}\n\n\nclass JoinMapAlias implements _IAlias {\n\n\n    constructor(private owner: JoinSelection, private target: _IAlias, private map: string) {\n    }\n\n    *listColumns(): Iterable<IValue<any>> {\n        for (const c of this.target.listColumns()) {\n            yield c.setWrapper(this.owner, x => (x as any)[this.map]);\n        }\n    }\n}\n\nexport class JoinIndex<T> implements _IIndex<T> {\n    constructor(readonly owner: JoinSelection<T>, private base: _IIndex, private side: 'restrictive' | 'joined') {\n    }\n\n    get expressions(): IndexExpression[] {\n        return this.base.expressions;\n    }\n\n    stats(t: _Transaction, key?: IndexKey): Stats | null {\n        return null;\n    }\n\n    iterateKeys() {\n        return null;\n    }\n\n    entropy(op: IndexOp): number {\n        const strategy = this.chooseStrategy(op.t);\n        if (!strategy) {\n            // very high entropy (catastophic join)\n            return this.base.entropy(op) * this.other.entropy(op.t);\n        }\n        // todo: multiply that by the mean count per keys in strategy.joinIndex ?\n        return this.base.entropy(op);\n    }\n\n    eqFirst(rawKey: IndexKey, t: _Transaction): T | null {\n        for (const i of this.enumerate({\n            type: 'eq',\n            key: rawKey,\n            t,\n        })) {\n            return i;\n        }\n        return null;\n    }\n\n    private chooseStrategy(t: _Transaction) {\n        const strats = this.owner.strategies.filter(x => x.iterateSide === this.side);\n        if (!strats.length) {\n            return null;\n        }\n        return chooseStrategy(t, strats);\n    }\n\n    private get other() {\n        return this.side === 'joined'\n            ? this.owner.restrictive\n            : this.owner.joined;\n    }\n\n    *enumerate(op: IndexOp): Iterable<T> {\n        const strategy = this.chooseStrategy(op.t);\n        if (strategy) {\n            for (const i of this.base.enumerate(op)) {\n                yield* this.owner.iterateStrategyItem(i, strategy, op.t);\n            }\n        } else {\n            this.owner.db.raiseGlobal('catastrophic-join-optimization');\n            const all = [...this.other.enumerate(op.t)];\n\n            for (const i of this.base.enumerate(op)) {\n                yield* this.owner.iterateCatastrophicItem(i, all, this.side, op.t);\n            }\n        }\n    }\n\n\n    explain(e: _Explainer): _IndexExplanation {\n        const strat = this.chooseStrategy(e.transaction);\n        return {\n            _: 'indexOnJoin',\n            index: this.base.explain(e),\n            strategy: strat?.joinIndex?.explain(e) ?? 'catastrophic',\n        }\n    }\n}","import { IMemoryTable, Schema, QueryError, TableEvent, PermissionDeniedError, NotSupported, IndexDef, ColumnNotFound, ISubscription, nil, DataType } from './interfaces';\nimport { _ISelection, IValue, _ITable, setId, getId, CreateIndexDef, CreateIndexColDef, _IDb, _Transaction, _ISchema, _Column, _IType, SchemaField, _IIndex, _Explainer, _SelectExplanation, ChangeHandler, Stats, OnConflictHandler, DropHandler, IndexHandler, asIndex, RegClass, RegType, Reg, ChangeOpts } from './interfaces-private';\nimport { buildValue } from './expression-builder';\nimport { BIndex } from './btree-index';\nimport { columnEvaluator } from './transforms/selection';\nimport { nullIsh, deepCloneSimple, Optional, indexHash, findTemplate, colByName } from './utils';\nimport { Map as ImMap } from 'immutable';\nimport { CreateColumnDef, TableConstraintForeignKey, TableConstraint, Expr, BinaryOperator, ExprRef } from 'pgsql-ast-parser';\nimport { ColRef } from './column';\nimport { buildAlias, Alias } from './transforms/alias';\nimport { DataSourceBase } from './transforms/transform-base';\nimport { parseSql } from './parse-cache';\nimport { ForeignKey } from './constraints/foreign-key';\nimport { Types } from './datatypes';\n\n\ntype Raw<T> = ImMap<string, T>;\n\n\ninterface ChangeSub<T> {\n    before: Set<ChangeHandler<T>>;\n    after: Set<ChangeHandler<T>>;\n}\n\ninterface ChangePlan<T> {\n    before(): void\n    after(): void;\n}\n\nclass ColumnManager {\n    private _columns?: readonly IValue[];\n    readonly map = new Map<string, ColRef>();\n\n    get columns(): readonly IValue[] {\n        if (!this._columns) {\n            this._columns = Object.freeze(Array.from(this.map.values(), c => c.expression));\n        }\n        return this._columns!;\n    }\n    invalidateColumns() {\n        this._columns = undefined;\n    }\n\n    // Pass-through methods\n    get = this.map.get.bind(this.map);\n    has = this.map.has.bind(this.map)\n    values = this.map.values.bind(this.map);\n\n    set(name: string, colDef: ColRef) {\n        this.invalidateColumns();\n        return this.map.set(name, colDef);\n    }\n\n    delete(name: string) {\n        this.invalidateColumns();\n        return this.map.delete(name);\n    }\n}\n\nexport class MemoryTable<T = any> extends DataSourceBase<T> implements IMemoryTable, _ITable<T> {\n\n\n    private handlers = new Map<TableEvent, Set<() => void>>();\n    readonly selection: Alias<T>;\n    private _reg?: Reg;\n    get reg(): Reg {\n        if (!this._reg) {\n            throw new QueryError(`relation \"${this.name}\" does not exist`);\n        }\n        return this._reg;\n    }\n    get columns() {\n        return this.columnMgr.columns;\n    }\n    private it = 0;\n    private cstGen = 0;\n    hasPrimary = false;\n    private readonly = false;\n    hidden = false;\n    private dataId = Symbol();\n    private serialsId: symbol = Symbol();\n    private indexByHash = new Map<string, {\n        index: BIndex<T>;\n        expressions: IValue[];\n    }>();\n    readonly columnMgr = new ColumnManager();\n    name: string;\n\n    private changeHandlers = new Map<_Column | null, ChangeSub<T>>();\n    private truncateHandlers = new Set<DropHandler>();\n    private drophandlers = new Set<DropHandler>();\n    private indexHandlers = new Set<IndexHandler>();\n\n    get type() {\n        return 'table' as const;\n    }\n\n    get debugId() {\n        return this.name;\n    }\n\n    entropy(t: _Transaction) {\n        return this.bin(t).size;\n    }\n\n    isOriginOf(a: IValue<any>): boolean {\n        return a.origin === this.selection;\n    }\n\n    constructor(schema: _ISchema, t: _Transaction, _schema: Schema) {\n        super(schema);\n        this.name = _schema.name;\n        this.selection = buildAlias(this, this.name) as Alias<T>;\n\n        // fields\n        for (const s of _schema.fields) {\n            this.addColumn(s, t);\n        }\n\n\n        // other table constraints\n        for (const c of _schema.constraints ?? []) {\n            this.addConstraint(c, t);\n        }\n    }\n\n    register() {\n        // once fields registered,\n        //  then register the table\n        //  (column registrations need it not to be registered yet)\n        this._reg = this.ownerSchema._reg_register(this);\n        return this;\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return {\n            count: this.bin(t).size,\n        };\n    }\n\n    rename(name: string) {\n        const on = this.name;\n        if (on === name) {\n            return this;\n        }\n        this.name = name;\n        this.ownerSchema._reg_rename(this, on, name);\n        (this.selection as Alias<T>).name = this.name;\n        this.db.onSchemaChange();\n        return this;\n    }\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue<any> | nil {\n        return colByName(this.columnMgr.map, column, nullIfNotFound)\n            ?.expression;\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            _: 'table',\n            table: this.name,\n        };\n    }\n\n    addColumn(column: SchemaField | CreateColumnDef, t: _Transaction): _Column {\n        if ('dataType' in column) {\n            const tp: SchemaField = {\n                ...column,\n                name: column.name.name,\n                type: this.ownerSchema.getType(column.dataType),\n            };\n            delete (tp as any as Optional<CreateColumnDef>).dataType;\n            return this.addColumn(tp, t);\n        }\n\n        if (this.columnMgr.has(column.name)) {\n            throw new QueryError(`Column \"${column.name}\" already exists`);\n        }\n        const type = typeof column.type === 'string'\n            ? this.ownerSchema.getType(column.type)\n            : column.type;\n        const cref = new ColRef(this, columnEvaluator(this.selection, column.name, type as _IType), column, column.name);\n\n\n        // auto increments\n        if (column.serial) {\n            t.set(this.serialsId, t.getMap(this.serialsId).set(column.name, 0));\n        }\n\n        this.columnMgr.set(column.name, cref);\n\n        try {\n            if (column.constraints?.length) {\n                cref.addConstraints(column.constraints, t);\n            }\n            const hasDefault = column.constraints?.some(x => x.type === 'default');\n            if (!hasDefault) {\n                this.remapData(t, x => (x as any)[column.name] = (x as any)[column.name] ?? null);\n            }\n        } catch (e) {\n            this.columnMgr.delete(column.name);\n            throw e;\n        }\n\n        // once constraints created, reference them. (constraint creation might have thrown)m\n        this.db.onSchemaChange();\n        this.selection.rebuild();\n        return cref;\n    }\n\n\n    getColumnRef(column: string): ColRef;\n    getColumnRef(column: string, nullIfNotFound?: boolean): ColRef | nil;\n    getColumnRef(column: string, nullIfNotFound?: boolean): ColRef | nil {\n        const got = this.columnMgr.get(column);\n        if (!got) {\n            if (nullIfNotFound) {\n                return null;\n            }\n            throw new QueryError(`Column \"${column}\" not found`);\n        }\n        return got;\n    }\n\n    bin(t: _Transaction) {\n        return t.getMap<Raw<T>>(this.dataId);\n    }\n\n    setBin(t: _Transaction, val: Raw<T>) {\n        return t.set(this.dataId, val);\n    }\n\n    on(event: TableEvent, handler: () => any): ISubscription {\n        let lst = this.handlers.get(event);\n        if (!lst) {\n            this.handlers.set(event, lst = new Set());\n        }\n        lst.add(handler);\n        return {\n            unsubscribe: () => lst!.delete(handler),\n        };\n    }\n\n    raise(event: TableEvent) {\n        const got = this.handlers.get(event);\n        for (const h of got ?? []) {\n            h();\n        }\n        this.db.raiseTable(this.name, event);\n    }\n\n    setReadonly() {\n        this.readonly = true;\n        return this;\n    }\n    setHidden() {\n        this.hidden = true;\n        return this;\n    }\n\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        this.raise('seq-scan');\n        for (const v of this.bin(t).values()) {\n            yield deepCloneSimple(v); // copy the original data to prevent it from being mutated.\n        }\n    }\n\n    find(template?: T, columns?: (keyof T)[]): Iterable<T> {\n        return findTemplate(this.selection, this.db.data, template, columns);\n    }\n\n    remapData(t: _Transaction, modify: (newCopy: T) => any) {\n        // convert raw data ( must copy the whole thing,\n        // because it can throw in the middle of this process !)\n        //  => this would result in partially converted tables.\n        const converted = this.bin(t).map(x => {\n            const copy = { ...x };\n            modify(copy);\n            return copy;\n        });\n        this.setBin(t, converted);\n    }\n\n    insert(toInsert: T): T {\n        const ret = this.doInsert(this.db.data, deepCloneSimple(toInsert));\n        return deepCloneSimple(ret);\n    }\n\n    doInsert(t: _Transaction, toInsert: T, opts?: ChangeOpts): T {\n        if (this.readonly) {\n            throw new PermissionDeniedError(this.name);\n        }\n\n        // get ID of this item\n        const newId = this.name + '_' + (this.it++);\n        setId(toInsert, newId);\n\n        // serial (auto increments) columns\n        let serials = t.getMap(this.serialsId);\n        for (const [k, v] of serials.entries()) {\n            if (!nullIsh((toInsert as any)[k])) {\n                continue;\n            }\n            (toInsert as any)[k] = v + 1;\n            serials = serials.set(k, v + 1);\n        }\n        t.set(this.serialsId, serials);\n\n        // set default values\n        for (const c of this.columnMgr.values()) {\n            c.setDefaults(toInsert, t);\n        }\n\n        // check change handlers (foreign keys)\n        const changePlan = this.changePlan(t, null, toInsert, opts);\n        changePlan.before();\n\n        // check \"on conflict\"\n        const onConflict = opts?.onConflict;\n        if (onConflict) {\n            if ('ignore' in onConflict) {\n                if (onConflict.ignore === 'all') {\n                    for (const k of this.indexByHash.values()) {\n                        const found = k.index.eqFirst(k.index.buildKey(toInsert, t), t);\n                        if (found) {\n                            return found; // ignore.\n                        }\n                    }\n                } else {\n                    const index = onConflict.ignore as BIndex;\n                    const found = index.eqFirst(index.buildKey(toInsert, t), t);\n                    if (found) {\n                        return found; // ignore.\n                    }\n                }\n            } else {\n                const index = onConflict.onIndex as BIndex;\n                const key = index.buildKey(toInsert, t);\n                const got = index.eqFirst(key, t);\n                if (got) {\n                    // update !\n                    onConflict.update(got, toInsert);\n                    return this.update(t, got);\n                }\n            }\n        }\n\n        // check constraints\n        for (const c of this.columnMgr.values()) {\n            c.checkConstraints(toInsert, t);\n        }\n\n        // check change handlers (foreign keys)\n        changePlan.after();\n\n        // index & check indx contrainsts\n        this.indexElt(t, toInsert);\n        this.setBin(t, this.bin(t).set(newId, toInsert));\n        return toInsert;\n    }\n\n    private changePlan(t: _Transaction, old: T | null, neu: T | null, _opts: ChangeOpts | nil): ChangePlan<T> {\n        const opts = _opts ?? {};\n        let iter: () => IterableIterator<ChangeSub<T>>;\n        if (!old || !neu) {\n            iter = () => this.changeHandlers.values();\n        } else {\n            const ret: ChangeSub<T>[] = [];\n            const global = this.changeHandlers.get(null);\n            if (global) {\n                ret.push(global);\n            }\n            for (const def of this.columnMgr.values()) {\n                const h = this.changeHandlers.get(def);\n                if (!h) {\n                    continue;\n                }\n                const oldVal = (old as any)[def.expression.id!];\n                const neuVal = (neu as any)[def.expression.id!];\n                if (def.expression.type.equals(oldVal, neuVal)) {\n                    continue;\n                }\n                ret.push(h);\n            }\n            iter = ret[Symbol.iterator].bind(ret);\n        }\n        return {\n            before: () => {\n                const ran = new Set();\n                for (const { before } of iter()) {\n                    for (const b of before) {\n                        if (!b || ran.has(b)) {\n                            continue;\n                        }\n                        b(old, neu, t, opts);\n                        ran.add(b);\n                    }\n                }\n            },\n            after: () => {\n                const ran = new Set();\n                for (const { after } of iter()) {\n                    for (const a of after) {\n                        if (!a || ran.has(a)) {\n                            continue;\n                        }\n                        a(old, neu, t, opts);\n                        ran.add(a);\n                    }\n                }\n            },\n        }\n    }\n\n    update(t: _Transaction, toUpdate: T): T {\n        if (this.readonly) {\n            throw new PermissionDeniedError(this.name);\n        }\n        const bin = this.bin(t);\n        const id = getId(toUpdate);\n        const exists = bin.get(id) ?? null;\n\n        // set default values\n        for (const c of this.columnMgr.values()) {\n            c.setDefaults(toUpdate, t);\n        }\n\n\n\n        // check change handlers (foreign keys)\n        const changePlan = this.changePlan(t, exists, toUpdate, null);\n        changePlan.before();\n        changePlan.after();\n\n\n        // check constraints\n        for (const c of this.columnMgr.values()) {\n            c.checkConstraints(toUpdate, t);\n        }\n\n        // remove old version from index\n        if (exists) {\n            for (const k of this.indexByHash.values()) {\n                k.index.delete(exists, t);\n            }\n        }\n\n        // add new version to index\n        this.indexElt(t, toUpdate);\n\n        // store raw\n        this.setBin(t, bin.delete(id).set(id, toUpdate));\n        return toUpdate;\n    }\n\n    delete(t: _Transaction, toDelete: T) {\n        const id = getId(toDelete);\n        const bin = this.bin(t);\n        const got = bin.get(id);\n        if (!id || !got) {\n            throw new Error('Unexpected error: an operation has been asked on an item which does not belong to this table');\n        }\n\n        // check change handlers (foreign keys)\n        const changePlan = this.changePlan(t, toDelete, null, null);\n        changePlan.before();\n        changePlan.after();\n\n        // remove from indices\n        for (const k of this.indexByHash.values()) {\n            k.index.delete(got, t);\n        }\n        this.setBin(t, bin.delete(id));\n\n        return got;\n    }\n\n    truncate(t: _Transaction): void {\n        // call truncate handlers\n        for (const h of this.truncateHandlers) {\n            h(t);\n        }\n        // truncate indices\n        for (const k of this.indexByHash.values()) {\n            k.index.truncate(t);\n        }\n        this.setBin(t, ImMap());\n    }\n\n\n    private indexElt(t: _Transaction, toInsert: T) {\n        for (const k of this.indexByHash.values()) {\n            k.index.add(toInsert, t);\n        }\n    }\n\n    hasItem(item: T, t: _Transaction) {\n        const id = getId(item);\n        return this.bin(t).has(id);\n    }\n\n    getIndex(...forValues: IValue[]): _IIndex | nil {\n        if (!forValues.length || forValues.some(x => !x || !this.isOriginOf(x))) {\n            return null;\n        }\n        const ihash = indexHash(forValues);\n        const got = this.indexByHash.get(ihash);\n        return got?.index ?? null;\n    }\n\n    constraintNameGen(constraintName?: string) {\n        return constraintName\n            ?? (this.name + '_constraint_' + (++this.cstGen));\n    }\n\n    addCheck(_t: _Transaction, check: Expr, constraintName?: string) {\n        constraintName = this.constraintNameGen(constraintName);\n        const getter = buildValue(this.selection, check).convert(Types.bool);\n\n        const checkVal = (t: _Transaction, v: any) => {\n            const value = getter.get(v, t);\n            if (value === false) {\n                throw new QueryError(`check constraint \"${constraintName}\" is violated by some row`)\n            }\n        }\n\n        // check that everything matches (before adding check)\n        for (const v of this.enumerate(_t)) {\n            checkVal(_t, v);\n        }\n\n        // add a check for future updates\n        this.onBeforeChange([], (old, neu, ct) => {\n            if (!neu) {\n                return;\n            }\n            checkVal(ct, neu);\n        });\n    }\n\n\n    createIndex(t: _Transaction, expressions: CreateIndexDef): this;\n    createIndex(t: _Transaction, expressions: string[], type: 'primary' | 'unique', indexName?: string): this;\n    createIndex(t: _Transaction, expressions: string[] | CreateIndexDef, _type?: 'primary' | 'unique', _indexName?: string): this {\n        if (this.readonly) {\n            throw new PermissionDeniedError(this.name);\n        }\n        if (Array.isArray(expressions)) {\n            const keys: CreateIndexColDef[] = [];\n            for (const e of expressions) {\n                const parsed = parseSql(e, 'expr');\n                const getter = buildValue(this.selection, parsed);\n                keys.push({\n                    value: getter,\n                });\n            }\n            return this.createIndex(t, {\n                columns: keys,\n                primary: _type === 'primary',\n                notNull: _type === 'primary',\n                unique: !!_type,\n                indexName: _indexName,\n            });\n        }\n\n        if (!expressions?.columns?.length) {\n            throw new QueryError('Empty index');\n        }\n\n        if (expressions.primary && this.hasPrimary) {\n            throw new QueryError('Table ' + this.name + ' already has a primary key');\n        }\n        if (expressions.primary) {\n            expressions.notNull = true;\n            expressions.unique = true;\n        }\n\n\n        const ihash = indexHash(expressions.columns.map(x => x.value));\n\n        const indexName = this.determineIndexRelName(expressions.indexName, ihash, expressions.ifNotExists, 'idx');\n        if (!indexName) {\n            return this;\n        }\n\n\n        const index = new BIndex(t, indexName, expressions.columns, this, ihash, !!expressions.unique, !!expressions.notNull);\n\n        // fill index (might throw if constraint not respected)\n        const bin = this.bin(t);\n        for (const e of bin.values()) {\n            index.add(e, t);\n        }\n\n        // =========== reference index ============\n        this.indexHandlers.forEach(h => h('create', index));\n        //  This must be done LAST, to avoid throwing an execption if index population failed\n        for (const col of index.expressions) {\n            for (const used of col.usedColumns) {\n                this.getColumnRef(used.id!).usedInIndexes.add(index);\n            }\n        }\n        this.indexByHash.set(ihash, { index, expressions: index.expressions });\n        if (expressions.primary) {\n            this.hasPrimary = true;\n        }\n        return this;\n    }\n\n    private determineIndexRelName(indexName: string | nil, ihash: string, ifNotExists: boolean | nil, sufix: string): string | nil {\n        if (indexName) {\n            if (this.ownerSchema.getOwnObject(indexName)) {\n                if (ifNotExists) {\n                    return null;\n                }\n                throw new QueryError(`relation \"${indexName}\" already exists`);\n            }\n            return indexName;\n        } else {\n            const baseName = indexName = `${this.name}_${ihash}_${sufix}`;\n            let i = 1;\n            while (this.ownerSchema.getOwnObject(indexName)) {\n                indexName = baseName + (i++);\n            }\n            return indexName!;\n        }\n    }\n\n    dropIndex(t: _Transaction, uName: string) {\n        const u = asIndex(this.ownerSchema.getOwnObject(uName)) as BIndex;\n        if (!u || !this.indexByHash.has(u.hash)) {\n            throw new QueryError('Cannot drop index that does not belong to this table: ' + uName);\n        }\n        this.indexHandlers.forEach(h => h('drop', u));\n        this.indexByHash.delete(u.hash);\n        u.dropFromData(t);\n        this.ownerSchema._reg_unregister(u);\n    }\n\n\n    onIndex(sub: IndexHandler): ISubscription {\n        this.indexHandlers.add(sub);\n        return {\n            unsubscribe: () => this.indexHandlers.delete(sub),\n        };\n    }\n\n    listIndices(): IndexDef[] {\n        return [...this.indexByHash.values()]\n            .map<IndexDef>(x => ({\n                name: x.index.name!,\n                expressions: x.expressions.map(x => x.id!),\n            }));\n    }\n\n    addForeignKey(cst: TableConstraintForeignKey, t: _Transaction) {\n        const ihash = indexHash(cst.localColumns.map(x => x.name));\n        const constraintName = this.determineIndexRelName(cst.constraintName?.name, ihash, false, 'fk');\n        if (!constraintName) {\n            return this;\n        }\n        const got = new ForeignKey(constraintName)\n            .install(t, cst, this);\n\n        // todo;\n        return this;\n    }\n\n    addConstraint(cst: TableConstraint, t: _Transaction) {\n        // todo add constraint name\n        switch (cst.type) {\n            case 'foreign key':\n                return this.addForeignKey(cst, t);\n            case 'primary key':\n                return this.createIndex(t, cst.columns.map(x => x.name), 'primary', cst.constraintName?.name);\n            case 'unique':\n                return this.createIndex(t, cst.columns.map(x => x.name), 'unique', cst.constraintName?.name);\n            case 'check':\n                return this.addCheck(t, cst.expr, cst.constraintName?.name);\n            default:\n                throw NotSupported.never(cst, 'constraint type');\n        }\n    }\n\n    onBeforeChange(columns: (string | _Column)[], check: ChangeHandler<T>): ISubscription {\n        return this._subChange('before', columns, check);\n    }\n    onCheckChange(columns: string[], check: ChangeHandler<T>): ISubscription {\n        return this._subChange('before', columns, check);\n    }\n\n    private _subChange(key: keyof ChangeSub<T>, columns: (string | _Column)[], check: ChangeHandler<T>): ISubscription {\n        const unsubs: (() => void)[] = [];\n        for (const c of columns) {\n            const ref = typeof c === 'string'\n                ? this.getColumnRef(c)\n                : c;\n\n            let ch = this.changeHandlers.get(ref);\n            if (!ch) {\n                this.changeHandlers.set(ref, ch = {\n                    after: new Set(),\n                    before: new Set(),\n                });\n            }\n            ch[key].add(check);\n            unsubs.push(() => ch![key].delete(check));\n        }\n        return {\n            unsubscribe: () => {\n                for (const u of unsubs) {\n                    u();\n                }\n            }\n        }\n    }\n\n\n    drop(t: _Transaction) {\n        this.drophandlers.forEach(d => d(t));\n        t.delete(this.dataId);\n        for (const i of this.indexByHash.values()) {\n            i.index.dropFromData(t);\n        }\n        // todo should also check foreign keys, cascade, ...\n        return this.ownerSchema._reg_unregister(this);\n    }\n\n    onDrop(sub: DropHandler): ISubscription {\n        this.drophandlers.add(sub);\n        return {\n            unsubscribe: () => {\n                this.drophandlers.delete(sub);\n            }\n        }\n    }\n\n    onTruncate(sub: DropHandler): ISubscription {\n        this.truncateHandlers.add(sub);\n        return {\n            unsubscribe: () => {\n                this.truncateHandlers.delete(sub);\n            }\n        }\n\n    }\n}\n","import { IValue, _IIndex, _ITable, getId, IndexKey, CreateIndexColDef, _Transaction, _Explainer, _IndexExplanation, IndexExpression, IndexOp, Stats, _INamedIndex, Reg, _ISchema } from './interfaces-private';\n// @ts-ignore\nimport createTree from 'functional-red-black-tree';\nimport { QueryError, NotSupported, nil } from './interfaces';\nimport { Set as ImSet, Map as ImMap } from 'immutable';\nimport { deepCloneSimple, nullIsh } from './utils';\n\n\n// https://www.npmjs.com/package/functional-red-black-tree\ninterface BTree<T> {\n    readonly keys: Iterable<IndexKey>;\n    readonly values: Iterable<IndexKey>;\n    readonly length: number;\n    get(key: IndexKey): T;\n    insert(key: IndexKey, value: T): BTree<T>;\n    remove(key: IndexKey): BTree<T>;\n    find(key: IndexKey): BIterator<T>;\n    /** Find the first item in the tree whose key is >= key */\n    ge(key: IndexKey): BIterator<T>;\n    /** Finds the first item in the tree whose key is > key */\n    gt(key: IndexKey): BIterator<T>;\n    /** Finds the last item in the tree whose key is < key */\n    lt(key: IndexKey): BIterator<T>;\n    /** Finds the last item in the tree whose key is <= key */\n    le(key: IndexKey): BIterator<T>;\n\n    at(pos: number): BIterator<T>;\n\n    readonly begin: BIterator<T>;\n    readonly end: BIterator<T>;\n    /**  If a truthy value is returned from the visitor, then iteration is stopped. */\n    forEach(fn: (key: IndexKey, value: T) => boolean, low?: number, high?: number): void;\n    // root;\n}\n\ninterface BIterator<T> {\n    readonly key: IndexKey;\n    readonly value: T;\n    // tree;\n    readonly index: any;\n    readonly valid: boolean;\n    clone(): BIterator<T>;\n    remove(): BTree<T>;\n    update(value: T): BTree<T>;\n    next(): void;\n    prev(): void;\n    readonly hasNext: boolean;\n    readonly hasPrev: boolean;\n}\n\ntype RawTree<T> = BTree<ImMap<string, T>>;;\nexport class BIndex<T = any> implements _INamedIndex<T> {\n\n    get type(): 'index' {\n        return 'index';\n    }\n\n    readonly reg: Reg;\n\n    // private asBinary: RawTree;\n    expressions: (IndexExpression & IValue)[];\n    private treeBinId = Symbol();\n    private treeCountId = Symbol();\n\n\n    get ownerSchema(): _ISchema {\n        return this.onTable.ownerSchema;\n    }\n\n    constructor(t: _Transaction\n        , readonly name: string\n        , private cols: CreateIndexColDef[]\n        , readonly onTable: _ITable<T>\n        , readonly hash: string\n        , readonly unique: boolean\n        , readonly notNull: boolean) {\n        this.reg = onTable.ownerSchema._reg_register(this);\n        this.truncate(t);\n        this.expressions = cols.map(x => x.value);\n    }\n\n    drop(t: _Transaction): void {\n        this.onTable.dropIndex(t, this.name);\n    }\n\n    compare(_a: any, _b: any) {\n        for (let i = 0; i < this.expressions.length; i++) {\n            const k = this.cols[i];\n            const a = _a[i];\n            const b = _b[i];\n            if (a === null || b === null) {\n                if (a === b) {\n                    continue;\n                }\n                return (a === null\n                    ? -1\n                    : 1) * (k.nullsLast ? 1 : -1);\n            }\n            if (k.value.type.equals(a, b)) {\n                continue;\n            }\n            return (k.value.type.gt(a, b)\n                ? 1\n                : -1)// * (k.desc ? -1 : 1);\n        }\n        return 0;\n    }\n\n    buildKey(raw: any, t: _Transaction) {\n        return this.expressions.map(k => k.get(raw, t));\n    }\n\n    truncate(t: _Transaction) {\n        const asBinary = createTree((a: any, b: any) => {\n            return this.compare(a, b);\n        });\n        this.setBin(t, asBinary);\n    }\n\n    dropFromData(t: _Transaction) {\n        t.delete(this.treeBinId);\n    }\n\n    private bin(t: _Transaction) {\n        return t.get<RawTree<T>>(this.treeBinId);\n    }\n    private setBin(t: _Transaction, val: RawTree<T>) {\n        return t.set(this.treeBinId, val);\n    }\n\n    private setCount(t: _Transaction, val: number) {\n        return t.set(this.treeCountId, val);\n    }\n    private getCount(t: _Transaction): number {\n        return t.get<number>(this.treeCountId) ?? 0;\n    }\n\n    hasKey(key: IndexKey[], t: _Transaction): boolean {\n        const it = this.bin(t).find(key);\n        return it.valid;\n    }\n\n    add(raw: T, t: _Transaction) {\n        // build key and object id\n        const id = getId(raw);\n        const key = this.buildKey(raw, t);\n        if (this.notNull && key.some(x => nullIsh(x))) {\n            throw new QueryError('Cannot add a null record in index ' + this.name);\n        }\n        if (this.unique && this.hasKey(key, t)) {\n            const idCols = this.cols.map(it => it.value.id);\n            throw new QueryError({\n                error: `insert into \"${this.onTable.name}\" (${Object.keys(raw).join(', ')}) `\n                    + `values (${Object.keys(raw).map((_, i) => `$${i + 1}`).join(', ')}) returning \"${idCols}\" `\n                    + `- duplicate key value violates unique constraint \"${this.onTable.name}_pkey\"`,\n                details: `Key (${idCols})=(${key}) already exists.`,\n                code: '23505'\n            });\n        }\n        // get tree\n        let tree = this.bin(t);\n        // get key in tree\n        let keyValues = tree.find(key);\n        if (keyValues.valid) {\n            if (keyValues.value.has(id)) {\n                return; // already exists\n            }\n            tree = keyValues.update(keyValues.value.set(id, raw));\n        } else {\n            tree = tree.insert(key, ImMap<string, T>().set(id, raw));\n        }\n        this.setBin(t, tree);\n        this.setCount(t, this.getCount(t) + 1);\n\n    }\n\n    delete(raw: any, t: _Transaction) {\n        const key = this.buildKey(raw, t);\n        let tree = this.bin(t);\n        let keyValues = tree.find(key);\n        if (!keyValues.valid) {\n            return; // key does not exists\n        }\n        const id = getId(raw);\n        if (!keyValues.value.has(id)) {\n            return; // element does not exists\n        }\n        const newKeyValues = keyValues.value.delete(id);\n        if (!newKeyValues.size) {\n            tree = keyValues.remove();\n        } else {\n            tree = keyValues.update(newKeyValues);\n        }\n        this.setBin(t, tree);\n        this.setCount(t, this.getCount(t) - 1);\n    }\n\n    eqFirst(rawKey: IndexKey, t: _Transaction): T | null {\n        for (const r of this.eq(rawKey, t, false)) {\n            return deepCloneSimple(r);\n        }\n        return null;\n    }\n\n\n    *nin(rawKey: IndexKey[], t: _Transaction): Iterable<T> {\n        rawKey.sort((a, b) => this.compare(a, b));\n        const kit = rawKey[Symbol.iterator]();\n        let cur = kit.next();\n        const bin = this.bin(t);\n        let it = bin.begin;\n        while (!cur.done) {\n            // yield previous\n            while (it.valid && this.compare(it.key, cur.value) < 0) {\n                yield* it.value.values();\n                it.next();\n            }\n            // skip equals\n            if (this.compare(it.key, cur.value) === 0) {\n                it = bin.gt(cur.value);\n            }\n            cur = kit.next();\n        }\n\n        // finish\n        while (it.valid) {\n            yield* it.value.values();\n            it.next();\n        }\n    }\n\n\n    entropy(op: IndexOp) {\n        const bin = this.bin(op.t);\n        if (!bin.length) {\n            return 0;\n        }\n        const all = op.t.get<number>(this.treeCountId) ?? 0;\n        // evaluate number of keys included in this operation\n        const e = this._keyCount(op);\n        // multiply by average values per key\n        return e * all / bin.length;\n    }\n\n    stats(t: _Transaction, key?: IndexKey): Stats {\n        if (!key) {\n            return {\n                count: t.get<number>(this.treeCountId) ?? 0,\n            };\n        }\n        const found = this.bin(t).get(key);\n        return {\n            count: found?.size ?? 0,\n        };\n    }\n\n    iterateKeys(t: _Transaction): Iterable<IndexKey> {\n        const bin = this.bin(t);\n        return bin.keys;\n    }\n\n\n    private _keyCount(op: IndexOp) {\n        const bin = this.bin(op.t);\n        switch (op.type) {\n            case 'eq': {\n                const begin = bin.find(op.key);\n                if (!begin.valid) {\n                    return 0;\n                }\n                const end = bin.gt(op.key);\n                if (!end.valid) {\n                    return bin.length - begin.index;\n                }\n                return end.index - begin.index + 1;\n            }\n            case 'neq': {\n                let cnt = 0;\n                const first = bin.find(op.key);\n                if (!first.valid) {\n                    return bin.length;\n                }\n                cnt += first.valid\n                    ? first.index\n                    : 0;\n                const end = bin.gt(op.key);\n                cnt += end.valid\n                    ? (bin.length - end.index)\n                    : 0;\n                return cnt;\n            }\n            case 'ge': {\n                const found = bin.ge(op.key);\n                return found.valid\n                    ? (bin.length - found.index)\n                    : 0;\n            }\n            case 'gt': {\n                const found = bin.gt(op.key);\n                return found.valid\n                    ? (bin.length - found.index)\n                    : 0;\n            }\n            case 'le': {\n                const found = bin.gt(op.key);\n                return found.valid\n                    ? found.index\n                    : bin.length;\n            }\n            case 'lt': {\n                const found = bin.ge(op.key);\n                return found.valid\n                    ? found.index\n                    : bin.length;\n            }\n            case 'inside': {\n                const begin = bin.ge(op.lo);\n                if (!begin.valid) {\n                    return 0;\n                }\n                const end = bin.gt(op.hi);\n                if (!end.valid) {\n                    return bin.length - begin.index;\n                }\n                return end.index - begin.index;\n            }\n            case 'outside': {\n                let cnt = 0;\n                const first = bin.lt(op.lo);\n                cnt += first.valid\n                    ? first.index + 1\n                    : 0;\n                const end = bin.gt(op.hi);\n                cnt += end.valid\n                    ? (bin.length - end.index)\n                    : 0;\n                return cnt;\n            }\n            case 'nin': {\n                let cnt = bin.length;\n                for (const e of op.keys) {\n                    const f = bin.find(e);\n                    if (f.valid) {\n                        cnt--;\n                    }\n                }\n                return cnt;\n            }\n            default:\n                throw NotSupported.never(op['type']);\n        }\n    }\n\n    *enumerate(op: IndexOp): Iterable<T> {\n        for (const x of this._enumerate(op)) {\n            yield deepCloneSimple(x);\n        }\n    }\n    private _enumerate(op: IndexOp): Iterable<T> {\n        switch (op.type) {\n            case 'eq':\n                return this.eq(op.key, op.t, op.matchNull!);\n            case 'neq':\n                return this.neq(op.key, op.t, op.matchNull!);\n            case 'ge':\n                return this.ge(op.key, op.t);\n            case 'le':\n                return this.le(op.key, op.t);\n            case 'gt':\n                return this.gt(op.key, op.t);\n            case 'lt':\n                return this.lt(op.key, op.t);\n            case 'outside':\n                return this.outside(op.lo, op.hi, op.t);\n            case 'inside':\n                return this.inside(op.lo, op.hi, op.t);\n            case 'nin':\n                return this.nin(op.keys, op.t);\n            default:\n                throw NotSupported.never(op['type']);\n        }\n    }\n\n    *eq(key: IndexKey, t: _Transaction, matchNull: boolean): Iterable<T> {\n        if (!matchNull && key.some(nullIsh)) {\n            return;\n        }\n        const it = this.bin(t).find(key);\n        while (it.valid && this.compare(it.key, key) === 0) {\n            yield* it.value.values();\n            it.next();\n        }\n    }\n\n\n\n    *neq(key: IndexKey, t: _Transaction, matchNull: boolean): Iterable<T> {\n        if (!matchNull && key.some(nullIsh)) {\n            return;\n        }\n        // yield before\n        const bin = this.bin(t);\n        let it = bin.begin;\n        while (it.valid && this.compare(it.key, key) < 0) {\n            yield* it.value.values();\n            it.next();\n        }\n        // yield after\n        it = bin.gt(key);\n        while (it.valid) {\n            yield* it.value.values();\n            it.next();\n        }\n    }\n\n    *gt(key: IndexKey, t: _Transaction): Iterable<T> {\n        const it = this.bin(t).gt(key);\n        while (it.valid) {\n            yield* it.value.values();\n            it.next();\n        }\n    }\n\n    *ge(key: IndexKey, t: _Transaction): Iterable<T> {\n        const it = this.bin(t).ge(key);\n        while (it.valid) {\n            yield* it.value.values();\n            it.next();\n        }\n    }\n\n    *lt(key: IndexKey, t: _Transaction): Iterable<T> {\n        const bin = this.bin(t);\n        const limit = bin.lt(key);\n        const it = bin.begin;\n        if (!limit.valid) {\n            // yield all\n            while (it.valid) {\n                yield* it.value.values();\n                it.next();\n            }\n            return;\n        }\n        while (it.valid && limit.index >= it.index) {\n            yield* it.value.values();\n            it.next();\n        }\n        // const it = this.asBinary.lt(key);\n        // while (it.valid) {\n        //     yield* it.value.values();\n        //     it.prev();\n        // }\n    }\n\n    *le(key: IndexKey, t: _Transaction): Iterable<T> {\n        const bin = this.bin(t);\n        const limit = bin.le(key);\n        const it = bin.begin;\n        if (!limit.valid) {\n            // yield all\n            while (it.valid) {\n                yield* it.value.values();\n                it.next();\n            }\n            return;\n        }\n        while (it.valid && limit.index >= it.index) {\n            yield* it.value.values();\n            it.next();\n        }\n        // const it = this.asBinary.le(key);\n        // while (it.valid) {\n        //     yield* it.value.values();\n        //     it.prev();\n        // }\n    }\n\n    *outside(lo: IndexKey, hi: IndexKey, t: _Transaction): Iterable<T> {\n        yield* this.lt(lo, t);\n        yield* this.gt(hi, t);\n    }\n\n    *inside(lo: IndexKey, hi: IndexKey, t: _Transaction): Iterable<T> {\n        const it = this.bin(t).ge(lo);\n        while (it.valid && this.compare(it.key, hi) <= 0) {\n            yield* it.value.values();\n            it.next();\n        }\n    }\n\n    explain(e: _Explainer): _IndexExplanation {\n        return {\n            _: 'btree',\n            onTable: this.onTable.name,\n            btree: this.expressions.map(x => x.id!),\n        }\n    }\n}","module.exports = require(\"functional-red-black-tree\");","import { _Column, IValue, _IIndex, NotSupported, _Transaction, QueryError, _IType, SchemaField, ChangeHandler, nil, ISubscription, DropHandler } from './interfaces-private';\nimport type { MemoryTable } from './table';\nimport { Evaluator } from './evaluator';\nimport { ColumnConstraint, AlterColumn, AlterColumnAddGenerated } from 'pgsql-ast-parser';\nimport { nullIsh } from './utils';\nimport { buildValue } from './expression-builder';\nimport { columnEvaluator } from './transforms/selection';\nimport { BIndex } from './btree-index';\nimport { GeneratedIdentityConstraint } from './constraints/generated';\nimport { DataType } from './interfaces';\n\n\n\nexport class ColRef implements _Column {\n\n    default: IValue | nil;\n    notNull = false;\n    usedInIndexes = new Set<BIndex>();\n    private drophandlers = new Set<DropHandler>();\n\n    constructor(readonly table: MemoryTable\n        , public expression: Evaluator\n        , _schema: SchemaField\n        , public name: string) {\n        if (expression.type.primary === DataType.record) {\n            throw new QueryError(`column \"${this.name}\" has pseudo-type record`);\n        }\n    }\n\n    addConstraints(clist: ColumnConstraint[], t: _Transaction): this {\n        const notNull = clist.some(x => x.type === 'not null');\n        const acceptNil = clist.some(x => x.type === 'null');\n        if (notNull && acceptNil) {\n            throw new QueryError(`conflicting NULL/NOT NULL declarations for column \"${this.name}\" of table \"${this.table.name}\"`)\n        }\n        for (const c of clist) {\n            const cname = c.constraintName;\n            switch (c.type) {\n                case 'not null':\n                case 'null':\n                    // dealt with that above.\n                    break;\n                case 'primary key':\n                    this.table.createIndex(t, {\n                        columns: [{ value: this.expression }],\n                        primary: true,\n                        indexName: cname?.name,\n                    });\n                    break;\n                case 'unique':\n                    this.table.createIndex(t, {\n                        columns: [{ value: this.expression }],\n                        notNull: notNull,\n                        unique: true,\n                        indexName: cname?.name,\n                    });\n                    break;\n                case 'default':\n                    this.alter({\n                        type: 'set default',\n                        default: c.default,\n                        updateExisting: true,\n                    }, t);\n                    break;\n                case 'check':\n                    this.table.addCheck(t, c.expr, cname?.name);\n                    break;\n                case 'add generated':\n                    new GeneratedIdentityConstraint(c.constraintName?.name, this)\n                        .install(t, c);\n                    break;\n                default:\n                    throw NotSupported.never(c, 'add constraint type');\n            }\n        }\n        if (notNull) {\n            this.addNotNullConstraint(t);\n        }\n        this.table.db.onSchemaChange();\n        return this;\n    }\n\n\n    private addNotNullConstraint(t: _Transaction) {\n        // check has no null value\n        const bin = this.table.bin(t);\n        for (const e of bin.values()) {\n            const val = this.expression.get(e, t);\n            if (nullIsh(val)) {\n                throw new QueryError(`Cannot add not null constraint on column \"${this.expression.id}\": it contains null values`);\n            }\n        }\n        this.notNull = true;\n\n        // just amend schema (for cloning)\n        this.table.db.onSchemaChange();\n    }\n\n    rename(to: string, t: _Transaction): this {\n        if (this.table.getColumnRef(to, true)) {\n            throw new QueryError(`Column \"${to}\" already exists`);\n        }\n\n        // first, move data (this cannot throw => OK to modify mutable data)\n        this.table.remapData(t, v => {\n            const ov = v[this.expression.id!];\n            delete v[this.expression.id!];\n            v[to] = ov;\n        });\n        // for (const v of this.table.bin(t)) {\n        //     const ov = v[this.expression.id];\n        //     delete v[this.expression.id];\n        //     v[to] = ov;\n        // }\n\n        // === do nasty things to rename column\n        this.replaceExpression(to, this.expression.type);\n        this.table.db.onSchemaChange();\n        this.name = to;\n        return this;\n    }\n\n    alter(alter: AlterColumn, t: _Transaction): this {\n        switch (alter.type) {\n            case 'drop default':\n                this.default = null;\n                break;\n            case 'set default':\n                const df = buildValue(this.table.selection, alter.default);\n                if (!df.isConstant) {\n                    throw new QueryError('cannot use column references in default expression');\n                }\n                if (alter.updateExisting) {\n                    const defVal = df.get();\n                    this.table.remapData(t, x => x[this.expression.id!] = defVal);\n                }\n                this.default = df;\n                break;\n            case 'set not null':\n                this.addNotNullConstraint(t);\n                break;\n            case 'drop not null':\n                this.notNull = false;\n                break;\n            case 'set type':\n                const newType = this.table.ownerSchema.getType(alter.dataType);\n                const conv = this.expression.convert(newType);\n                const eid = this.expression.id;\n\n                this.table.remapData(t, x => x[this.expression.id!] = conv.get(x, t));\n\n                // once converted, do nasty things to change expression\n                this.replaceExpression(eid!, newType);\n                break;\n            case 'add generated':\n                new GeneratedIdentityConstraint(alter.constraintName?.name, this)\n                    .install(t, alter);\n                break;\n            default:\n                throw NotSupported.never(alter, 'alter column type');\n        }\n        this.table.db.onSchemaChange();\n        return this;\n    }\n\n    private replaceExpression(newId: string, newType: _IType) {\n        const on = this.expression.id!;\n        const nn = newId;\n        this.expression = columnEvaluator(this.table, newId, newType);\n\n        // replace in table\n        this.table.columnMgr.delete(on);\n        this.table.columnMgr.set(nn, this);\n    }\n\n    drop(t: _Transaction): void {\n        const on = this.expression.id!;\n        if (!this.table.columnMgr.has(on)) {\n            throw new Error('Corrupted table');\n        }\n\n        // remove indices\n        for (const u of this.usedInIndexes) {\n            this.table.dropIndex(t, u.name);\n        }\n\n        // remove associated data\n        this.table.remapData(t, x => delete x[this.expression.id!]);\n\n        // nasty business to remove columns\n        this.table.columnMgr.delete(on);\n        this.table.selection.rebuild();\n        this.drophandlers.forEach(d => d(t));\n        this.table.db.onSchemaChange();\n    }\n\n    checkConstraints(toInsert: any, t: _Transaction) {\n        if (!this.notNull) {\n            return;\n        }\n        const col = this.expression.get(toInsert, t);\n        if (nullIsh(col)) {\n            throw new QueryError(`null value in column \"${this.expression.id}\" violates not-null constraint`);\n        }\n    }\n\n    setDefaults(toInsert: any, t: _Transaction) {\n        const col = this.expression.get(toInsert, t);\n        if (col !== undefined) {\n            return;\n        }\n        if (!this.default) {\n            toInsert[this.expression.id!] = null\n        } else {\n            toInsert[this.expression.id!] = this.default.get();\n        }\n    }\n\n\n    onDrop(sub: DropHandler): ISubscription {\n        this.drophandlers.add(sub);\n        return {\n            unsubscribe: () => {\n                this.drophandlers.delete(sub);\n            }\n        }\n    }\n\n}","import { ISubscription, NotSupported, QueryError } from '../interfaces';\nimport { AlterColumnAddGenerated, Expr, ExprBinary, nil, TableConstraintForeignKey } from 'pgsql-ast-parser';\nimport { asTable, CreateIndexColDef, _Column, _IConstraint, _ITable, _Transaction } from '../interfaces-private';\nimport { nullIsh } from '../utils';\n\nexport class GeneratedIdentityConstraint implements _IConstraint {\n    private sub?: ISubscription;\n\n    private get table() {\n        return this.column.table;\n    }\n    private get schema() {\n        return this.table.ownerSchema;\n    }\n    constructor(readonly name: string | nil, private column: _Column) {\n    }\n\n    uninstall(t: _Transaction): void {\n        this.sub?.unsubscribe();\n    }\n\n\n    install(ct: _Transaction, _c: AlterColumnAddGenerated) {\n        if (!this.column.notNull) {\n            // if it's a table creation, then force 'not null'\n            const tableCreation = !this.schema.getTable(this.table.name, true);\n            if (tableCreation) {\n                this.column.alter({\n                    type: 'set not null',\n                }, ct);\n            } else {\n                // else, throw an error\n                throw new QueryError(`column \"${this.column.name}\" of relation \"${this.table.name}\" must be declared NOT NULL before identity can be added`);\n            }\n        }\n\n        const seq = this.schema.createSequence(ct, _c.sequence, _c.sequence?.name);\n\n        // todo : Review this... it's a complete bluff (dont have time to check spec)\n        const mode = _c.always ?? 'always';\n        this.sub = this.table.onBeforeChange([this.column], (old, neu, dt, opts) => {\n            // only act on new things\n            if (old) {\n                return;\n            }\n            const gen = () => neu[this.column.name] = seq.nextValue(dt);\n\n            if (nullIsh(neu[this.column.name])) {\n                // no value has been provided => generate one.\n                gen();\n                return;\n            }\n\n            // a value has been provided => check if must be overriden.\n            switch (mode) {\n                case 'by default':\n                    switch (opts.overriding ?? 'system') {\n                        case 'system':\n                            break;\n                        default:\n                            gen();\n                            break;\n\n                    }\n                    break;\n                case 'always':\n                    // column is 'GENREATED ALWAYS'\n                    // => must specify 'overriding system value'\n                    if (opts.overriding !== 'system') {\n                        throw new QueryError({\n                            error: `cannot insert into column \"${this.column.name}\"`,\n                            details: ` Column \"${this.column.name}\" is an identity column defined as GENERATED ALWAYS.`,\n                            hint: 'Use OVERRIDING SYSTEM VALUE to override.',\n                        })\n                    }\n                    break;\n                default:\n                    throw NotSupported.never(mode);\n            }\n\n        });\n    }\n\n}","import { ISubscription, NotSupported, QueryError } from '../interfaces';\nimport { Expr, ExprBinary, TableConstraintForeignKey } from 'pgsql-ast-parser';\nimport { asTable, CreateIndexColDef, _IConstraint, _ITable, _Transaction } from '../interfaces-private';\nimport { nullIsh } from '../utils';\n\nexport class ForeignKey implements _IConstraint {\n\n    private unsubs: ISubscription[] = [];\n\n    private table!: _ITable;\n    private foreignTable!: _ITable;\n\n\n\n    get db() {\n        return this.table.ownerSchema.db;\n    }\n\n    get schema() {\n        return this.table.ownerSchema;\n    }\n\n\n    constructor(readonly name: string) {\n    }\n\n    install(_t: _Transaction, cst: TableConstraintForeignKey, table: _ITable) {\n        const ftable = asTable(table.ownerSchema.getObject(cst.foreignTable, { beingCreated: table }));\n        const cols = cst.localColumns.map(x => table.getColumnRef(x.name));\n        const fcols = cst.foreignColumns.map(x => ftable.getColumnRef(x.name));\n        this.table = table;\n        this.foreignTable = ftable;\n        if (cols.length !== fcols.length) {\n            throw new QueryError('Foreign key count mismatch');\n        }\n        cols.forEach((c, i) => {\n            if (fcols[i].expression.type !== c.expression.type) {\n                throw new QueryError(`Foreign key column type mismatch`);\n            }\n        });\n\n        if ((cst.match ?? 'simple') !== 'simple' && cols.length !== 1) {\n            throw new NotSupported(`matching mode '${cst.match}' on mutliple columns foreign keys`);\n        }\n\n        // check that there is an unique index on this table for the given expressions\n        const findex = ftable.getIndex(...fcols.map(x => x.expression));\n        if (!findex?.unique) {\n            throw new QueryError(`there is no unique constraint matching given keys for referenced table \"${ftable.name}\"`);\n        }\n\n\n        // auto-create indices\n        if (this.db.options.autoCreateForeignKeyIndices) {\n            table.createIndex(_t, {\n                ifNotExists: true,\n                columns: cols.map<CreateIndexColDef>(x => ({\n                    value: x.expression,\n                })),\n            });\n        }\n\n        // ========================\n        // when changing the foreign table key, check correspondances in this table\n        // ========================\n        const onUpdate = cst.onUpdate ?? 'no action';\n        const onDelete = cst.onDelete ?? 'no action';\n        this.unsubs.push(ftable.onBeforeChange(cst.foreignColumns.map(x => x.name), (old, neu, dt) => {\n            if (!old) {\n                return;\n            }\n            const oVals = fcols.map(x => old[x.expression.id!]);\n            if (oVals.some(nullIsh)) {\n                return;\n            }\n            // build foreign key equality expression\n            const equals = cst.localColumns.map<ExprBinary>((x, i) => ({\n                type: 'binary',\n                op: '=',\n                left: { type: 'ref', name: x.name, table: { name: table.name } },\n                // hack, see #fkcheck\n                right: {\n                    type: 'constant',\n                    value: oVals[i],\n                    dataType: fcols[i].expression.type as any, // hack\n                },\n            }));\n            const expr = equals.slice(1).reduce<Expr>((a, b) => ({\n                type: 'binary',\n                op: 'AND',\n                left: a,\n                right: b,\n            }), equals[0]);\n\n            // check nothing matches\n            for (const local of table.selection.filter(expr).enumerate(dt)) {\n                // ====== ON DELETE\n                switch (neu ? onUpdate : onDelete) {\n                    case 'no action':\n                    case 'restrict':\n                        throw new QueryError(`update or delete on table \"${ftable.name}\" violates foreign key constraint on table \"${this.name}\"`);\n                    case 'cascade':\n                        if (neu) {\n                            for (let i = 0; i < fcols.length; i++) {\n                                local[cst.localColumns[i].name] = neu[cst.foreignColumns[i].name];\n                            }\n                            table.update(dt, local);\n                        } else {\n                            table.delete(dt, local);\n                        }\n                        break;\n                    case 'set default':\n                    case 'set null':\n                        for (const c of cst.localColumns) {\n                            local[c.name] = null;\n                        }\n                        table.update(dt, local);\n                        break;\n                }\n            }\n        }));\n\n        // =====================\n        //  when changing something in this table,\n        //  then there must be a key match in the foreign table\n        // =====================\n        table.onBeforeChange(cst.localColumns.map(x => x.name), (_, neu, dt) => {\n            if (!neu) {\n                return;\n            }\n            const vals = cols.map(x => (neu as any)[x.expression.id!]);\n            if (vals.some(nullIsh)) {\n                return;\n            }\n            // build foreign key equality expression\n            const equals = cst.foreignColumns.map<ExprBinary>((x, i) => ({\n                type: 'binary',\n                op: '=',\n                left: { type: 'ref', name: x.name, table: { name: ftable.name } },\n                // hack, see #fkcheck\n                right: {\n                    type: 'constant',\n                    value: vals[i],\n                    dataType: cols[i].expression.type as any, // hack\n                },\n            }));\n            const expr = equals.slice(1).reduce<Expr>((a, b) => ({\n                type: 'binary',\n                op: 'AND',\n                left: a,\n                right: b,\n            }), equals[0]);\n\n            // check there is a match\n            let yielded = false;\n            for (const _ of ftable.selection.filter(expr).enumerate(dt)) {\n                yielded = true;\n            }\n            if (!yielded) {\n                throw new QueryError(`insert or update on table \"${ftable.name}\" violates foreign key constraint on table \"${this.name}\"`);\n            }\n        });\n\n\n        // =====================\n        //  prevent foreign table from being dropped\n        // =====================\n        this.unsubs.push(ftable.onDrop(() => {\n            //  (todo implement multiple drops)\n            throw new QueryError({\n                error: `cannot drop table \"${ftable.name}\" because other objects depend on it`,\n                details: `constraint ${this.name} on table ${table.name} depends on table \"${ftable.name}\"`,\n                hint: `Use DROP ... CASCADE to drop the dependent objects too.`,\n            });\n        }));\n\n        // =====================\n        //  prevent foreign table truncation\n        // =====================\n        this.unsubs.push(ftable.onTruncate(() => {\n            throw new QueryError({\n                error: `cannot truncate a table referenced in a foreign key constraint`,\n                details: `Table \"${table.name}\" references \"${ftable.name}\".`,\n                hint: `HINT:  Truncate table \"${table.name}\" at the same time, or use TRUNCATE ... CASCADE.`,\n            })\n        }));\n\n        // =====================\n        //  when this table is dropped => remove hooks on foreign table\n        // =====================\n        table.onDrop(dt => {\n            this.uninstall(dt);\n        });\n\n        return this;\n    }\n\n    uninstall(t: _Transaction): void {\n        this.unsubs.forEach(x => x.unsubscribe());\n        this.unsubs = [];\n    }\n}","import { FilterBase } from './transform-base';\nimport { _ISelection, _Explainer, _SelectExplanation, _Transaction, Stats } from '../interfaces-private';\n\nexport class ArrayFilter<T = any> extends FilterBase<T> {\n\n    get index() {\n        return null;\n    }\n\n    entropy() {\n        return this.elts.length;\n    }\n\n    hasItem(raw: T): boolean {\n        return this.elts.includes(raw);\n    }\n\n    getIndex() {\n        return null;\n    }\n\n    constructor(fromTable: _ISelection<T>, private elts: T[]) {\n        super(fromTable);\n    }\n\n    enumerate(): Iterable<T> {\n        return this.elts;\n    }\n\n    stats(t: _Transaction): Stats | null {\n        return {\n            count: this.elts.length,\n        };\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'constantSet',\n            rawArrayLen: this.elts.length,\n        }\n    }\n}","import { AlterSequenceChange, CreateSequenceOptions } from 'pgsql-ast-parser';\nimport { combineSubs, ignore } from './utils';\nimport { NotSupported, asTable, _ISchema, _ISequence, _IType, _Transaction, RegClass, Reg } from './interfaces-private';\nimport { ISubscription, nil, QueryError } from './interfaces';\nimport { Types } from './datatypes';\n\nexport class Sequence implements _ISequence {\n\n    get type(): 'sequence' {\n        return 'sequence';\n    }\n\n    private symbol = Symbol();\n    private owner?: ISubscription;\n    private cfg: {\n        start?: number;\n        max?: number;\n        min?: number;\n        cycle?: boolean;\n        inc?: number;\n        dataType?: _IType;\n    } = {};\n\n    readonly reg: Reg;\n\n\n    get cycle() {\n        return this.cfg.cycle ?? false;\n    }\n\n    get dataType() {\n        return this.cfg.dataType ?? Types.integer;\n    }\n\n    get inc() {\n        return this.cfg.inc ?? 1;\n    }\n\n\n    constructor(public name: string, readonly ownerSchema: _ISchema) {\n        this.reg = ownerSchema._reg_register(this);\n    }\n\n\n    get start() {\n        return this.cfg.start ?? (this.inc > 0\n            ? this.min\n            : this.max);\n    }\n\n    get max() {\n        return this.cfg.max\n            ?? (this.inc > 0\n                ? Number.MAX_SAFE_INTEGER - 1\n                : -1);\n    }\n\n    get min() {\n        return this.cfg.min\n            ?? (this.inc > 0\n                ? 1\n                : Number.MIN_SAFE_INTEGER + 1);\n    }\n\n    alter(t: _Transaction, opts: CreateSequenceOptions | AlterSequenceChange | nil): this {\n        if (!opts) {\n            return this;\n        }\n        const oldCfg = { ...this.cfg };\n        try {\n            if (!('type' in opts)) {\n                return this.alterOpts(t, opts);\n            }\n            switch (opts.type) {\n                case 'set options':\n                    this.alterOpts(t, opts);\n                    if (opts.restart) {\n                        t.set(this.symbol, this.start);\n                    }\n                    return this;\n                case 'set schema':\n                    if (opts.newSchema.name === this.ownerSchema.name) {\n                        return this;\n                    }\n                    throw new NotSupported('Sequence schema change');\n                case 'rename':\n                    const to = opts.newName.name.toLowerCase();\n                    this.ownerSchema._reg_rename(this, this.name, to);\n                    this.name = to;\n                    return this;\n                case 'owner to':\n                    // todo: implement sequence owners ? ...ignored to support pg_dump exports.\n                    ignore(opts);\n                    return this;\n                default:\n                    throw NotSupported.never(opts);\n            }\n        } catch (e) {\n            this.cfg = oldCfg;\n            throw e;\n        }\n    }\n\n    nextValue(t: _Transaction): number {\n        let v = t.get<number>(this.symbol);\n        if (v === undefined) {\n            v = this.start;\n        } else {\n            v += this.inc;\n        }\n        this.setValue(t, v);\n        return v;\n    }\n\n    setValue(t: _Transaction, value: number) {\n        if (value > this.max) {\n            throw new QueryError(`reached maximum value of sequence \"${this.name}\"`);\n        }\n        if (value < this.min) {\n            throw new QueryError(`reached minimum value of sequence \"${this.name}\"`);\n        }\n        t.set(this.symbol, value);\n    }\n\n    currentValue(t: _Transaction): number {\n        const v = t.get<number>(this.symbol);\n        if (v === undefined) {\n            throw new QueryError(`currval of sequence \"${this.name}\" is not yet defined in this session`);\n        }\n        return v;\n    }\n\n\n    private alterOpts(t: _Transaction, opts: CreateSequenceOptions) {\n        if (opts.as) {\n            ignore(opts.as);\n            this.cfg.dataType = this.ownerSchema.getType(opts.as);\n        }\n        ignore(opts.cache);\n        if (opts.cycle) {\n            this.cfg.cycle = opts.cycle === 'cycle';\n        }\n\n        if (typeof opts.incrementBy === 'number') {\n            this.cfg.inc = opts.incrementBy;\n        }\n\n        if (typeof opts.maxValue === 'number') {\n            this.cfg.max = opts.maxValue;\n        } else if (opts.maxValue) {\n            this.cfg.max = undefined;\n        }\n\n        if (typeof opts.minValue === 'number') {\n            this.cfg.min = opts.minValue;\n        } else if (opts.maxValue) {\n            this.cfg.min = undefined;\n        }\n\n        if (typeof opts.startWith === 'number') {\n            this.cfg.start = opts.startWith;\n        }\n\n\n        if (opts.ownedBy === 'none') {\n            this.owner?.unsubscribe();\n        } else if (opts.ownedBy) {\n            this.owner?.unsubscribe();\n\n            const tbl = asTable(this.ownerSchema.getObject({\n                name: opts.ownedBy.table,\n                schema: opts.ownedBy.schema\n            }));\n\n            const owner = tbl.getColumnRef(opts.ownedBy.column);\n\n            this.owner = combineSubs(\n                owner.onDrop(dt => this.drop(dt)),\n                tbl.onDrop(dt => this.drop(dt)),\n            );\n        }\n\n        // === validate\n        if (this.max < this.min) {\n            throw new QueryError('Invalid squeuence min-max');\n        }\n\n        if (!this.inc) {\n            throw new QueryError('Invalid increment');\n        }\n\n        if (this.start > this.max || this.start < this.min) {\n            throw new QueryError('Invalid sequence starting value');\n        }\n        return this;\n    }\n\n    drop(t: _Transaction) {\n        this.owner?.unsubscribe();\n        this.owner = undefined;\n        t.delete(this.symbol);\n        this.ownerSchema._reg_unregister(this);\n    }\n}","\nimport { _ISchema } from '../interfaces-private'\nimport { IMigrate } from './migrate-interfaces'\n\nimport MigrationFile = IMigrate.MigrationFile\nimport MigrationParams = IMigrate.MigrationParams\nimport MigrationData = IMigrate.MigrationData\nimport { literal } from '../pg-escape'\n\ndeclare var __non_webpack_require__: any;\ndeclare var process: any;\n\nexport async function readMigrations (migrationPath?: string) {\n  const path = __non_webpack_require__('path');\n  const fs = __non_webpack_require__('fs');\n  const migrationsPath = migrationPath || path.join(process.cwd(), 'migrations')\n  const location = path.resolve(migrationsPath)\n\n  // Get the list of migration files, for example:\n  //   { id: 1, name: 'initial', filename: '001-initial.sql' }\n  //   { id: 2, name: 'feature', filename: '002-feature.sql' }\n  const migrationFiles = await new Promise<MigrationFile[]>(\n    (resolve, reject) => {\n      fs.readdir(location, (err: any, files: string[]) => {\n        if (err) {\n          return reject(err)\n        }\n\n        resolve(\n          files\n            .map(x => x.match(/^(\\d+).(.*?)\\.sql$/))\n            .filter(x => x !== null)\n            .map(x => ({ id: Number(x![1]), name: x![2], filename: x![0] }))\n            .sort((a, b) => Math.sign(a.id - b.id))\n        )\n      })\n    }\n  )\n\n  if (!migrationFiles.length) {\n    throw new Error(`No migration files found in '${location}'.`)\n  }\n\n  // Get the list of migrations, for example:\n  //   { id: 1, name: 'initial', filename: '001-initial.sql', up: ..., down: ... }\n  //   { id: 2, name: 'feature', filename: '002-feature.sql', up: ..., down: ... }\n  return Promise.all(\n    migrationFiles.map(\n      migration =>\n        new Promise<MigrationData>((resolve, reject) => {\n          const filename = path.join(location, migration.filename)\n          fs.readFile(filename, 'utf-8', (err: any, data: string) => {\n            if (err) {\n              return reject(err)\n            }\n\n            const [up, down] = data.split(/^--\\s+?down\\b/im)\n\n            const migrationData = migration as Partial<MigrationData>\n            migrationData.up = up.replace(/^-- .*?$/gm, '').trim() // Remove comments\n            migrationData.down = down ? down.trim() : '' // and trim whitespaces\n            resolve(migrationData as MigrationData)\n          })\n        })\n    )\n  )\n}\n\n/**\n * Migrates database schema to the latest version\n */\nexport async function migrate (db: _ISchema, config: MigrationParams = {}) {\n  config.force = config.force || false\n  config.table = config.table || 'migrations'\n\n  const { force, table } = config\n  const migrations = config.migrations\n    ? config.migrations\n    : await readMigrations(config.migrationsPath)\n\n  // Create a database table for migrations meta data if it doesn't exist\n  await db.none(`CREATE TABLE IF NOT EXISTS \"${table}\" (\n  id   INTEGER PRIMARY KEY,\n  name TEXT    NOT NULL,\n  up   TEXT    NOT NULL,\n  down TEXT    NOT NULL\n)`)\n\n  // Get the list of already applied migrations\n  let dbMigrations = await db.many(\n    `SELECT id, name, up, down FROM \"${table}\" ORDER BY id ASC`\n  )\n\n  // Undo migrations that exist only in the database but not in files,\n  // also undo the last migration if the `force` option is enabled.\n  const lastMigration = migrations[migrations.length - 1]\n  for (const migration of dbMigrations\n    .slice()\n    .sort((a, b) => Math.sign(b.id - a.id))) {\n    if (\n      !migrations.some(x => x.id === migration.id) ||\n      (force && migration.id === lastMigration.id)\n    ) {\n      // await db.run('BEGIN')\n      try {\n        await db.none(migration.down)\n        await db.none(`DELETE FROM \"${table}\" WHERE id = ${migration.id}`)\n        // await db.run('COMMIT')\n        dbMigrations = dbMigrations.filter(x => x.id !== migration.id)\n      } catch (err) {\n        // await db.run('ROLLBACK')\n        throw err\n      }\n    } else {\n      break\n    }\n  }\n\n  // Apply pending migrations\n  const lastMigrationId = dbMigrations.length\n    ? dbMigrations[dbMigrations.length - 1].id\n    : 0\n  for (const migration of migrations) {\n    if (migration.id > lastMigrationId) {\n      // await db.run('BEGIN')\n      try {\n        await db.none(migration.up)\n        await db.none(\n          `INSERT INTO \"${table}\" (id, name, up, down) VALUES (\n          ${migration.id},\n          ${literal(migration.name)},\n          ${literal(migration.up)},\n          ${literal(migration.down)})`\n        )\n        // await db.run('COMMIT')\n      } catch (err) {\n        // await db.run('ROLLBACK')\n        throw err\n      }\n    }\n  }\n}","import { Evaluator } from '../evaluator';\nimport { TypeBase } from './datatype-base';\nimport { CastError, DataType, nil, QueryError } from '../interfaces';\nimport { _ISchema, _IType } from '../interfaces-private';\n\nexport class CustomEnumType extends TypeBase<string> {\n\n    get primary(): DataType {\n        return this.name as any;\n    }\n\n    get name(): string {\n        return this._name;\n    }\n\n    constructor(readonly schema: _ISchema\n        , private readonly _name: string\n        , readonly values: string[]) {\n        super();\n    }\n\n    install() {\n        this.schema._registerType(this);\n    }\n\n    doCanCast(to: _IType) {\n        return to.primary === DataType.text;\n    }\n\n    doCast(value: Evaluator<string>, to: _IType<string>): Evaluator<any> | nil {\n        return value;\n    }\n\n    prefer(type: _IType<any>): _IType | nil {\n        return this;\n    }\n\n    doCanBuildFrom(from: _IType): boolean | nil {\n        return from.primary === DataType.text;\n    }\n\n    doBuildFrom(value: Evaluator<string>, from: _IType<string>): Evaluator<string> | nil {\n        return value\n            .setConversion((raw: string) => {\n                if (!this.values.includes(raw)) {\n                    throw new QueryError(`invalid input value for enum ${this.name}: \"${raw}\"`);\n                }\n                return raw;\n            }\n                , conv => ({ conv, toCenum: this.name }))\n    }\n}\n","import { QueryError, Schema, SchemaField } from '../interfaces';\nimport { setId, _ISchema, _IType, _Transaction } from '../interfaces-private';\nimport { Expr } from 'pgsql-ast-parser';\nimport { ReadOnlyTable } from './readonly-table';\nimport { buildValue } from '../expression-builder';\nimport { Types } from '../datatypes';\n\nlet cnt = 0;\nexport class ValuesTable extends ReadOnlyTable {\n    private items: any[];\n    private symbol = Symbol();\n\n    entropy(t: _Transaction): number {\n        return this.items.length;\n    }\n    enumerate(t: _Transaction): Iterable<any> {\n        return this.items;\n    }\n    hasItem(value: any, t: _Transaction): boolean {\n        return !!value[this.symbol];\n    }\n\n\n    readonly _schema: Schema;\n\n    constructor(owner: _ISchema, alias: string, items: Expr[][], columnNames: string[]) {\n        super(owner);\n        const len = new Set(items.map(x => x.length));\n        if (len.size !== 1) {\n            throw new QueryError('VALUES lists must all be the same length');\n        }\n        if (columnNames?.length > items[0].length) {\n            throw new QueryError(`table \"${alias}\" has ${items[0].length} columns available but ${columnNames.length} columns specified`);\n        }\n        let builtVals = items.map(vals => vals.map(e => buildValue(owner.dualTable.selection, e)));\n        const types = items[0].map((_, i) => preferedType(builtVals.map(x => x[i].type)));\n        this._schema = {\n            name: alias,\n            fields: types.map<SchemaField>((type, i) => {\n                return {\n                    type,\n                    name: columnNames?.[i] ?? `column${i}`,\n                }\n            })\n        };\n        this.items = builtVals.map(vals => {\n            const ret = { [this.symbol]: true } as any;\n            setId(ret, 'vtbl' + (++cnt));\n            for (let i = 0; i < vals.length; i++) {\n                ret[this._schema.fields[i].name] = vals[i].convert(types[i]).get();\n            }\n            return ret;\n        });\n    }\n}\n\nfunction preferedType(types: _IType[]) {\n    return types.reduce((a, b) => {\n        const ret = a.prefer(b);\n        if (!ret) {\n            throw new QueryError('Incompatible value types');\n        }\n        return ret;\n    }, types[0]);\n}","import { Evaluator } from '../evaluator';\nimport { TypeBase } from './datatype-base';\nimport { CastError, DataType, IEquivalentType, IType, nil, QueryError, typeDefToStr } from '../interfaces';\nimport { _ISchema, _IType } from '../interfaces-private';\nimport { Types } from './datatypes';\n\nexport class EquivalentType extends TypeBase<string> {\n\n    private equiv: IType;\n\n    constructor(private def: IEquivalentType) {\n        super();\n        if (typeof def.equivalentTo === 'string') {\n            let eq = (Types as any)[def.equivalentTo];\n            if (typeof eq === 'function') {\n                eq = eq();\n            }\n            this.equiv = eq;\n        } else {\n            this.equiv = def.equivalentTo;\n        }\n\n        if (!this.equiv) {\n            throw new Error(`Invalid equilvalent type`);\n        }\n    }\n\n    get primary(): DataType {\n        return this.def.name as any;\n    }\n\n    doCanCast(to: _IType) {\n        return to.primary === this.equiv.primary;\n    }\n\n    doCast(value: Evaluator<string>, to: _IType<string>): Evaluator<any> | nil {\n        return value;\n    }\n\n    prefer(type: _IType<any>): _IType | nil {\n        return this;\n    }\n\n    doCanBuildFrom(from: _IType): boolean | nil {\n        return from.primary === this.equiv.primary;\n    }\n\n    doBuildFrom(value: Evaluator<string>, from: _IType<string>): Evaluator<string> | nil {\n        return value\n            .setConversion(x => {\n                if (!this.def.isValid(x)) {\n                    throw new QueryError(`invalid input syntax for type ${typeDefToStr(this)}: ${x}`);\n                }\n                return x;\n            }, val => ({ val, to: this.equiv.primary }));\n    }\n}\n","import { QueryError, Reg, _Explainer, _ISchema, _ISelection, _IView, _Transaction } from './interfaces-private';\nimport { DataSourceBase, FilterBase } from './transforms/transform-base';\n\nexport class View extends FilterBase<any> implements _IView {\n    get type(): 'view' {\n        return 'view';\n    }\n\n    private _reg?: Reg;\n    get reg(): Reg {\n        if (!this._reg) {\n            throw new QueryError(`relation \"${this.name}\" does not exist`);\n        }\n        return this._reg;\n    }\n\n    constructor(readonly ownerSchema: _ISchema, readonly name: string, readonly selection: _ISelection) {\n        super(selection);\n    }\n\n\n    enumerate(t: _Transaction): Iterable<any> {\n        return this.selection.enumerate(t);\n    }\n\n    hasItem(value: any, t: _Transaction): boolean {\n        return this.selection.hasItem(value, t);\n    }\n\n    explain(e: _Explainer) {\n        return this.selection.explain(e);\n    }\n\n    stats(t: _Transaction) {\n        return this.selection.stats(t);\n    }\n\n\n    register() {\n        // once fields registered,\n        //  then register the table\n        //  (column registrations need it not to be registered yet)\n        this._reg = this.ownerSchema._reg_register(this);\n        return this;\n    }\n\n    drop(t: _Transaction): void {\n        throw new Error('Method not implemented.');\n    }\n}","import { _ISelection, CastError, DataType, NotSupported } from '../interfaces-private';\nimport { buildValue } from '../expression-builder';\nimport { Types, ArrayType } from '../datatypes';\nimport { EqFilter } from './eq-filter';\nimport { Value } from '../evaluator';\nimport { FalseFilter } from './false-filter';\nimport { AndFilter } from './and-filter';\nimport { OrFilter } from './or-filter';\nimport { SeqScanFilter } from './seq-scan';\nimport { InFilter } from './in-filter';\nimport { NotInFilter } from './not-in-filter';\nimport { Expr, ExprBinary, ExprUnary, ExprTernary } from 'pgsql-ast-parser';\nimport { StartsWithFilter } from './startswith-filter';\nimport { IneqFilter } from './ineq-filter';\nimport { hasNullish, nullIsh } from '../utils';\nimport { BetweenFilter } from './between-filter';\n\nexport function buildFilter<T>(this: void, on: _ISelection<T>, filter: Expr): _ISelection<T> {\n    return _buildFilter(on, filter) ?? new SeqScanFilter(on, buildValue(on, filter))\n}\n\nfunction _buildFilter<T>(this: void, on: _ISelection<T>, filter: Expr): _ISelection<T> | null {\n    // check if there is a direct index\n    const built = buildValue(on, filter);\n    if (built.index) {\n        if (built.index.expressions.length !== 1) {\n            throw new Error('Was not expecing multiples expressions filter');\n        }\n        const itype = built.index.expressions[0].type;\n        if (itype !== Types.bool) {\n            throw new CastError(itype.primary, DataType.bool);\n        }\n        return new EqFilter(built, true, 'eq', false);\n    }\n\n    // if this filter is a constant expression (ex: 1 = 1)\n    // then return directly\n    if (built.isConstant) {\n        const val = built.convert(Types.bool)\n            .get();\n        if (val) {\n            return on;\n        }\n        return new FalseFilter(on);\n    }\n    switch (filter.type) {\n        case 'binary':\n            return buildBinaryFilter(on, filter);\n        case 'unary':\n            return buildUnaryFilter(on, filter);\n        case 'ternary':\n            return buildTernaryFilter(on, filter);\n        default:\n            return null;\n    }\n}\n\nfunction buildUnaryFilter<T>(this: void, on: _ISelection<T>, filter: ExprUnary): _ISelection<T> | null {\n    const { operand, op } = filter;\n    switch (op) {\n        case 'IS NULL':\n        case 'IS NOT NULL': {\n            const leftValue = buildValue(on, operand);\n            if (leftValue.index) {\n                return new EqFilter(leftValue, null, op === 'IS NULL' ? 'eq' : 'neq', true);\n            }\n            return new SeqScanFilter(on, Value.isNull(on.ownerSchema, leftValue, op === 'IS NULL'));\n        }\n    }\n    return null;\n}\n\nfunction buildBinaryFilter<T>(this: void, on: _ISelection<T>, filter: ExprBinary): _ISelection<T> | null{\n    const { left, right, op } = filter;\n    switch (op) {\n        case '=':\n        case '!=':\n        case '>':\n        case '<':\n        case '<=':\n        case '>=':\n            return buildComparison(on, filter);\n        case 'AND':\n        case 'OR': {\n            const leftFilter = buildFilter(on, left);\n            const rightFilter = buildFilter(on, right);\n            if (op === 'OR' && (leftFilter instanceof SeqScanFilter || rightFilter instanceof SeqScanFilter)) {\n                return null;\n            }\n            return op === 'AND'\n                ? new AndFilter([leftFilter, rightFilter])\n                : new OrFilter(leftFilter, rightFilter);\n        }\n        case 'IN':\n        case 'NOT IN': {\n            const value = buildValue(on, left);\n            let arrayValue = buildValue(on, right);\n            // to support things like: \"col in (value)\" - which RHS does not parse to an array\n            if (arrayValue.type.primary !== DataType.array) {\n                arrayValue = Value.array(on.ownerSchema, [arrayValue], false);\n            }\n            const elementType = (arrayValue.type as ArrayType).of.prefer(value.type);\n            const array = arrayValue.convert(elementType!.asArray());\n            // only support scanning indexes with one expression\n            if (array.isConstant && value.index?.expressions.length === 1) {\n                const arrCst = array.get();\n                if (nullIsh(arrCst)) {\n                    return new FalseFilter(on);\n                }\n                return op === 'IN'\n                    ? new InFilter(value, arrCst)\n                    : new NotInFilter(value, arrCst);\n            }\n            // todo use indexes on queries like \"WHERE 'whatever' in (indexedOne, indexedTwo)\"\n            //   => this is an OrFilter\n            return new SeqScanFilter(on, Value.in(on.ownerSchema, value, array, op === 'IN'));\n        }\n        case 'LIKE': {\n            const value = buildValue(on, left);\n            if (value.index && value.index.expressions[0].hash === value.hash) {\n                const valueToCompare = buildValue(on, right);\n                if (valueToCompare.isConstant) {\n                    const str = valueToCompare.get();\n                    if (str === null) {\n                        return new FalseFilter(on);\n                    }\n                    const got = /^([^%_]+)([%_]?.+)$/.exec(str);\n                    if (got) {\n                        const start = got[1];\n                        if (start.length === str) {\n                            // that's a full string with no tokens => just an '='\n                            return buildComparison(on, {\n                                type: 'binary',\n                                op: '=',\n                                left: left,\n                                right: right,\n                            });\n                        }\n                        // yea, we can use an index\n                        const indexed = new StartsWithFilter(value, start);\n                        if (got[2] === '%') {\n                            // just a starsWith\n                            return indexed;\n                        }\n                        // use index, but filter again on it.\n                        return new SeqScanFilter(indexed, buildValue(on, filter));\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\n\nfunction buildComparison<T>(this: void, on: _ISelection<T>, filter: ExprBinary): _ISelection<T> | null {\n    const { op, left, right } = filter;\n    let leftValue = buildValue(on, left);\n    let rightValue = buildValue(on, right);\n\n    if (leftValue.isConstant && rightValue.isConstant) {\n        const global = buildValue(on, filter);\n        const got = global.get();\n        if (got) {\n            return on;\n        }\n        return new FalseFilter(on);\n    }\n\n    if (rightValue.isConstant) {\n        rightValue = rightValue.convert(leftValue.type);\n    } else if (leftValue.isConstant) {\n        leftValue = leftValue.convert(rightValue.type);\n    }\n\n    switch (op) {\n        case '=':\n        case '!=': {\n            if (leftValue.index && rightValue.isConstant) {\n                return new EqFilter(leftValue, rightValue.get(), op === '=' ? 'eq' : 'neq', false)\n            }\n            if (rightValue.index && leftValue.isConstant) {\n                return new EqFilter(rightValue, leftValue.get(), op === '=' ? 'eq' : 'neq', false);\n            }\n            break;\n        }\n        case '>':\n        case '>=':\n        case '<':\n        case '<=':\n            if (leftValue.index && leftValue.index.expressions[0].hash === leftValue.hash && rightValue.isConstant) {\n                const fop = op === '>' ? 'gt'\n                    : op === '>=' ? 'ge'\n                        : op === '<' ? 'lt'\n                            : 'le';\n                return new IneqFilter(leftValue, fop, rightValue.get());\n            }\n            if (rightValue.index && rightValue.index.expressions[0].hash === rightValue.hash && leftValue.isConstant) {\n                const fop = op === '>' ? 'le'\n                    : op === '>=' ? 'lt'\n                        : op === '<' ? 'ge'\n                            : 'gt';\n                return new IneqFilter(rightValue, fop, leftValue.get());\n            }\n            break;\n    }\n    return null;\n}\n\nfunction buildTernaryFilter<T>(this: void, on: _ISelection<T>, filter: ExprTernary): _ISelection<T> | null {\n    switch (filter.op) {\n        case 'BETWEEN':\n        case 'NOT BETWEEN': {\n            const value = buildValue(on, filter.value);\n            const lo = buildValue(on, filter.lo);\n            const hi = buildValue(on, filter.hi);\n            const valueIndex = value.index;\n            if (valueIndex && valueIndex.expressions[0].hash === value.hash && lo.isConstant && hi.isConstant) {\n                const lov = lo.get();\n                const hiv = hi.get();\n                if (hasNullish(lov, hiv)) {\n                    return new FalseFilter(on);\n                }\n                return new BetweenFilter(value, lov, hiv, filter.op === 'BETWEEN' ? 'inside' : 'outside');\n            }\n        }\n    }\n    return null;\n}","import { _ISelection, IValue, _IIndex, _ITable, _Transaction, _Explainer, _SelectExplanation, IndexKey, IndexOp, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { nullIsh } from '../utils';\n\nexport class EqFilter<T = any> extends FilterBase<T> {\n\n    private index: _IIndex;\n    private opDef: IndexOp;\n\n    entropy(t: _Transaction): number {\n        return this.index.entropy({ ...this.opDef, t });\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        const stats = this.index.stats(t, [this.equalsCst]);\n        if (this.op === 'eq' || !stats) {\n            return stats;\n        }\n        // if neq, then compute from eq and all\n        const all = this.index.stats(t);\n        if (!all) {\n            return null;\n        }\n        return {\n            count: all.count - stats.count,\n        };\n    }\n\n    hasItem(item: T, t: _Transaction) {\n        const val = this.onValue.get(item, t);\n        if (nullIsh(val)) {\n            return false;\n        }\n        const eq = this.onValue.type.equals(val, this.equalsCst);\n        if (nullIsh(eq)) {\n            return false;\n        }\n        return this.op === 'eq' ? !!eq : !eq;\n    }\n\n    constructor(private onValue: IValue<T>\n        , private equalsCst: any\n        , private op: 'eq' | 'neq'\n        , private matchNull: boolean) {\n        super(onValue.origin!);\n        if (onValue.index!.expressions.length !== 1) {\n            throw new Error('Unexpected index equality expressions count mismatch');\n        }\n\n        this.index = this.onValue.index!;\n        this.opDef = {\n            type: op,\n            key: [equalsCst],\n            t: null as any,\n            matchNull: this.matchNull,\n        }\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        for (const item of this.index.enumerate({ ...this.opDef, t })) {\n            yield item;\n        }\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: this.op,\n            entropy: this.entropy(e.transaction),\n            on: this.onValue.index!.explain(e),\n        };\n    }\n}\n","import { _ISelection, IValue, _Explainer, _SelectExplanation, _Transaction, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\n\nexport class FalseFilter<T = any> extends FilterBase<T> {\n\n    get index() {\n        return null;\n    }\n\n    entropy() {\n        return 0;\n    }\n\n    hasItem() {\n        return false;\n    }\n\n    enumerate(): Iterable<T> {\n        return [];\n    }\n\n    stats(t: _Transaction): Stats | null {\n        return {\n            count: 0,\n        }\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'empty',\n        };\n    }\n}","import { _ISelection, _IIndex, _ITable, _Transaction, _Explainer, _SelectExplanation, Stats, nil } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { SeqScanFilter } from './seq-scan';\n\n\n\nexport class AndFilter<T = any> extends FilterBase<T> {\n\n    get index(): _IIndex<T> | nil {\n        return null;\n    }\n\n    private prevEntropy?: { t: _Transaction; ret: number };\n\n    entropy(t: _Transaction) {\n        // just a bit of caching\n        if (t === this.prevEntropy?.t) {\n            return this.prevEntropy.ret;\n        }\n        const { best } = this.plan(t);\n        const ret = best.entropy(t);\n        this.prevEntropy = {\n            ret,\n            t,\n        };\n        return ret;\n    }\n\n    hasItem(value: T, t: _Transaction): boolean {\n        return !this.filters.some(x => !x.hasItem(value, t));\n    }\n\n    constructor(private filters: _ISelection<T>[]) {\n        super(filters.find(x => !(x instanceof SeqScanFilter)) ?? filters[0]);\n        if (filters.some(f => f.columns !== this.base.columns)) {\n            throw new Error('Column set mismatch');\n        }\n    }\n\n    private plan(t: _Transaction) {\n        const sorted = [...this.filters]\n            .sort((a, b) => a.entropy(t) > b.entropy(t) ? 1 : -1);\n        const [best] = sorted.splice(0, 1);\n        return { best, sorted };\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        // sort them so the most restrictive filter is first\n        const { best, sorted } = this.plan(t)\n        for (const item of best.enumerate(t)) {\n            if (!sorted.some(x => x.hasItem(item, t))) {\n                continue;\n            }\n            yield item;\n        }\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        const { best, sorted } = this.plan(e.transaction);\n        return {\n            id: e.idFor(this),\n            _: 'and',\n            enumerate: best.explain(e),\n            andCheck: sorted.map(x => x.explain(e)),\n        };\n    }\n\n}","import { _ISelection, _IIndex, _ITable, getId, _Transaction, _Explainer, _SelectExplanation, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\n\n\nexport class OrFilter<T = any> extends FilterBase<T> {\n\n    entropy(t: _Transaction) {\n        return this.left.entropy(t) + this.right.entropy(t);\n    }\n\n    hasItem(value: T, t: _Transaction): boolean {\n        return this.left.hasItem(value, t) && this.right.hasItem(value, t);\n    }\n\n    constructor(private left: _ISelection<T>, private right: _ISelection<T>) {\n        super(left);\n        if (left.columns !== right.columns) { //  istanbul ignore next\n            throw new Error('Column set mismatch');\n        }\n    }\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        const yielded = new Set<string>();\n        for (const item of this.left.enumerate(t)) {\n            yield item;\n            yielded.add(getId(item));\n        }\n        for (const item of this.right.enumerate(t)) {\n            const id = getId(item);\n            if (!yielded.has(id)) {\n                yield item;\n            }\n        }\n    }\n\n\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'union',\n            union: [\n                this.left.explain(e),\n                this.right.explain(e),\n            ],\n        };\n    }\n}","import { _ISelection, IValue, _IIndex, _ITable, getId, _Transaction, _Explainer, _SelectExplanation, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { DataType, CastError, QueryError } from '../interfaces';\nimport { nullIsh } from '../utils';\n\nexport class InFilter<T = any> extends FilterBase<T> {\n\n\n    private index: _IIndex;\n\n    entropy(t: _Transaction) {\n        let ret = 0;\n        for (const a of this.elts) {\n            ret += this.index.entropy({\n                type: 'eq',\n                key: [a],\n                t,\n            });\n        }\n        return ret;\n    }\n\n    hasItem(item: T, t: _Transaction) {\n        const val = this.onValue.get(item, t);\n        return !nullIsh(val)\n            && this.elts.some(x => this.onValue.type.equals(x, val));\n    }\n\n    constructor(private onValue: IValue<T>\n        , private elts: any[]) {\n        super(onValue.origin!);\n        this.index = onValue.index!;\n        if (this.index.expressions.length !== 1) {\n            throw new Error('Only supports IN with signle expressions index');\n        }\n        if (!Array.isArray(elts)) {\n            throw new QueryError('Cannot iterate element list');\n        }\n    }\n\n    stats(t: _Transaction): Stats | null {\n        const elts = this.elts.map(x => this.index.stats(t, [x]));\n        if (elts.some(x => !x)) {\n            return null;\n        }\n        // compute from elements\n        const ret: Stats = {\n            count: 0,\n        };\n        for (const i of elts) {\n            ret.count += i!.count;\n        }\n        return ret;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        for (const a of this.elts) {\n            yield* this.index.enumerate({\n                type: 'eq',\n                key: [a],\n                t,\n            });\n        }\n    }\n\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'eq',\n            entropy: this.entropy(e.transaction),\n            on: this.index.explain(e),\n        };\n    }\n}","import { _ISelection, IValue, _IIndex, _ITable, getId, _Transaction, _Explainer, _SelectExplanation, IndexKey, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { DataType, CastError, QueryError } from '../interfaces';\nimport { nullIsh } from '../utils';\n\nexport class NotInFilter<T = any> extends FilterBase<T> {\n\n    private index: _IIndex;\n    private keys: IndexKey[];\n\n    entropy(t: _Transaction) {\n        return this.onValue.index!.entropy({\n            type: 'nin',\n            keys: this.keys,\n            t,\n        });\n    }\n\n    hasItem(item: T, t: _Transaction): boolean {\n        const val = this.onValue.get(item, t);\n        return !nullIsh(val)\n            && !this.elts.some(x => this.onValue.type.equals(x, val));\n    }\n\n    constructor(private onValue: IValue<T>\n        , private elts: any[]) {\n        super(onValue.origin!);\n        this.index = onValue.index!;\n        if (this.index.expressions.length !== 1) {\n            throw new Error('Only supports IN with signle expressions index');\n        }\n        if (!Array.isArray(elts)) {\n            throw new QueryError('Cannot iterate element list');\n        }\n        this.keys = elts.map(x => [x]);\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        const all = this.base.stats(t);\n        if (!all) {\n            return null;\n        }\n        const elts = this.elts.map(x => this.index.stats(t, [x]));\n        if (elts.some(x => !x)) {\n            return null;\n        }\n        // compute based on 'all'\n        for (const i of elts) {\n            all.count -= i!.count;\n        }\n        return all;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        yield* this.index.enumerate({\n            type: 'nin',\n            keys: this.keys,\n            t,\n        });\n    }\n\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'neq',\n            entropy: this.entropy(e.transaction),\n            on: this.onValue.index!.explain(e),\n        };\n    }\n}","import { _ISelection, IValue, _IIndex, _ITable, getId, _Transaction, _Explainer, _SelectExplanation, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { DataType, CastError, QueryError } from '../interfaces';\n\nexport class StartsWithFilter<T = any> extends FilterBase<T> {\n\n    get index() {\n        return null;\n    }\n\n    entropy(t: _Transaction) {\n        return this.onValue.index!.entropy({\n            type: 'ge',\n            key: [this.startWith],\n            t,\n        });\n    }\n\n    hasItem(item: T, t: _Transaction) {\n        const get = this.onValue.get(item, t);\n        return typeof get === 'string'\n            && get.startsWith(this.startWith);\n    }\n\n    constructor(private onValue: IValue<T>\n        , private startWith: string) {\n        super(onValue.origin!);\n        if (onValue.index!.expressions[0].hash !== this.onValue.hash) {\n            throw new Error('Startwith must be the first component of the index');\n        }\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        const index = this.onValue.index!;\n        for (const item of index.enumerate({\n            type: 'ge',\n            key: [this.startWith],\n            t,\n        })) {\n            const got: string = this.onValue.get(item, t);\n            if (got === null || !got.startsWith(this.startWith)) {\n                break;\n            }\n            yield item;\n        }\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'ineq',\n            entropy: this.entropy(e.transaction),\n            on: this.onValue.index!.explain(e),\n        };\n    }\n}","import { _ISelection, IValue, _IIndex, _ITable, _Transaction, _Explainer, _SelectExplanation, IndexOp, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { nullIsh } from '../utils';\n\nexport class IneqFilter<T = any> extends FilterBase<T> {\n\n    private index: _IIndex;\n    private opDef: IndexOp;\n\n    entropy(t: _Transaction) {\n        return this.onValue.index!.entropy({ ...this.opDef, t });\n    }\n\n    hasItem(item: T, t: _Transaction) {\n        const val = this.onValue.get(item, t);\n        if (nullIsh(val)) {\n            return false;\n        }\n        return !!this.onValue.type[this.op](val, this.than);\n    }\n\n    constructor(private onValue: IValue<T>\n        , private op: 'gt' | 'ge' | 'lt' | 'le'\n        , private than: any) {\n        super(onValue.origin!);\n\n        this.index = this.onValue.index!;\n        this.opDef = {\n            type: op,\n            key: [than],\n            t: null as any,\n        }\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        for (const item of this.index.enumerate({ ...this.opDef, t })) {\n            if (!this.hasItem(item, t)) {\n                break;\n            }\n            yield item;\n        }\n    }\n\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'ineq',\n            entropy: this.entropy(e.transaction),\n            on: this.onValue.index!.explain(e),\n        };\n    }\n}","import { _ISelection, IValue, _IIndex, _ITable, _Transaction, _Explainer, _SelectExplanation, IndexOp, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { nullIsh } from '../utils';\n\nexport class BetweenFilter<T = any> extends FilterBase<T> {\n\n    private opDef: IndexOp;\n\n\n    entropy(t: _Transaction) {\n        return this.onValue.index!.entropy({ ...this.opDef, t });\n    }\n\n    constructor(private onValue: IValue<T>\n        , private lo: any\n        , private hi: any\n        , private op: 'inside' | 'outside') {\n        super(onValue.origin!);\n        if (onValue.index!.expressions[0]?.hash !== onValue.hash) {\n            throw new Error('Between index misuse');\n        }\n        this.opDef = {\n            type: op,\n            hi: [hi],\n            lo: [lo],\n            t: null as any,\n        }\n    }\n\n    hasItem(value: T, t: _Transaction): boolean {\n        const v = this.onValue.get(value, t);\n        if (nullIsh(v)) {\n            return false;\n        }\n        if (this.op === 'inside') {\n            return !!this.onValue.type.ge(v, this.lo)\n                && !!this.onValue.type.le(v, this.hi);\n        }\n        return !!this.onValue.type.lt(v, this.lo)\n            || !!this.onValue.type.gt(v, this.lo);\n    }\n\n    enumerate(t: _Transaction): Iterable<T> {\n        return this.onValue.index!.enumerate({ ...this.opDef, t });\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: this.op,\n            entropy: this.entropy(e.transaction),\n            on: this.onValue.index!.explain(e),\n        };\n    }\n}\n","import { LibAdapters, IMemoryDb, NotSupported, QueryResult } from './interfaces';\nimport { literal } from './pg-escape';\nimport moment from 'moment';\nimport lru from 'lru-cache';\nimport { bufToString, isBuf } from './buffer-node';\nimport { compareVersions, nullIsh } from './utils';\ndeclare var __non_webpack_require__: any;\n\nconst delay = (time: number | undefined) => new Promise(done => setTimeout(done, time ?? 0));\n\nfunction replaceQueryArgs$(this: void, sql: string, values: any[]) {\n    return sql.replace(/\\$(\\d+)/g, (str: any, istr: any) => {\n        const i = Number.parseInt(istr);\n        if (i > values.length) {\n            throw new Error('Unmatched parameter in query ' + str);\n        }\n        const val = values[i - 1];\n        return toLiteral(val);\n    });\n}\n\nfunction toLiteral(val: any): string {\n    switch (typeof val) {\n        case 'string':\n            return literal(val);\n        case 'boolean':\n            return val ? 'true' : 'false';\n        case 'number':\n            return val.toString(10);\n        default:\n            if (nullIsh(val)) {\n                return 'null';\n            }\n            if (Array.isArray(val)) {\n                if (val.length === 0) return `'{}'`;\n                return `ARRAY[${val.map(x => toLiteral(x)).join(', ')}]`;\n            }\n            if (val instanceof Date) {\n                return `'${moment.utc(val).toISOString()}'`;\n            }\n            if (isBuf(val)) {\n                return literal(bufToString(val));\n            }\n            if (typeof val === 'object') {\n                return literal(JSON.stringify(val));\n            }\n            throw new Error('Invalid query parameter')\n    }\n}\n\nexport class Adapters implements LibAdapters {\n    private _mikroPatched?: boolean;\n\n    constructor(private db: IMemoryDb) {\n    }\n\n    createPg(queryLatency?: number): { Pool: any; Client: any } {\n        const that = this;\n        // https://node-postgres.com/features/queries\n        interface PgQuery {\n            text: string;\n            values?: any[];\n            rowMode?: 'array';\n            types?: any;\n        }\n        class MemPg {\n\n            connection = this;\n\n            on() {\n                // nop\n            }\n\n            release() {\n            }\n\n            removeListener() {\n            }\n\n            once(what: string, handler: () => void) {\n                if (what === 'connect') {\n                    setTimeout(handler, queryLatency ?? 0);\n                }\n            }\n\n            end(callback: any) {\n                if (callback) {\n                    callback();\n                    return null;\n                } else {\n                    return Promise.resolve();\n                }\n            }\n\n            connect(callback: any) {\n                if (callback) {\n                    callback(null, this, () => { });\n                    return null;\n                } else {\n                    return Promise.resolve(this);\n                }\n            }\n            query(query: any, valuesOrCallback: any, callback: any) {\n                let values: any = null;\n                if (Array.isArray(valuesOrCallback)) {\n                    values = valuesOrCallback;\n                }\n                if (callback == null && typeof valuesOrCallback === 'function') {\n                    callback = valuesOrCallback;\n                }\n\n                const pgquery = this.adaptQuery(query, values);\n                try {\n                    const result = this.adaptResults(query, that.db.public.query(pgquery.text));\n                    if (callback) {\n                        setTimeout(() => callback(null, result), queryLatency ?? 0);\n                        return null;\n                    } else {\n                        return new Promise(res => setTimeout(() => res(result), queryLatency ?? 0));\n                    }\n                } catch (e) {\n                    if (callback) {\n                        setTimeout(() => callback(e), queryLatency ?? 0);\n                        return null;\n                    } else {\n                        return new Promise((_, rej) => setTimeout(() => rej(e), queryLatency ?? 0));\n                    }\n                }\n            }\n\n            private adaptResults(query: PgQuery, res: QueryResult) {\n                if (query.rowMode) {\n                    throw new NotSupported('pg rowMode');\n                }\n                return {\n                    ...res,\n                    // clone rows to avoid leaking symbols\n                    rows: res.rows.map(row => {\n                        return Object.entries(row).reduce((obj, [key, val]) => {\n                            obj[key] = val;\n                            return obj;\n                        }, {} as any);\n                    }),\n                    get fields() {\n                        // to implement if needed ? (never seen a lib that uses it)\n                        return [];\n                    }\n                };\n            }\n\n            private adaptQuery(query: string | PgQuery, values: any): PgQuery {\n                if (typeof query === 'string') {\n                    query = {\n                        text: query,\n                        values,\n                    };\n                } else {\n                    // clean copy to avoid mutating things outside our scope\n                    query = { ...query };\n                }\n                if (!query.values?.length) {\n                    return query;\n                }\n\n                if (query.types?.getTypeParser) {\n                    throw new NotSupported('getTypeParser is not supported');\n                }\n\n                // console.log(query);\n                // console.log('\\n');\n\n                query.text = replaceQueryArgs$(query.text, query.values);\n                return query;\n            }\n        }\n        return {\n            Pool: MemPg,\n            Client: MemPg,\n        };\n    }\n\n    createTypeormConnection(postgresOptions: any, queryLatency?: number) {\n        const that = this;\n        (postgresOptions as any).postgres = that.createPg(queryLatency);\n        if (postgresOptions?.type !== 'postgres') {\n            throw new NotSupported('Only postgres supported, found ' + postgresOptions?.type ?? '<null>')\n        }\n\n        const { getConnectionManager } = __non_webpack_require__('typeorm')\n        const created = getConnectionManager().create(postgresOptions);\n        created.driver.postgres = that.createPg(queryLatency);\n        return created.connect();\n    }\n\n    createSlonik(queryLatency?: number) {\n        const { createMockPool, createMockQueryResult } = __non_webpack_require__('slonik');\n        return createMockPool({\n            query: async (sql: string, args: any[]) => {\n                await delay(queryLatency ?? 0);\n                const formatted = replaceQueryArgs$(sql, args);\n                const ret = this.db.public.many(formatted);\n                return createMockQueryResult(ret);\n            },\n        });\n    }\n\n\n    createPgPromise(queryLatency?: number) {\n        // https://vitaly-t.github.io/pg-promise/module-pg-promise.html\n        // https://github.com/vitaly-t/pg-promise/issues/743#issuecomment-756110347\n        const pgp = __non_webpack_require__('pg-promise')();\n        pgp.pg = this.createPg(queryLatency);\n        const db = pgp('pg-mem');\n        if (compareVersions('10.8.7', db.$config.version) < 0) {\n            throw new Error(` pg-mem cannot be used with pg-promise@${db.$config.version},\n\n        you must install version pg-promise@10.8.7 or newer:\n\n                npm i pg-promise@latest -S\n\n            See https://github.com/vitaly-t/pg-promise/issues/743 for details`);\n        }\n        return db;\n    }\n\n    createPgNative(queryLatency?: number) {\n        queryLatency = queryLatency ?? 0;\n        const prepared = new lru<string, string>({\n            max: 1000,\n            maxAge: 5000,\n        });\n        function handlerFor(a: any, b: any) {\n            return typeof a === 'function' ? a : b;\n        }\n        const that = this;\n        return class Client {\n            async connect(a: any, b: any) {\n                const handler = handlerFor(a, b);\n                await delay(queryLatency);\n                handler?.();\n            }\n\n            connectSync() {\n                // nop\n            }\n\n            async prepare(name: string, sql: string, npar: number, callback: any) {\n                await delay(queryLatency);\n                this.prepareSync(name, sql, npar);\n                callback();\n            }\n\n            prepareSync(name: string, sql: string, npar: number) {\n                prepared.set(name, sql);\n            }\n\n            async execute(name: string, a: any, b: any) {\n                const handler = handlerFor(a, b);\n                const pars = Array.isArray(a) ? a : [];\n                await delay(queryLatency);\n                try {\n                    const rows = this.executeSync(name, pars);\n                    handler(null, rows);\n                } catch (e) {\n                    handler(e);\n                }\n            }\n            executeSync(name: string, pars?: any) {\n                pars = Array.isArray(pars) ? pars : [];\n                const prep = prepared.get(name);\n                if (!prep) {\n                    throw new Error('Unkown prepared statement ' + name);\n                }\n                return this.querySync(prep, pars);\n            }\n\n\n            async query(sql: string, b: any, c: any) {\n                const handler = handlerFor(b, c);\n                const params = Array.isArray(b) ? b : [];\n                try {\n                    await delay(queryLatency);\n                    const result = this.querySync(sql, params);\n                    handler(null, result);\n                } catch (e) {\n                    handler?.(e);\n                }\n            }\n\n            querySync(sql: string, params: any[]) {\n                sql = replaceQueryArgs$(sql, params);\n                const ret = that.db.public.many(sql);\n                return ret;\n            }\n        }\n    }\n\n    createKnex(queryLatency?: number, knexConfig?: object): any {\n        const knex = __non_webpack_require__('knex')({\n            connection: {},\n            ...knexConfig,\n            client: 'pg',\n        });\n        knex.client.driver = this.createPg(queryLatency);\n        knex.client.version = 'pg-mem';\n        return knex;\n    }\n\n\n    async createMikroOrm(mikroOrmOptions: any, queryLatency?: number) {\n\n        const { MikroORM } = __non_webpack_require__('@mikro-orm/core');\n        const { AbstractSqlDriver, PostgreSqlConnection, PostgreSqlPlatform } = __non_webpack_require__('@mikro-orm/postgresql');\n        const that = this;\n\n        // see https://github.com/mikro-orm/mikro-orm/blob/aa71065d0727920db7da9bfdecdb33e6b8165cb5/packages/postgresql/src/PostgreSqlConnection.ts#L5\n        class PgMemConnection extends PostgreSqlConnection {\n            protected createKnexClient(type: string) {\n                return that.createKnex();\n            }\n\n        }\n        // see https://github.com/mikro-orm/mikro-orm/blob/master/packages/postgresql/src/PostgreSqlDriver.ts\n        class PgMemDriver extends AbstractSqlDriver<PgMemConnection> {\n            constructor(config: any) {\n                super(config, new PostgreSqlPlatform(), PgMemConnection, ['knex', 'pg']);\n            }\n        }\n\n        // hack: this query is not supported by pgsql-ast-parser\n        if (!this._mikroPatched) {\n            this.db.public.interceptQueries(q => {\n                if (q === `set names 'utf8';`) {\n                    return [];\n                }\n                return null;\n            });\n            this._mikroPatched = true;\n        }\n\n\n        const orm = await MikroORM.init({\n            ...mikroOrmOptions,\n            dbName: 'public',\n            driver: PgMemDriver,\n        });\n        return orm;\n    }\n\n}\n","import { _Transaction } from './interfaces-private';\nimport { Map as ImMap, Set as ImSet } from 'immutable';\nimport { NotSupported, QueryError } from './interfaces';\n\nexport class Transaction implements _Transaction {\n    private origData: ImMap<symbol, any>;\n\n    static root() {\n        return new Transaction(null, ImMap());\n    }\n\n    get isChild() {\n        return !!this.parent;\n    }\n\n    private constructor(private parent: Transaction | null, private data: ImMap<symbol, any>) {\n        this.origData = data;\n    }\n\n\n    clone() {\n        return new Transaction(null, this.data);\n    }\n\n    fork(): _Transaction {\n        return new Transaction(this, this.data);\n    }\n\n    commit(): _Transaction {\n        if (!this.parent) {\n            return this;\n        }\n        if (this.parent.data !== this.origData) {\n            throw new NotSupported('Concurrent transactions');\n        }\n        this.parent.data = this.data;\n        return this.parent;\n    }\n\n    delete(identity: symbol): void {\n        this.data = this.data.delete(identity);\n    }\n\n    set<T>(identity: symbol, data: T): T {\n        this.data = this.data.set(identity, data);\n        return data;\n    }\n\n    get<T>(identity: symbol): T {\n        return this.data.get(identity);\n    }\n\n    getMap<T extends ImMap<any, any>>(identity: symbol): T {\n        let got = this.data.get(identity);\n        if (!got) {\n            this.data = this.data.set(identity, got = ImMap());\n        }\n        return got as any as T;\n    }\n\n    getSet<T>(identity: symbol): ImSet<T> {\n        let got = this.data.get(identity);\n        if (!got) {\n            this.data = this.data.set(identity, got = ImSet());\n        }\n        return got as any;\n    }\n\n    fullCommit() {\n        const ret = this.commit();\n        return ret.isChild\n            ? ret.fullCommit()\n            : ret;\n    }\n\n    rollback () {\n        return this.parent ?? this;\n    }\n}\n","import { IValue, _ISelection, _Transaction, _Explainer, _SelectExplanation, Stats, nil } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { LimitStatement } from 'pgsql-ast-parser';\nimport { buildValue } from '../expression-builder';\n\nexport function buildLimit(on: _ISelection, limit: LimitStatement) {\n    const l = limit.limit && buildValue(on, limit.limit);\n    const o = limit.offset && buildValue(on, limit.offset);\n    return new LimitFilter(on, l, o);\n}\n\nclass LimitFilter<T = any> extends FilterBase<T> {\n\n    get index() {\n        return null;\n    }\n\n    entropy(t: _Transaction) {\n        return this.selection.entropy(t);\n    }\n\n    hasItem(raw: T, t: _Transaction): boolean {\n        return this.base.hasItem(raw, t);\n    }\n\n    constructor(private selection: _ISelection<T>, private take: IValue | nil, private skip: IValue | nil) {\n        super(selection);\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        let skip = this.skip?.get(null, t) ?? 0;\n        let take = this.take?.get(null, t) ?? Number.MAX_SAFE_INTEGER;\n        if (take <= 0) {\n            return;\n        }\n        for (const raw of this.selection.enumerate(t)) {\n            if (skip > 0) {\n                skip--;\n                continue;\n            }\n            yield raw;\n            take--;\n            if (!take) {\n                return;\n            }\n        }\n    }\n\n\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'limit',\n            take: this.take?.explain(e),\n            skip: this.skip?.explain(e),\n            on: this.selection.explain(e),\n        };\n    }\n}","import { IValue, _ISelection, _Transaction, _Explainer, _SelectExplanation, Stats, _IIndex, _IType, setId, getId } from '../interfaces-private';\nimport { DataSourceBase } from './transform-base';\nimport { ColumnNotFound, nil, NotSupported, QueryError } from '../interfaces';\nimport { columnEvaluator } from './selection';\nimport { reconciliateTypes } from '../datatypes/datatypes';\nimport { ExprRef } from 'pgsql-ast-parser';\nimport { colByName } from '../utils';\n\n// https://www.postgresql.org/docs/current/typeconv-union-case.html\nexport function buildUnion(left: _ISelection, right: _ISelection) {\n    if (left.columns.length !== right.columns.length) {\n        throw new QueryError('each UNION query must have the same number of columns');\n    }\n    const cols: UCol[] = Array(left.columns.length);\n    for (let i = 0; i < left.columns.length; i++) {\n        const l = left.columns[i];\n        const r = right.columns[i];\n\n        const type = reconciliateTypes([l, r], true);\n        if (!type) {\n            throw new QueryError(`UNION types ${l.type.name} and ${r.type.name} cannot be matched`);\n        }\n        cols[i] = {\n            name: l.id ?? ('column' + i),\n            type,\n            lval: l.convert(type),\n            rval: r.convert(type),\n        };\n    }\n    return new Union(cols, left, right);\n}\n\ninterface UCol {\n    name: string;\n    type: _IType;\n    lval: IValue;\n    rval: IValue;\n}\n\nclass Union<T = any> extends DataSourceBase<T> {\n\n    readonly columns: ReadonlyArray<IValue<any>>;\n    private readonly colsByName = new Map<string, IValue>();\n\n    entropy(t: _Transaction) {\n        return this.left.entropy(t) + this.right.entropy(t);\n    }\n\n    hasItem(raw: T, t: _Transaction): boolean {\n        return this.left.hasItem(raw, t) || this.right.hasItem(raw, t);\n    }\n\n    constructor(private cols: UCol[]\n        , private left: _ISelection\n        , private right: _ISelection) {\n        super(left.ownerSchema);\n        this.columns = cols.map(x => columnEvaluator(this, x.name, x.type));\n        for (const c of this.columns) {\n            this.colsByName.set(c.id!, c);\n        }\n    }\n\n    stats(t: _Transaction): Stats | null {\n        return null;\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        for (const raw of this.left.enumerate(t)) {\n            const ret = {} as any;\n            setId(ret, getId(raw));\n            for (const c of this.cols) {\n                ret[c.name] = c.lval.get(raw, t);\n            }\n            yield ret;\n        }\n        for (const raw of this.right.enumerate(t)) {\n            const ret = {} as any;\n            setId(ret, getId(raw));\n            for (const c of this.cols) {\n                ret[c.name] = c.rval.get(raw, t);\n            }\n            yield ret;\n        }\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'union',\n            union: [this.left.explain(e),\n            this.right.explain(e)],\n        };\n    }\n\n    getColumn(column: string | ExprRef): IValue;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;\n    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue<any> | nil {\n        return colByName(this.colsByName, column, nullIfNotFound);\n    }\n\n    getIndex(...forValue: IValue<any>[]): _IIndex<any> | null | undefined {\n        // todo use indices on unions\n        return null;\n    }\n\n    isOriginOf(a: IValue<any>): boolean {\n        return a.origin === this || this.left.isOriginOf(a);\n    }\n}\n","import { Expr } from 'pgsql-ast-parser';\nimport { buildValue } from '../expression-builder';\nimport { IValue, Stats, _Explainer, _ISelection, _SelectExplanation, _Transaction } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport objectHash from 'object-hash';\n\nexport function buildDistinct(on: _ISelection, exprs?: Expr[]) {\n    const vals = exprs && exprs.length > 0\n        ? exprs.map(v => buildValue(on, v))\n        : on.columns\n    return new Distinct(on, vals);\n}\n\n\n// todo: use indices to optimize this (avoid iterating everything)\n\nclass Distinct<T> extends FilterBase<any> {\n\n    get index() {\n        return null;\n    }\n\n    entropy(t: _Transaction) {\n        // cant foresight how many items will be filtered\n        //  => just asumme nothing will be.\n        return this.base.entropy(t);\n    }\n\n    hasItem(raw: T, t: _Transaction): boolean {\n        return this.base.hasItem(raw, t);\n    }\n\n    constructor(selection: _ISelection<any>, private exprs: ReadonlyArray<IValue>) {\n        super(selection);\n    }\n\n    stats(t: _Transaction): Stats | null {\n        return this.base.stats(t);\n    }\n\n    *enumerate(t: _Transaction): Iterable<T> {\n        const got = new Set();\n        for (const i of this.base.enumerate(t)) {\n            const vals = this.exprs.map(v => v.type.hash(v.get(i, t)));\n            const hash = vals.length === 1 ? vals[0] : objectHash(vals);\n            if (got.has(hash)) {\n                continue;\n            }\n            got.add(hash);\n            yield i;\n        }\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'distinct',\n            of: this.base.explain(e),\n        };\n    }\n}","import { IValue, _ISelection, _Transaction, _Explainer, _SelectExplanation, Stats } from '../interfaces-private';\nimport { FilterBase } from './transform-base';\nimport { OrderByStatement } from 'pgsql-ast-parser';\nimport { buildValue } from '../expression-builder';\nimport { nullIsh } from '../utils';\n\nexport function buildOrderBy(on: _ISelection, order: OrderByStatement[]) {\n    return new OrderBy(on, order);\n}\n\nclass OrderBy<T> extends FilterBase<any> {\n    order: { by: IValue<any>; order: 'ASC' | 'DESC'; }[];\n\n    get index() {\n        return null;\n    }\n\n    entropy(t: _Transaction) {\n        const ret = this.selection.entropy(t);\n        // sort algorithm is n*log(n)\n        return ret * Math.log(ret + 1);\n    }\n\n    hasItem(raw: T, t: _Transaction): boolean {\n        return this.base.hasItem(raw, t);\n    }\n\n    constructor(private selection: _ISelection<T>, order: OrderByStatement[]) {\n        super(selection);\n        this.order = order.map(x => ({\n            by: buildValue(selection, x.by),\n            order: x.order ?? 'ASC',\n        }))\n    }\n\n\n    stats(t: _Transaction): Stats | null {\n        return this.base.stats(t);\n    }\n\n    enumerate(t: _Transaction): Iterable<T> {\n        const all = [...this.base.enumerate(t)];\n        all.sort((a, b) => {\n            for (const o of this.order) {\n                const aval = o.by.get(a, t);\n                const bval = o.by.get(b, t);\n                const na = nullIsh(aval);\n                const nb = nullIsh(bval);\n                if (na && nb) {\n                    continue;\n                }\n                if (na || nb) {\n                    return (o.order === 'ASC') === na ? 1 : -1;\n                }\n                if (o.by.type.equals(aval, bval)) {\n                    continue;\n                }\n                if (o.by.type.gt(aval, bval)) {\n                    return o.order === 'ASC' ? 1 : -1;\n                }\n                return o.order === 'ASC' ? -1 : 1;\n            }\n            return 0;\n        });\n        return all;\n    }\n\n    explain(e: _Explainer): _SelectExplanation {\n        return {\n            id: e.idFor(this),\n            _: 'orderBy',\n            of: this.selection.explain(e),\n        };\n    }\n}","import { Types } from '../../datatypes';\nimport { DataType, FunctionDefinition, _IDb, _ISchema } from '../../interfaces-private';\nimport { PgAttributeTable } from './pg-attribute-list';\nimport { PgClassListTable } from './pg-class';\nimport { PgConstraintTable } from './pg-constraints-list';\nimport { PgIndexTable } from './pg-index-list';\nimport { PgNamespaceTable } from './pg-namespace-list';\nimport { PgTypeTable } from './pg-type-list';\nimport { allFunctions } from '../../functions';\nimport { PgRange } from './pg-range';\nimport { sqlSubstring } from '../../expression-builder';\nimport { PgDatabaseTable } from './pg-database';\n\n\nexport function setupPgCatalog(db: _IDb) {\n    const catalog: _ISchema = db.createSchema('pg_catalog');\n\n    catalog._registerType(Types.bool)\n        ._registerType(Types.citext)\n        ._registerType(Types.timestamp)\n        ._registerType(Types.uuid)\n        ._registerType(Types.date)\n        ._registerType(Types.time)\n        ._registerType(Types.jsonb)\n        ._registerType(Types.regtype)\n        ._registerType(Types.regclass)\n        ._registerType(Types.json)\n        ._registerType(Types.null)\n        ._registerType(Types.float)\n        ._registerType(Types.integer)\n        ._registerType(Types.bigint)\n        ._registerType(Types.bytea)\n        ._registerType(Types.point)\n        ._registerType(Types.line)\n        ._registerType(Types.lseg)\n        ._registerType(Types.box)\n        ._registerType(Types.path)\n        ._registerType(Types.polygon)\n        ._registerType(Types.circle)\n        ._registerType(Types.interval)\n        ._registerType(Types.record)\n        ._registerType(Types.inet)\n        ._registerTypeSizeable(DataType.text, Types.text)\n\n    new PgConstraintTable(catalog).register();\n    new PgClassListTable(catalog).register();\n    new PgNamespaceTable(catalog).register();\n    new PgAttributeTable(catalog).register();\n    new PgIndexTable(catalog).register();\n    new PgTypeTable(catalog).register();\n    new PgRange(catalog).register();\n    new PgDatabaseTable(catalog).register();\n\n\n    // this is an ugly hack...\n    const tbl = catalog.declareTable({\n        name: 'current_schema',\n        fields: [\n            { name: 'current_schema', type: Types.text() },\n        ]\n    }, true);\n    tbl.insert({ current_schema: 'public' });\n    tbl.setHidden().setReadonly();\n\n    addFns(catalog, allFunctions);\n\n    catalog.registerFunction({\n        name: 'set_config',\n        args: [Types.text(), Types.text(), Types.bool],\n        returns: Types.text(),\n        impure: true,\n        implementation: (cfg: string, val: string, is_local: boolean) => {\n            // todo - implement this... used to override search_path in dumps.\n            //       => have a dynamic search_path.\n            //       => not trivial du to the \"is_local\" arg\n            //  https://www.postgresql.org/docs/9.3/functions-admin.html\n            return val;\n        }\n    });\n\n    catalog.registerFunction({\n        name: 'substring',\n        args: [Types.text(), Types.integer],\n        returns: Types.text(),\n        implementation: sqlSubstring,\n    })\n\n    catalog.registerFunction({\n        name: 'substring',\n        args: [Types.text(), Types.integer, Types.integer],\n        returns: Types.text(),\n        implementation: sqlSubstring,\n    })\n\n\n    db.getSchema('pg_catalog').registerFunction({\n        name: 'col_description',\n        args: [DataType.integer, DataType.integer],\n        returns: DataType.text,\n        implementation: x => 'Fake description provided by pg-mem',\n    });\n    catalog.setReadonly()\n}\n\nfunction addFns(catalog: _ISchema, fns: FunctionDefinition[]) {\n    for (const f of fns) {\n        catalog.registerFunction(f);\n    }\n}","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _ISchema } from '../../interfaces-private';\nimport {  nil, Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { ReadOnlyTable } from '../readonly-table';\n\nexport class PgAttributeTable extends ReadOnlyTable implements _ITable {\n\n    _schema: Schema = {\n        name: 'pg_attribute',\n        fields: [\n            { name: 'attrelid', type: Types.integer } // oid\n            , { name: 'attname', type: Types.text() }\n            , { name: 'atttypid', type: Types.integer } // oid\n            , { name: 'attstattarget', type: Types.integer }\n            , { name: 'attlen', type: Types.integer }\n            , { name: 'attnum', type: Types.integer }\n            , { name: 'attndims', type: Types.integer }\n            , { name: 'attcacheoff', type: Types.integer }\n            , { name: 'atttypmod', type: Types.integer }\n            , { name: 'attbyval', type: Types.bool }\n            , { name: 'attstorage', type: Types.text(1) } // char(1)\n            , { name: 'attalign', type: Types.text(1) } // char(1)\n            , { name: 'attnotnull', type: Types.bool }\n            , { name: 'atthasdef', type: Types.bool }\n            , { name: 'atthasmissing', type: Types.bool }\n            , { name: 'attidntity', type: Types.text(1) } // char(1)\n            , { name: 'attisdroppd', type: Types.bool }\n            , { name: 'attislocal', type: Types.bool }\n            , { name: 'attinhcount', type: Types.integer }\n            , { name: 'attcollation', type: Types.integer } // oid\n            , { name: 'attacl', type: Types.jsonb } // aclitem[]\n            , { name: 'attoptions', type: Types.text().asArray() }\n            , { name: 'attfdwoptions', type: Types.text().asArray() }\n            , { name: 'attmissingval', type: Types.jsonb }// anyarray\n        ]\n    };\n\n\n    entropy(): number {\n        return 0;\n    }\n\n    *enumerate() {\n    }\n\n    hasItem(value: any): boolean {\n        return false;\n    }\n\n    getIndex(forValue: IValue<any>): _IIndex<any> | nil {\n        return null;\n    }\n\n}\n","import { _ITable, _ISelection, _IIndex, _IDb, _ISchema, _Transaction } from '../../interfaces-private';\nimport { Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { ReadOnlyTable } from '../readonly-table';\n\n// https://www.postgresql.org/docs/12/catalog-pg-class.html\n\nconst IS_SCHEMA = Symbol('_is_pg_classlist');\nexport class PgClassListTable extends ReadOnlyTable implements _ITable {\n\n    get ownSymbol() {\n        return IS_SCHEMA;\n    }\n\n\n    _schema: Schema = {\n        name: 'pg_class',\n        fields: [\n            { name: 'oid', type: Types.integer } // hidden oid column\n            , { name: 'relname', type: Types.text() }\n            , { name: 'relnamespace', type: Types.integer } // oid\n            , { name: 'reltype', type: Types.integer } // oid\n            , { name: 'reloftype', type: Types.integer } // oid\n            , { name: 'relowner', type: Types.integer } // oid\n            , { name: 'relam', type: Types.integer } // oid\n            , { name: 'relfilenode', type: Types.integer } // oid\n            , { name: 'reltablespace', type: Types.integer } // oid\n            , { name: 'relpages', type: Types.integer }\n            , { name: 'reltyples', type: Types.integer }\n            , { name: 'relallvisible', type: Types.integer }\n            , { name: 'reltoastrelid', type: Types.integer }\n            , { name: 'relhashindex', type: Types.bool }\n            , { name: 'relisshared', type: Types.bool }\n            , { name: 'relpersistence', type: Types.text(1) } // char(1)\n            , { name: 'relkind', type: Types.text(1) } // char(1)\n            , { name: 'relnatts', type: Types.integer }\n            , { name: 'relchecks', type: Types.integer }\n            , { name: 'relhasoids', type: Types.bool }\n            , { name: 'relhasrules', type: Types.bool }\n            , { name: 'relhastriggers', type: Types.bool }\n            , { name: 'relhassubclass', type: Types.bool }\n            , { name: 'relrowsecurity', type: Types.bool }\n            , { name: 'relforcerowsecurity', type: Types.bool }\n            , { name: 'relispopulated', type: Types.bool }\n            , { name: 'relreplident', type: Types.text(1) } // char(1)\n            , { name: 'relispartition', type: Types.bool }\n            , { name: 'relrewrite', type: Types.integer } // oid\n            , { name: 'relfrozenxid', type: Types.integer } // xid\n            , { name: 'relminmxid', type: Types.integer } // xid\n            , { name: 'relacl', type: Types.text() } // alitem[]\n            , { name: 'reloptions', type: Types.text().asArray() } // text[]\n            , { name: 'relpartbound', type: Types.jsonb } // pg_nod_tr\n        ]\n    };\n\n    // private indexes: { [key: string]: _IIndex } = {\n    //     'oid': new CustomIndex(this, {\n    //         get size() {\n    //             return this.size\n    //         },\n    //         column: this.selection.getColumn('oid'),\n    //         byColumnValue: (oid: string, t: _Transaction) => {\n    //             return [this.byOid(oid, t)]\n    //         }\n    //     }),\n    //     'relname': new CustomIndex(this, {\n    //         get size() {\n    //             return this.size\n    //         },\n    //         column: this.selection.getColumn('relname'),\n    //         byColumnValue: (oid: string, t: _Transaction) => {\n    //             return [this.byRelName(oid, t)];\n    //         }\n    //     }),\n    // }\n\n\n\n    // private byOid(oid: string, t: _Transaction) {\n    //     const { type, id } = parseOid(oid);\n    //     switch (type) {\n    //         case 'table':\n    //             return this.makeTable(this.schema.getTable(id, true)!);\n    //         case 'index':\n    //             return null;\n    //         // return this.makeTable(this.db.getIndex(id, true));\n    //         default:\n    //             throw NotSupported.never(type);\n    //     }\n    // }\n\n    // private byRelName(name: string, t: _Transaction) {\n    //     return this.schema.getTable(name, true);\n    //     // ?? this.db.getIndex(name, true);\n    // }\n\n    entropy(t: _Transaction): number {\n        return 0;\n    }\n\n    *enumerate() {\n        // for (const t of this.db.listTables()) {\n        //     yield this.makeTable(t);\n        // }\n    }\n\n\n    makeInedx(t: _IIndex<any>): any {\n        if (!t) {\n            return null;\n        }\n        // relkind , i = index, S = sequence, t = TOAST table, v = view, m = materialized view, c = composite type, f = foreign table, p = partitioned table, I = partitioned index\n        throw new Error('todo');\n    }\n    makeTable(t: _ITable<any>): any {\n        if (!t) {\n            return null;\n        }\n        throw new Error('todo');\n        // const ret = {\n        //     relname: t.name,\n        //     relnamespace: t instanceof MemoryTable\n        //         ? MAIN_NAMESPACE\n        //         : SCHEMA_NAMESPACE,\n        //     relkind: 'r', //  r = ordinary table\n        //     [IS_SCHEMA]: true,\n        // };\n        // return setId(ret, '/schema/pg_class/table/' + t.name);\n    }\n\n    hasItem(value: any): boolean {\n        return !!value?.[IS_SCHEMA];\n    }\n\n}\n","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _ISchema, _Transaction } from '../../interfaces-private';\nimport {  nil, Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { TableIndex } from '../table-index';\nimport { ReadOnlyTable } from '../readonly-table';\n\nconst IS_SCHEMA = Symbol('_is_pgconstraint');\nexport class PgConstraintTable extends ReadOnlyTable implements _ITable {\n\n    get ownSymbol() {\n        return IS_SCHEMA;\n    }\n\n    _schema: Schema = {\n        name: 'pg_constraint',\n        fields: [\n            { name: 'oid', type: Types.integer } // hidden oid column\n            , { name: 'conname', type: Types.text() } // <== 'name' type\n            , { name: 'connamespace', type: Types.integer } // <== 'oid' type\n            , { name: 'contype', type: Types.text(1) } // <== 'char(1)' type\n            , { name: 'condeferrable', type: Types.bool }\n            , { name: 'condeferred', type: Types.bool }\n            , { name: 'convalidated', type: Types.bool }\n            , { name: 'conrelid', type: Types.integer } // <== oid\n            , { name: 'contypid', type: Types.integer } // <== oid\n            , { name: 'conindid', type: Types.integer } // <== oid\n            , { name: 'conparentid', type: Types.integer } // <== oid\n            , { name: 'confrelid', type: Types.integer } // <== oid\n            , { name: 'confupdtype', type: Types.text(1) } // <== 'char(1)' type\n            , { name: 'confdeltype', type: Types.text(1) } // <== 'char(1)' type\n            , { name: 'confmatchtype', type: Types.text(1) } // <== 'char(1)' type\n            , { name: 'conislocal', type: Types.bool }\n            , { name: 'coninhcount', type: Types.integer }\n            , { name: 'connoinherit', type: Types.bool }\n            , { name: 'conkey', type: Types.integer.asArray() }\n            , { name: 'confkey', type: Types.integer.asArray() }\n            , { name: 'conpfeqop', type: Types.integer.asArray() } // <== oid[]\n            , { name: 'conppeqop', type: Types.integer.asArray() } // <== oid[]\n            , { name: 'conffeqop', type: Types.integer.asArray() } // <== oid[]\n            , { name: 'conexclop', type: Types.integer.asArray() } // <== oid[]\n            , { name: 'conbin', type: Types.text() } // <== weird type\n            , { name: 'consrc', type: Types.text() }\n        ]\n    };\n\n\n    entropy(t: _Transaction): number {\n        return this.db.listSchemas()\n            .reduce((tot, s) => tot + s.tablesCount(t) * 10 * 3, 0);\n    }\n\n    *enumerate(t: _Transaction) {\n        for (const schema of this.db.listSchemas()) {\n            for (const it of schema.listTables(t)) {\n                yield* this.itemsByTable(it, t);\n            }\n        }\n    }\n\n    make(table: _ITable, i: number, t: IValue<any>): any {\n        if (!t) {\n            return null;\n        }\n        let ret = {};\n        for (const { name } of this._schema.fields) {\n            (ret as any)[name] = null;\n        }\n\n        ret = {\n            ...ret,\n            // table_catalog: 'pgmem',\n\n            [IS_SCHEMA]: true,\n        };\n        setId(ret, `/schema/${table.ownerSchema.name}/pg_constraint/${table.name}/${i}`);\n        return ret;\n    }\n\n    hasItem(value: any): boolean {\n        return !!value?.[IS_SCHEMA];\n    }\n\n    getIndex(forValue: IValue<any>): _IIndex<any> | nil {\n        if (forValue.id === 'table_name') {\n            return new TableIndex(this, forValue);\n        }\n        return null;\n    }\n\n}\n","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _ISchema } from '../../interfaces-private';\nimport { Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { ReadOnlyTable } from '../readonly-table';\n\nexport class PgIndexTable extends ReadOnlyTable implements _ITable {\n\n    _schema: Schema = {\n        name: 'pg_index',\n        fields: [\n            { name: 'indexrelid', type: Types.integer } // oid\n            , { name: 'indrelid', type: Types.integer } // oid\n            , { name: 'indnatts', type: Types.integer }\n            , { name: 'indnkyatts', type: Types.integer }\n            , { name: 'indisunique', type: Types.bool }\n            , { name: 'indisprimary', type: Types.bool }\n            , { name: 'indisxclusion', type: Types.bool }\n            , { name: 'indimmediate', type: Types.bool }\n            , { name: 'indisclustered', type: Types.bool }\n            , { name: 'indisvalid', type: Types.bool }\n            , { name: 'indcheckxmin', type: Types.bool }\n            , { name: 'indisready', type: Types.bool }\n            , { name: 'indisliv', type: Types.bool }\n            , { name: 'indisreplident', type: Types.bool }\n            , { name: 'indkey', type: Types.integer.asArray() } // int2vector\n            , { name: 'indcollation', type: Types.integer.asArray() } // oidvector\n            , { name: 'indclass', type: Types.integer.asArray() } // oidvector\n            , { name: 'indoption', type: Types.integer.asArray() } // int2vector\n            , { name: 'indeexprs', type: Types.jsonb } // pg_node_tree\n            , { name: 'indpred', type: Types.jsonb } // pg_node_tree\n        ]\n    };\n\n    entropy(): number {\n        return 0;\n    }\n\n    *enumerate() {\n    }\n\n\n\n    hasItem(value: any): boolean {\n        return false;\n    }\n\n}\n","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _ISchema } from '../../interfaces-private';\nimport { Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { ReadOnlyTable } from '../readonly-table';\n\nexport class PgNamespaceTable extends ReadOnlyTable implements _ITable {\n\n    _schema: Schema = {\n        name: 'pg_namespace',\n        fields: [\n            { name: 'oid', type: Types.integer } // hidden oid column\n            , { name: 'nspname', type: Types.text() }\n            , { name: 'nspowner', type: Types.integer } // oid\n            , { name: 'nspacl', type: Types.jsonb } // aclitem[]\n        ]\n    };\n\n\n    entropy(): number {\n        return 0;\n    }\n\n    *enumerate() {\n\n        // yield {\n        //     oid: MAIN_NAMESPACE,\n        //     nspname: 'public',\n        //     nspowner: null,\n        //     nspacl: null,\n        // };\n        // yield {\n        //     oid: MAIN_NAMESPACE,\n        //     nspname: 'public',\n        //     nspowner: null,\n        //     nspacl: null,\n        // };\n    }\n\n\n\n    hasItem(value: any): boolean {\n        return false;\n    }\n}\n","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _ISchema } from '../../interfaces-private';\nimport { Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { ReadOnlyTable } from '../readonly-table';\n\nexport class PgTypeTable extends ReadOnlyTable implements _ITable {\n\n\n    _schema: Schema = {\n        name: 'pg_type',\n        fields: [\n            { name: 'oid', type: Types.integer } // hiddn oid column\n            , { name: 'typname', type: Types.text() }\n            , { name: 'typnamespace', type: Types.integer } // oid\n            , { name: 'typowner', type: Types.integer } // oid\n            , { name: 'typlen', type: Types.integer }\n            , { name: 'typbyval', type: Types.bool }\n            , { name: 'typtype', type: Types.text(1) } // char(1)\n            , { name: 'typispreferred', type: Types.bool }\n            , { name: 'typisdefined', type: Types.bool }\n            , { name: 'typdlim', type: Types.text(1) } // char(1)\n            , { name: 'typrelid', type: Types.integer } // oid\n            , { name: 'typelem', type: Types.integer } // oid\n            , { name: 'typarray', type: Types.integer } // oid\n            , { name: 'typinput', type: Types.text() } // regproc\n            , { name: 'typoutput', type: Types.text() } // regproc\n            , { name: 'typreceive', type: Types.text() } // regproc\n            , { name: 'typsend', type: Types.text() } // regproc\n            , { name: 'typmodin', type: Types.text() } // regproc\n            , { name: 'typmodout', type: Types.text() } // regproc\n            , { name: 'typanalyze', type: Types.text() } // regproc\n            , { name: 'typalign', type: Types.text(1) } // char(1)\n            , { name: 'typstorage', type: Types.text(1) } // char(1)\n            , { name: 'typnotnull', type: Types.bool }\n            , { name: 'typbasetype', type: Types.integer } //oid\n            , { name: 'typtypmod', type: Types.integer }\n            , { name: 'typndims', type: Types.integer }\n            , { name: 'typcollation', type: Types.integer } // oid\n            , { name: 'typdfaultbin', type: Types.text() } // pg_nod_tree\n            , { name: 'typdefault', type: Types.text() }\n            , { name: 'typacl', type: Types.jsonb }\n        ]\n    };\n\n\n    entropy(): number {\n        return 0;\n    }\n\n    *enumerate() {\n    }\n\n\n\n    hasItem(value: any): boolean {\n        return false;\n    }\n\n}\n","import { stringFunctions } from './string';\nimport { dateFunctions } from './date';\nimport { systemFunctions } from './system';\nimport { sequenceFunctions } from './sequence-fns';\n\n\nexport const allFunctions = [\n    ...stringFunctions\n    , ... dateFunctions\n    , ... systemFunctions\n    , ... sequenceFunctions\n]","import { DataType, FunctionDefinition } from '../interfaces-private';\n\nexport const stringFunctions: FunctionDefinition[] = [\n    {\n        name: 'lower',\n        args: [DataType.text],\n        returns: DataType.text,\n        implementation: (x: string) => x?.toLowerCase(),\n    },\n    {\n        name: 'upper',\n        args: [DataType.text],\n        returns: DataType.text,\n        implementation: (x: string) => x?.toUpperCase(),\n    },\n    {\n        name: 'concat',\n        args: [DataType.text],\n        argsVariadic: DataType.text,\n        returns: DataType.text,\n        implementation: (...x: string[]) => x?.join(''),\n    },\n]","import { FunctionDefinition } from '../interfaces';\nimport moment from 'moment';\nimport { DataType, QueryError } from '../interfaces-private';\n\n\nexport const dateFunctions: FunctionDefinition[] = [\n    {\n        name: 'to_date',\n        args: [DataType.text, DataType.text],\n        returns: DataType.date,\n        implementation: (data, format) => {\n            if ((data ?? null) === null || (format ?? null) === null) {\n                return null; // if one argument is null => null\n            }\n            const ret = moment.utc(data, format);\n            if (!ret.isValid()) {\n                throw new QueryError(`The text '${data}' does not match the date format ${format}`);\n            }\n            return ret.toDate();\n        }\n    },\n    {\n        name: 'now',\n        returns: DataType.timestamp,\n        impure: true,\n        implementation: () => new Date(),\n    },\n];","import { Types } from '../datatypes';\nimport { FunctionDefinition } from '../interfaces';\n\nexport const systemFunctions: FunctionDefinition[] = [\n    {\n        // ugly hack...\n        name: 'current_schema',\n        returns: Types.text(),\n        implementation: () => 'public',\n    },\n]\n","import { getContext } from '../utils';\nimport { Types } from '../datatypes';\nimport { FunctionDefinition, QueryError } from '../interfaces';\nimport { asSeq, RegClass, _ISequence } from '../interfaces-private';\n\n// https://www.postgresql.org/docs/8.1/functions-sequence.html\n\nfunction getSeq(id: RegClass) {\n    const { transaction, schema } = getContext();\n    if (!transaction) {\n        throw new QueryError('cannot query sequence value in this context');\n    }\n    return {\n        t: transaction,\n        seq: asSeq(schema.getObjectByRegOrName(id)),\n    };\n}\nconst lastVal = Symbol();\nexport const sequenceFunctions: FunctionDefinition[] = [\n\n    {\n        name: 'nextval',\n        args: [Types.regclass],\n        returns: Types.integer,\n        implementation: (seqId: RegClass) => {\n            const { seq, t } = getSeq(seqId);\n            const ret = seq.nextValue(t);\n            t.set(lastVal, ret);\n            return ret;\n        },\n        impure: true,\n    },\n    {\n        name: 'currval',\n        args: [Types.regclass],\n        returns: Types.integer,\n        implementation: (seqId: RegClass) => {\n            const { seq, t } = getSeq(seqId);\n            return seq.currentValue(t);\n        },\n        impure: true,\n    },\n    {\n        name: 'lastval',\n        returns: Types.integer,\n        implementation: (seqId: RegClass) => {\n            const { transaction } = getContext();\n            if (!transaction) {\n                throw new QueryError('cannot query lastval in this context');\n            }\n            return transaction.get<number>(lastVal);\n        },\n        impure: true,\n    },\n    {\n        name: 'setval',\n        args: [Types.regclass, Types.integer],\n        returns: Types.integer,\n        implementation: (seqId: RegClass, val: number) => {\n            const { seq, t } = getSeq(seqId);\n            if (typeof val !== 'number') {\n                throw new QueryError('Invalid setval() value');\n            }\n            seq.setValue(t, val);\n            return val;\n        },\n        impure: true,\n    },\n]\n","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _ISchema } from '../../interfaces-private';\nimport { Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { ReadOnlyTable } from '../readonly-table';\n\n// https://www.postgresql.org/docs/13/catalog-pg-range.html\nexport class PgRange extends ReadOnlyTable implements _ITable {\n\n\n    _schema: Schema = {\n        name: 'pg_range',\n        fields: [\n            { name: 'rngtypid', type: Types.integer } // oid\n            , { name: 'rngsubtype', type: Types.integer } // oid\n            , { name: 'rngcollation', type: Types.integer } // oid\n            , { name: 'rngsubopc', type: Types.integer } // oid\n            , { name: 'rngcanonical', type: Types.integer } // oid\n            , { name: 'rngsubdiff', type: Types.integer } // oid\n        ]\n    };\n\n\n    entropy(): number {\n        return 0;\n    }\n\n    *enumerate() {\n    }\n\n\n\n    hasItem(value: any): boolean {\n        return false;\n    }\n\n}\n","import { _ITable, _ISelection, _IIndex, _IDb, _ISchema, _Transaction, setId } from '../../interfaces-private';\nimport { Schema } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { ReadOnlyTable } from '../readonly-table';\n\n// https://www.postgresql.org/docs/12/catalog-pg-class.html\n\nconst IS_SCHEMA = Symbol('_is_pg_database');\nexport class PgDatabaseTable extends ReadOnlyTable implements _ITable {\n\n    get ownSymbol() {\n        return IS_SCHEMA;\n    }\n\n\n    _schema: Schema = {\n        name: 'pg_database',\n        fields: [\n            { name: 'oid', type: Types.integer } // hidden oid column\n            , { name: 'datname', type: Types.text() }\n            , { name: 'datdba', type: Types.integer }\n            , { name: 'encoding', type: Types.integer }\n            , { name: 'datcollate', type: Types.text() }\n            , { name: 'datctype', type: Types.text() }\n            , { name: 'datistemplate', type: Types.bool }\n            , { name: 'datlowconn', type: Types.bool }\n            , { name: 'datconlimit', type: Types.integer }\n            , { name: 'datlastsysoid', type: Types.integer }\n            , { name: 'datfrozenxid', type: Types.integer }\n            , { name: 'datminmxid', type: Types.integer }\n            , { name: 'dattablespace', type: Types.integer }\n            , { name: 'datacl', type: Types.jsonb }\n        ]\n    };\n\n    entropy(t: _Transaction): number {\n        return this.db.listSchemas().length;\n    }\n\n    *enumerate() {\n        // this is , whaterver...\n        let i = 48593;\n        for (const t of this.db.listSchemas()) {\n            const ret = {\n                oid: ++i,\n                datname: t.name,\n                [IS_SCHEMA]: true,\n            };\n            yield setId(ret, '/schema/pg_database/' + t.name);\n        }\n    }\n\n\n    hasItem(value: any): boolean {\n        return !!value?.[IS_SCHEMA];\n    }\n}\n","\nimport { _IDb, _ISchema } from '../../interfaces-private';\nimport { ColumnsListSchema } from './columns-list';\nimport { TablesSchema } from './table-list';\n\nexport function setupInformationSchema(db: _IDb) {\n    const schema: _ISchema = db.createSchema('information_schema');\n\n    // SELECT * FROM \"information_schema\".\"tables\" WHERE (\"table_schema\" = 'public' AND \"table_name\" = 'user')\n    new TablesSchema(schema).register();\n    new ColumnsListSchema(schema).register();\n\n    schema.setReadonly();\n}","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _Transaction, _ISchema } from '../../interfaces-private';\nimport { Schema, nil } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { TableIndex } from '../table-index';\nimport { ReadOnlyTable } from '../readonly-table';\n\nconst IS_SCHEMA = Symbol('_is_colmun');\nexport class ColumnsListSchema extends ReadOnlyTable implements _ITable {\n\n    get ownSymbol() {\n        return IS_SCHEMA;\n    }\n\n    _schema: Schema = {\n        name: 'columns',\n        fields: [\n            { name: 'table_catalog', type: Types.text() }\n            , { name: 'table_schema', type: Types.text() }\n            , { name: 'table_name', type: Types.text() }\n            , { name: 'column_name', type: Types.text() }\n            , { name: 'ordinal_position', type: Types.integer }\n            , { name: 'column_default', type: Types.text() }\n            , { name: 'is_nullable', type: Types.text(3) }\n            , { name: 'data_type', type: Types.text() }\n            , { name: 'character_maximum_length', type: Types.integer }\n            , { name: 'character_octet_length', type: Types.integer }\n            , { name: 'numeric_precision', type: Types.integer }\n            , { name: 'numeric_precision_radix', type: Types.integer }\n            , { name: 'numeric_scale', type: Types.integer }\n            , { name: 'datetime_precision', type: Types.integer }\n            , { name: 'interval_type', type: Types.text() }\n            , { name: 'interval_precision', type: Types.integer }\n            , { name: 'character_set_catalog', type: Types.text() }\n            , { name: 'character_set_schema', type: Types.text() }\n            , { name: 'character_set_name', type: Types.text() }\n            , { name: 'collation_catalog', type: Types.text() }\n            , { name: 'collation_schema', type: Types.text() }\n            , { name: 'collation_name', type: Types.text() }\n            , { name: 'domain_catalog', type: Types.text() }\n            , { name: 'domain_schema', type: Types.text() }\n            , { name: 'domain_name', type: Types.text() }\n            , { name: 'udt_catalog', type: Types.text() } // <====\n            , { name: 'udt_schema', type: Types.text() } // <====\n            , { name: 'udt_name', type: Types.text() } // <====\n            , { name: 'scope_catalog', type: Types.text() } // <====\n            , { name: 'scope_schema', type: Types.text() } // <====\n            , { name: 'scope_name', type: Types.text() } // <====\n            , { name: 'maximum_cardinality', type: Types.integer } // <====\n            , { name: 'dtd_identifier', type: Types.integer } // <=== INDEX\n            , { name: 'is_self_referencing', type: Types.text(3) }\n            , { name: 'is_identity', type: Types.text(3) } // <==\n            , { name: 'identity_generation', type: Types.text() } // <==\n            , { name: 'identity_start', type: Types.text() } // <==\n            , { name: 'identity_document', type: Types.text() } // <==\n            , { name: 'identity_increment', type: Types.text() } // <==\n            , { name: 'identity_maximum', type: Types.text() } // <==\n            , { name: 'identity_minimum', type: Types.text() } // <==\n            , { name: 'identity_cycle', type: Types.text(3) } // <==\n            , { name: 'is_generated', type: Types.text() } // <==\n            , { name: 'generation_expression', type: Types.text() } // <==\n            , { name: 'is_updatable', type: Types.text(3) } // <==\n        ]\n    };\n\n\n    entropy(t: _Transaction): number {\n        return this.db.listSchemas()\n            .reduce((tot, s) => tot + s.tablesCount(t) * 10, 0);\n    }\n\n    *enumerate(t: _Transaction) {\n        for (const s of this.db.listSchemas()) {\n            for (const it of s.listTables(t)) {\n                yield* this.itemsByTable(it, t);\n            }\n        }\n    }\n\n    make(table: _ITable, i: number, t: IValue<any>): any {\n        if (!t) {\n            return null;\n        }\n        let ret = {};\n        for (const { name } of this._schema.fields) {\n            (ret as any)[name] = null;\n        }\n\n        ret = {\n            ...ret,\n            table_catalog: 'pgmem',\n            table_schema: 'public',\n            table_name: table.name,\n            column_name: t.id,\n            ordinal_position: i,\n            is_nullable: 'NO',\n            data_type: t.type.primary, // <== todo\n            numeric_precision: null, // <== todo\n            numeric_precision_radix: null, // <== todo\n            numeric_scale: null, // <== todo\n\n            udt_catalog: 'pgmem',\n            udt_schema: 'pg_catalog',\n            udt_name: t.type.primary, // <== todo\n\n            dtd_identifier: i, // <== todo\n\n            is_self_referencing: 'NO',\n            is_identity: 'NO',\n\n            is_updatable: 'YES',\n            is_generated: 'NEVER',\n            identity_cycle: 'NO',\n\n\n            [IS_SCHEMA]: true,\n        };\n        setId(ret, `/schema/${table.ownerSchema.name}/table/${table.name}/${i}`);\n        return ret;\n    }\n\n    hasItem(value: any): boolean {\n        return !!value?.[IS_SCHEMA];\n    }\n\n    getIndex(forValue: IValue<any>): _IIndex<any> | nil {\n        if (forValue.id === 'table_name') {\n            return new TableIndex(this, forValue);\n        }\n        return null;\n    }\n\n}\n","import { _ITable, _ISelection, IValue, _IIndex, _IDb, IndexKey, setId, _ISchema, _Transaction, _Explainer } from '../../interfaces-private';\nimport { Schema, nil } from '../../interfaces';\nimport { Types } from '../../datatypes';\nimport { TableIndex } from '../table-index';\nimport { ReadOnlyTable } from '../readonly-table';\n\nconst IS_SCHEMA = Symbol('_is_schema');\nexport class TablesSchema extends ReadOnlyTable implements _ITable {\n\n    get ownSymbol() {\n        return IS_SCHEMA;\n    }\n\n    isOriginOf(v: IValue): boolean {\n        return v.origin === this || v.origin === this.selection;\n    }\n\n    _schema: Schema = {\n        name: 'tables',\n        fields: [\n            { name: 'table_catalog', type: Types.text() }\n            , { name: 'table_schema', type: Types.text() }\n            , { name: 'table_name', type: Types.text() }\n            , { name: 'table_type', type: Types.text() }\n            , { name: 'self_referencing_column_name', type: Types.text() }\n            , { name: 'reference_generation', type: Types.text() }\n            , { name: 'user_defined_type_catalog', type: Types.text() }\n            , { name: 'user_defined_type_schema', type: Types.text() }\n            , { name: 'user_defined_type_name', type: Types.text() }\n            , { name: 'is_insertable_into', type: Types.text(3) }\n            , { name: 'is_typed', type: Types.text(3) }\n            , { name: 'commit_action', type: Types.text() }\n        ]\n    };\n\n    entropy(t: _Transaction): number {\n        return this.db.listSchemas()\n            .reduce((tot, s) => tot + s.tablesCount(t), 0);\n    }\n\n    *enumerate(t: _Transaction) {\n        for (const s of this.db.listSchemas()) {\n            for (const it of s.listTables(t)) {\n                yield this.make(it);\n            }\n        }\n    }\n\n    make(t: _ITable<any>): any {\n        if (!t) {\n            return null;\n        }\n        const ret = {\n            table_catalog: 'pgmem',\n            table_schema: 'public',\n            table_name: t.name,\n            table_type: 'BASE TABLE',\n            self_referencing_column_name: null,\n            reference_generation: null,\n            user_defined_type_catalog: null,\n            user_defined_type_schema: null,\n            user_defined_type_name: null,\n            is_insertable_into: 'YES',\n            is_typed: 'NO',\n            commit_action: null,\n            [IS_SCHEMA]: true,\n        };\n        setId(ret, '/schema/table/' + t.name);\n        return ret;\n    }\n\n    hasItem(value: any): boolean {\n        return !!value?.[IS_SCHEMA];\n    }\n\n    getIndex(forValue: IValue<any>): _IIndex<any> | nil {\n        if (forValue.id === 'table_name') {\n            return new TableIndex(this, forValue);\n        }\n        return null;\n    }\n\n}\n"],"sourceRoot":""}